---
"title": "Erste Schritte in die Parallelität"
"summary": "Dieser Artikel beschreibt die Erfahrung des Autors mit der parallelen Programmierung durch eine kleine Aufgabe, bei der ein einfaches Demo zur Nebenläufigkeitssteuerung mit den Python-Modulen queue, signal und time implementiert wurde. Der Artikel erklärt die Funktionen der drei Module: queue dient als Nachrichtenwarteschlange, signal zum Abfangen des KeyboardInterrupt-Signals und time ermöglicht es dem Hauptthread, die Unterbrechung zu erkennen. Der Autor vertieft die Bedeutung von Nachrichtenwarteschlangen in der Multithread-Programmierung sowie den Gedanken, dass Systemdesign Details kapseln und Ereignisse zur Zusammenarbeit nutzen sollte, um die Kopplung zu reduzieren, und betont das Konzept des 'Designs für Veränderung'."
"tags":
  - "python"
  - "Parallelität"
  - "Multithreading"
  - "Nachrichtenwarteschlange"
  - "Systemdesign"
"date": "2017-05-07"
---

---
title: Erste Schritte in die Parallelität
date: 2017-05-07
taxonomies:
  tags:
    - python
    - Parallelität
---

Gut, eine kürzliche kleine Aufgabe hat mich dazu gebracht, sinnvolle parallele Programmierung kennenzulernen.

<!--more-->

## Demo

Daher habe ich mit den Python-Modulen `queue`, `signal` und `time` ein kleines Demo erstellt, das zwar nicht wirklich multithreaded ist, aber zur Veranschaulichung dient:

```python
# -*- coding: utf-8 -*-
# @Author: Michale
# @Date:   2017-05-04 15:00:41
# @Last Modified by:   Michale
# @Last Modified time: 2017-05-07 00:46:52
import signal
import queue
import time


class TestClass(object):
    queue = queue.Queue()

    def __init__(self):
        signal.signal(signal.SIGINT, self.stopIfPressKill)

    def stopIfPressKill(self, mySignal, stack):
        if mySignal == signal.SIGINT:
            print('you pressed CTRL-C')
            self.queue.put_nowait('stop')
            print(self.queue.qsize())

    def mainThread(self):
        while True:
            time.sleep(1)
            if not self.queue.empty():
                data = self.queue.get()
                print(data)
                if data == 'stop':
                    break
                else:
                    self.queue.put(data)


if __name__ == '__main__':
    yoo = TestClass()
    yoo.mainThread()

```

Erklärung der Funktionen der drei Module:

- `queue`: Dient als Nachrichtenwarteschlange, was hier etwas übertrieben erscheint.
- `signal`: Wird verwendet, um nach einem `KeyboardInterrupt` das Stoppsignal in die Nachrichtenwarteschlange zu legen.
- `time`: Ermöglicht es dem Hauptthread, diesen `KeyboardInterrupt` zu erkennen.

## Gedankengang

Die Einführung von Multithreading macht es schwierig, nicht-primäre Threads nach ihrem Start zu kontrollieren, was Menschen dazu zwingt, Methoden wie Nachrichtenwarteschlangen für die Kommunikation zwischen Threads zu verwenden.

Aber unabhängig davon, ob es sich um Multithreading handelt oder nicht, sollten die verschiedenen Module eines Systems ihre Details kapseln und Ereignisse für ihre Zusammenarbeit nutzen. Dies trägt erheblich dazu bei, die Kopplung des Systems zu verringern, und ist auch ein gutes Designprinzip für Systeme: **Entwurf für Veränderung.**