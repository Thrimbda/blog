---
"title": "Quellcode-Lektüre: Designanalyse von Harbor-Operator"
"summary": "Dieser Artikel analysiert detailliert das Quellcode-Design von Harbor-Operator, mit Schwerpunkt darauf, wie es Abhängigkeiten zwischen Ressourcen durch einen Abhängigkeitsgraphen (Dependency Graph) löst, mehrere CRD-Abstimmungslogiken mit einem einzigen Controller implementiert und die Wiederverwendbarkeit durch Konfiguration des Codes mittels ResourceManager erhöht. Der Artikel untersucht auch die Praxis von Harbor-Operator auf der Golang- und Kubernetes-Plattform und zeigt, wie es als Beispiel für das Designprinzip 'the right thing' ein Gleichgewicht zwischen Einfachheit, Konsistenz und Vollständigkeit findet, wertvolle Designreferenzen für die Operator-Entwicklung bietet."
"tags":
  - "Harbor-Operator"
  - "Quellcodeanalyse"
  - "Kubernetes"
  - "Operator Pattern"
  - "Abhängigkeitsgraph"
  - "Controller-Design"
  - "Golang"
  - "Softwarearchitektur"
"date": "2022-01-30"
---

<!--more-->

<a id="orgdafefdb"></a>

## Vorbereitungen

<a id="org081213e"></a>

### Warum Harbor-Operator?

<a id="org55a74c9"></a>

#### Worse is Better?

Was ist gute Software?

In einem berühmten Artikel aus den späten 80er Jahren, *The Rise of Worse is Better*, erwähnt der Autor, dass gutes Softwaredesign die vier Eigenschaften *Einfachheit*, *Korrektheit*, *Konsistenz* und *Vollständigkeit* berücksichtigen sollte.

Der Autor erwähnt zwei Softwaredesign-Philosophien, die vorläufig als *the right thing* und *worse is better* bezeichnet werden (es sei darauf hingewiesen, dass diese Benennung nicht abwertend gemeint ist); beide Philosophien drehen sich um die oben genannten Eigenschaften, unterscheiden sich jedoch in der Priorisierung dieser Eigenschaften.

---

<a id="orgbebeeee"></a>

##### The right thing

-   **Einfachheit** - Das Design muss einfach und verständlich sein, einfache Schnittstellen sind wichtiger als einfache Implementierungen.
-   **Korrektheit** - Das Design muss korrekt sein, hier darf es keine Kompromisse geben.
-   **Konsistenz** - Konsistenz ist genauso wichtig wie Korrektheit, daher können Einfachheit und Vollständigkeit etwas zurückstehen.
-   **Vollständigkeit** - Das Design muss eine Vielzahl möglicher Szenarien berücksichtigen und darf die Vollständigkeit nicht übermäßig zugunsten der Einfachheit opfern.

<a id="org948c614"></a>

##### Worse is better

-   **Einfachheit** - Das Design muss einfach und verständlich sein, einfache Implementierungen sind wichtiger als einfache Schnittstellen, Einfachheit ist die wichtigste Eigenschaft.
-   **Korrektheit** - Das Design muss korrekt sein, allerdings ist Einfachheit etwas wichtiger als Korrektheit.
-   **Konsistenz** - Das Design darf nicht zu inkonsistent sein, Konsistenz kann zugunsten der Einfachheit geopfert werden; bei Gewährleistung der Einfachheit kann Konsistenz für Vollständigkeit geopfert werden.
-   **Vollständigkeit** - Das Design muss eine Vielzahl möglicher Szenarien berücksichtigen, Vollständigkeit kann jederzeit geopfert werden, um die Einfachheit des Designs zu gewährleisten.

---

Anschließend führt der Autor viele Beispiele für beide Philosophien an, um zu argumentieren, warum *worse-is-better* damals die Softwarebranche eroberte.

Diese beiden Philosophien sind nicht besser oder schlechter, heute finden wir sie auch in unserer Umgebung, und die Realität bewegt sich oft zwischen beiden. Wir möchten exzellente, ästhetisch wertvolle Designs erstellen, müssen aber auch Kosten und menschliche Faktoren berücksichtigen. Letztendlich müssen wir qualitativ hochwertige, funktionierende Software liefern, um reale Probleme zu lösen, und die Kosten für die Entwicklung und Wartung der Software dürfen den Wert des Problems selbst nicht übersteigen.

<a id="org514ce0b"></a>

#### Golang - die Sprache

Golang ist fast ein Paradebeispiel für die *worse is better*-Philosophie:

-   Es bündelt die jahrelange Erfahrung von Google mit C++.
-   Es ist so einfach, ohne komplexe Funktionen, dass es für die Lösung eines Problems im Grunde nur einen *building block* gibt, was bedeutet:
    -   Es erfordert kaum Aufwand, die Sprache selbst zu beherrschen.
    -   Der Code ist sehr lesbar.
-   Schnelle Kompilierung, sogar auf Kosten von Generics für Kompiliergeschwindigkeit.
-   Parallele Aufgaben können sehr einfach über Goroutinen ausgeführt werden.
-   Die Ausnahmebehandlung (*exception stack*) als Sprachmerkmal wurde weitgehend aufgegeben, Fehlerprüfung und -behandlung werden erzwungen.
-   Einmal kompiliert, überall ausführbar.

<a id="org2432232"></a>

#### Kubernetes - die Plattform

Kubernetes ist allen bekannt, daher werde ich nicht den Besserwisser spielen und es kurz zusammenfassen: Es bietet ein konzeptionell sehr einfaches API-Design, ergänzt durch einen Abstimmungsmechanismus (*reconciliation*) aus der Kybernetik, der die automatisierte Bereitstellung, Skalierung und Verwaltung containerisierter Software ermöglicht.

K8s erlaubt Entwicklern durch die Offenlegung dieser API-Spezifikation und des Abstimmungsmechanismus, seine Fähigkeiten zu erweitern. Entwickler können das *Operator Pattern* implementieren: Das Wissen über Softwarekonfiguration, Bereitstellung (*Day-1*) sowie Betrieb, Backup und Failover (*Day-2*) wird in Software geschrieben, die die Software bedient, um diese komplexen und fehleranfälligen Operationen zu automatisieren, die Zuverlässigkeit zu erhöhen und die Kosten zu senken.

---

Der Grund für die Wahl von Harbor Operator ist sein exzellentes Design. Auf einer hervorragenden Plattform und mit einfachen Sprachmerkmalen, ohne übermäßige Tricks, implementiert es durch einige Schlüsseldesigns, die den SOLID-Designprinzipien entsprechen, ein pragmatisches und ästhetisch wertvolles Softwaresystem, das als Praktiker der *the right thing*-Philosophie angesehen werden kann.

Der Code des Autors hat fast keine Kommentare, ist aber außergewöhnlich gut lesbar, was auch dem gesamten System zu verdanken ist.

<a id="org6815286"></a>

## Ziele

Die Abstraktion und Vereinfachung von Problemen geht zwangsläufig mit einem Verlust an Flexibilität einher, während Harbor Operator die Flexibilität vollständig aufgibt, um maximale kognitive Entlastung zu erreichen, sodass die Entwicklung eines Operators eher der Deklaration einer Softwarekonfiguration gleicht.

Das manuelle Schreiben eines Operators mit client-go ist aufgrund des Fehlens von Generics in Golang eine Qual, das Projekt wäre mit einer riesigen Menge an *boilerplate code* (Vorlagencode) übersät. Ich glaube, selbst wenn jemand wirklich mit client-go von Grund auf schreiben würde, würde niemand wirklich bei Null anfangen.

Daher entstand kubebuilder, das die Erstellung des Kubernetes-Clients, das Abhören von Anfragen des Kubernetes API-Servers und deren Einreihung in Warteschlangen in öffentliche Bibliotheken wie *controller runtime* und *controller tools* abstrahiert und für Entwickler Gerüstcode generieren kann, um sich auf die Geschäftslogik zur Verarbeitung von API-Objektänderungsanfragen zu konzentrieren.

Kubebuilder bewahrt noch einen Hauch von Vielfalt in der Geschäftslogik, während Harbor Operator darauf aufbauend weiter nach Perfektion strebt, Flexibilität vollständig zugunsten konzeptioneller Konsistenz und Einfachheit opfert, und die Geschäftsanforderungen, denen es gegenübersteht, eignen sich tatsächlich sehr gut für diesen Ansatz.

Daher ist unser Hauptziel in dieser Quellcode-Lektüre, von Harbor Operator zu lernen:

-   Wie *Day-1*-Operationen durchgeführt werden.
-   Wie die Redundanz im Operator-Code weiter reduziert wird, indem derselbe Controller-Code verwendet wird, um Controller für elf CRDs auf verschiedenen Ebenen zu implementieren.
-   Wie DAG zur Lösung von Abhängigkeiten zwischen Ressourcen genutzt wird; der Autor scheint dafür sogar ein Patent angemeldet zu haben.

Darüber hinaus werden wir uns nicht schwerpunktmäßig mit folgenden Aspekten befassen:

-   *Day-2*-Operationen in Harbor Operator; tatsächlich ist diese Funktion in der aktuellen Version noch nicht stabil.
-   Dem Quellcode und den Funktionen von Harbor selbst.

<a id="org345a335"></a>

## Quellcode-Lektüre

<a id="org1198d5f"></a>

### Statische Struktur

<a id="orgb32de77"></a>

#### Verzeichnisstruktur

Hier sind nur die Verzeichnisse aufgelistet.

```
    root
    ├── apis
    │   ├── goharbor.io
    │   │   └── v1alpha3
    │   └── meta
    │       └── v1alpha1
    ├── controllers
    │   ├── controller_string.go
    │   ├── controllers.go
    │   └── goharbor
    │       ├── chartmuseum
    │       ├── controller_test.go
    │       ├── core
    │       ├── exporter
    │       ├── harbor
    │       ├── harborcluster
    │       ├── internal
    │       ├── jobservice
    │       ├── notaryserver
    │       ├── notarysigner
    │       ├── portal
    │       ├── registry
    │       ├── registryctl
    │       └── trivy
    ├── pkg
    │   ├── builder
    │   ├── cluster
    │   │   ├── controllers
    │   │   │   ├── cache
    │   │   │   ├── common
    │   │   │   ├── database
    │   │   │   │   └── api
    │   │   │   ├── harbor
    │   │   │   └── storage
    │   │   ├── gos
    │   │   ├── k8s
    │   │   └── lcm
    │   ├── config
    │   │   ├── harbor
    │   │   └── template
    │   ├── controller
    │   │   ├── errors
    │   │   ├── internal
    │   │   │   └── graph
    │   │   └── mutation
    │   ├── event-filter
    │   ├── exit
    │   ├── factories
    │   │   ├── application
    │   │   ├── logger
    │   │   └── owner
    │   ├── graph
    │   ├── harbor
    │   ├── image
    │   ├── manager
    │   ├── resources
    │   │   ├── checksum
    │   │   └── statuscheck
    │   ├── scheme
    │   ├── setup
    │   ├── status
    │   ├── template
    │   ├── tracing
    │   ├── utils
    │   │   └── strings
    │   └── version
    ...
```

<a id="orgfc0f08e"></a>

#### Wichtige Schnittstellen

![img](https://0xc1.space/images/2022/01/30/harbor-operator-class.svg)

<a id="org290c6c2"></a>

#### Systemarchitektur

Bis Version v1.0.1 ist Harbor Operator hauptsächlich für *Day-1*-Operationen des Harbor-Systems verantwortlich.
![img](https://0xc1.space/images/2022/01/30/harbor-operator-arch.png)

<a id="org41c8944"></a>

### Das Wesentliche im Blick: HarborCluster

Lassen Sie uns zunächst einige weniger kritische Teile ausblenden: Die CRD *HarborCluster* und die Implementierung ihres Controllers.

Warum ist sie besonders? Betrachten Sie zunächst ihre Position in der Systemarchitektur: Sie befindet sich auf der obersten Ebene und verwaltet das Harbor-System selbst sowie alle davon abhängigen zustandsbehafteten Dienste. Dies muss aus der Projektgeschichte und ihrer besonderen Stellung in der Systemarchitektur erklärt werden.

Aus systemarchitektonischer Sicht weist die Definition der HarborCluster-CRD große Ähnlichkeiten mit der Harbor-CRD auf, der Code enthält viele Redundanzen und sieht nicht sehr elegant aus. Dies liegt daran, dass sie als die oberste (äußerste) CRD im gesamten System direkt dem Benutzer gegenübersteht; sie muss dem Benutzer alle notwendigen Konfigurationsoptionen für die Bereitstellung von Harbor bieten. Da Harbor selbst ein zustandsloser Dienst ist, erfordert eine vollständige Bereitstellung außerdem, dass die HarborCluster-CRD alle zustandsbehafteten Dienste verwaltet, von denen Harbor abhängt, einschließlich Postgres, Minio und Redis.

Die notwendigen Informationen für das Harbor-System selbst sind bereits in der Harbor-CRD definiert, daher besteht der redundante Teil in der HarborCluster-CRD darin, diese Informationen vollständig und korrekt an die Harbor-CRD weiterzugeben. Darüber hinaus muss die HarborCluster-CRD auch die CRDs der zustandsbehafteten Dienste verwalten, die außerhalb ihrer eigenen Zuständigkeitsgrenzen liegen, und kann daher nicht vollständig die Controller-Logik aus Harbor und allen Unterkomponenten von Harbor verwenden.

Aus historischer Sicht war Harbor Operator ursprünglich ein privates Projekt von OVH Cloud und wurde später der goharbor-Community gespendet. Betrachtet man den Git-History, liegt der Grund für die große Inkonsistenz zwischen der CRD-Definition von HarborCluster und ihrer Controller-Implementierung im Vergleich zu anderen Controllern im System darin, dass sie ein späterer Community-Beitrag ist und ihre Funktionen bei der ursprünglichen Designphase von Harbor Operator nicht berücksichtigt wurden.

Die Implementierung des HarborCluster-Controllers selbst unterscheidet sich nicht wesentlich von den meisten Controllern, die mit Controller-Runtime implementiert sind, und wird daher nicht detailliert untersucht.

---

HarborCluster Controller

![img](https://0xc1.space/images/2022/01/30/harbor-cluster-controller.png)

---

Harbor Core Controller

![img](https://0xc1.space/images/2022/01/30/harbor-core-controller.png)

---

<a id="orgd9c3526"></a>

### Lösung von Abhängigkeiten zwischen Ressourcen: Dependency Graph

Der Abhängigkeitsgraph ist ein relativ unabhängiges Modul im gesamten Projekt, aber es fungiert tatsächlich als Ausführungsmotor für alle Controller in Harbor Operator. Im Wesentlichen wird beobachtet, dass zwischen verschiedenen Ressourcentypen in Kubernetes Abhängigkeiten bestehen; die Bereitstellung und Abstimmung einiger Ressourcen hängt von der Bereitstellung und Abstimmung anderer Ressourcen ab, z. B. kann ein Deployment von einem ConfigMap abhängen; letztendlich bilden diese Abhängigkeiten einen Abhängigkeitsgraphen, der tatsächlich ein DAG sein sollte. Hier benötigen wir die folgende Schnittstellendefinition:

```go
    package graph

    type Resource interface{}

    type RunFunc func(context.Context, Resource) error

    type Manager interface {
            Run(ctx context.Context) error
            AddResource(ctx context.Context, resource Resource, blockers []Resource, run RunFunc) error
    }

    type resourceManager struct {
       resources map[Resource][]Resource
       functions map[Resource]RunFunc

       lock sync.Mutex
    }
```

-   Dabei definiert `Resource` eine abstrakte Ressource. Da dieses Modul nicht darauf achtet, was eine Ressource genau darstellt, und um bei den Einschränkungen der Ausdruckskraft der Sprache maximale Flexibilität zu bewahren, wird der Top-Typ `interface{}` verwendet.
-   `RunFunc` ist dafür verantwortlich, wie eine Operation für eine `Resource` durchgeführt wird. Hier steht `RunFunc` vor einem Typsicherheitsproblem: `interface{}` bedeutet, dass der Compiler nichts über diesen Typ weiß und daher nichts damit anfangen kann, aber `RunFunc` muss mit diesem Typ, der alles sein kann, etwas anstellen. Daher gehen wir davon aus, dass eine Typumwandlung (*type assertion*) durchgeführt werden muss. Wenn jedes `RunFunc` für eine Ressource manuell in einen konkreten Typ umgewandelt werden müsste, wäre das sehr langweilig und widerlich; später werden wir sehen, wie Harbor Operator die Drecksarbeit an einer Stelle konzentriert.
-   `Manager` hat nur zwei Methoden: Ressource hinzufügen und diesen Graphen ausführen; beide müssen untersucht werden.
-   Die Datenstruktur `resourceManager`, die `Manager` implementiert, ist ebenfalls einfach definiert:
    -   Eine Map von `resource -> blockers`
    -   Eine Map von `resource -> runFunc`
    -   Ein `lock` zur Behandlung der Nebenläufigkeit bei Map-Operationen. Hier können wir sehen, dass der Autor Datenstrukturen wie `Sync.Map`, die nebenlä