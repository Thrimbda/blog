---
"title": "First Exploration of Concurrency"
"summary": "This article describes the author's experience with concurrent programming through a small assignment, using Python's queue, signal, and time modules to create a demonstration of concurrent control. The article explains the roles of these three modules in the demo: queue serves as a message queue for passing signals, signal is used to capture KeyboardInterrupt, and time allows the main thread to respond to the interrupt promptly. The author further discusses the importance of message queues in multithreaded programming, noting that they facilitate inter-thread communication and reduce system coupling. The author emphasizes that good system design should be designed for change, achieving module collaboration through encapsulation of details and event-driven approaches."
"tags":
  - "python"
  - "concurrency"
  - "multithreading"
  - "message queue"
  - "system design"
"date": "2017-05-07"
---

---
title: First Exploration of Concurrency
date: 2017-05-07
taxonomies:
  tags:
    - python
    - concurrency
---

Great! A recent small assignment allowed me to tangibly explore meaningful concurrent programming.

<!--more-->

## Demo

So, I created a small demo using Python's `queue`, `signal`, and `time` modules. It's not truly multithreaded but serves as an illustrative example:

```python
# -*- coding: utf-8 -*-
# @Author: Michale
# @Date:   2017-05-04 15:00:41
# @Last Modified by:   Michale
# @Last Modified time: 2017-05-07 00:46:52
import signal
import queue
import time


class TestClass(object):
    queue = queue.Queue()

    def __init__(self):
        signal.signal(signal.SIGINT, self.stopIfPressKill)

    def stopIfPressKill(self, mySignal, stack):
        if mySignal == signal.SIGINT:
            print('you pressed CTRL-C')
            self.queue.put_nowait('stop')
            print(self.queue.qsize())

    def mainThread(self):
        while True:
            time.sleep(1)
            if not self.queue.empty():
                data = self.queue.get()
                print(data)
                if data == 'stop':
                    break
                else:
                    self.queue.put(data)


if __name__ == '__main__':
    yoo = TestClass()
    yoo.mainThread()

```

Explanation of the three modules' roles:

- `queue`: Acts as a message queue, which is a bit overkill here.
- `signal`: Used to capture `KeyboardInterrupt` and place a stop signal into the message queue.
- `time`: Allows the main thread to capture this `KeyboardInterrupt`.

## Philosophy

The introduction of multithreading makes it difficult to control non-main threads once they are started, forcing the use of methods like message queues for inter-thread communication.

However, regardless of whether multithreading is involved, each module in a system should encapsulate its details and collaborate through events. This greatly helps reduce system coupling and is a key design principle of a good system: **designed for change.**