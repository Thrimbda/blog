---
"title": "Ein RBAC-Demo: Für Aiur"
"summary": "Dieser Artikel stellt detailliert das vom Autor entwickelte RBAC-Demo-Projekt \"Für Aiur\" vor, das im Hintergrund von StarCraft ein vereinfachtes Spielszenario simuliert. Der Artikel erläutert den Analyse- und Designprozess des Projekts, einschließlich der Definition von Subjekten, Rollen, Ressourcen und Berechtigungen sowie der Konfiguration der SA (Subjekt-Rolle) und PA (Rolle-Berechtigung) Beziehungen. Der Implementierungsteil nutzt das Flask-Framework von Python, um einen RESTful-Dienst aufzubauen, verwaltet die RBAC-Beziehungen über Dateien anstelle einer Datenbank und bietet konkrete Codebeispiele sowie Erläuterungen zur Geschäftslogik. Abschließend fasst der Artikel den Anwendungswert von RBAC in Systemen und die Erkenntnisse des Autors aus der Praxis zusammen."
"tags":
  - "Systemdesign und -analyse"
  - "RESTful"
  - "RBAC"
  - "Python"
  - "Flask"
  - "StarCraft"
  - "Demo"
  - "Zugriffskontrolle"
"date": "2017-05-11"
---

---
title: Ein RBAC-Demo: Für Aiur
date: 2017-05-11
taxonomies:
  tags:
    - Systemdesign und -analyse
    - RESTful
    - RBAC
---

Basierend auf dem Verständnis von RBAC aus dem vorherigen Artikel und aufgrund von Aufgabenanforderungen werde ich ein einfaches Demo als RBAC-Praxis erstellen.

Ich habe nicht die Absicht, das Demo übermäßig komplex zu gestalten. Mein Ziel ist es, das Problem zu veranschaulichen, daher gilt auch hier: "Klein, aber fein."

Was ist also das Ziel dieses Demos und was kann es tun?

<!--more-->

## Analyse und Design

Um es interessant zu gestalten und das Problem angemessen widerzuspiegeln, werde ich in meinem Demo eine stark vereinfachte Szene simulieren, in der jede Einheit auf wundersame Weise über subjektive Initiative verfügt – die Situation, der ein Protoss-Spieler in einer StarCraft-Partie gegenübersteht.

Ein gutes Demo braucht einen guten Namen, daher heißt dieses Demo: **Für Aiur!** (Aiur ist der Heimatplanet der Protoss. Jeder Zealot sagt beim Beamen auf das Schlachtfeld diesen begeisterten Satz: "Für Aiur!")

In **Für Aiur** führst du dein Team an, um genügend Zealot-Krieger zu produzieren, den Zerstörer Amon zu vernichten und das gesamte Universum zu retten. Wenn du nicht genug Zealots hast, wirst du scheitern, die Sterne flüstern und alles wird vernichtet.

All dies spiegelt sich in einem RESTful-Dienst wider, der mit dem Flask-Framework von Python geschrieben wurde.

> Eigentlich könnten in einem realen Szenario alle Subjekte außer dem Spieler erschaffen werden und daher als Ressourcen betrachtet werden. Um RBAC zu verdeutlichen, habe ich ihnen jedoch die folgenden Einschränkungen hinzugefügt:
>
> - Die wenigen in diesem Demo bereitgestellten Subjekte sind einzigartig und existieren immer, als wären sie unverwechselbar. Dadurch wird auch jede Möglichkeit ausgeschlossen, dass Subjekte rekursiv erschaffen werden können (z.B. kann eine Sonde einen Nexus bauen, und ein Nexus kann Sonden produzieren).
> - Tatsächlich benötigen Warpgates die Energie von Pylonen, um zu funktionieren, aber das wird hier nicht dargestellt. Ich erkläre es damit, dass unsere Warpgates Energie von der Protoss-Flaggschiff-Mutterschiff Spear of Adun (Speer von Adun) im geosynchronen Orbit erhalten, sodass Pylonen nur als Ressource betrachtet werden, die das Bevölkerungslimit bereitstellen.

Diese Partie enthält die folgenden Objekte:

### Subjekt (Subject)

- Spieler (du) thrimbda
- Sonde (grundlegende Arbeitseinheit, kann Ressourcen sammeln und Gebäude bauen) probe
- Warpgate (produziert Zealots, eine Kampfeinheit) gateway

#### Rolle (Role)

- Archon (Oberbefehlshaber, verwaltet alle Ressourcen) archon
- Kristallsammler (nur Sonden können diese Aufgabe übernehmen) crystal_collector
- Portal für Zealot-Beaming (Leuchtfeuer, das das Beamen von Protoss-Kriegern unterstützt) portal
- Pylonen-Erbauer (mit Pylonen können wir genügend Bevölkerungslimit für das Beamen von Zealots haben) pylon_transporter

### Ressource (Resource)

- Ungesammelte Kristalle (werden zum Bau von Pylonen und zum Beamen von Zealots verwendet, Anfangswert unbekannt)
- Gesammelte Kristalle (werden zum Bau von Pylonen und zum Beamen von Zealots verwendet, Anfangswert 0)
- Bevölkerungslimit (stellt Energie für das Beamen bereit, also das, was wir als Bevölkerung bezeichnen, Anfangswert 0)
- Zealot (Kampfeinheit, deine Krieger, um das Universum zu retten, Anfangswert 0)

### Berechtigung (Permission)

> Da jede Operation auf eine Ressource eine Berechtigung ist, listen wir hier nicht separat die Operationen auf, sondern geben direkt die Berechtigungen und ihre Beschreibungen an.

- Kristalle sammeln (maximal 1000 Einheiten pro Sammelvorgang)
- Ungesammelte Kristalle beobachten (Gesamtmenge anzeigen)
- Statusbericht (meldet die aktuellen Ressourcenmengen, die du besitzt)
- Amons Stärke auskundschaften (berechnet die benötigte Anzahl an Zealots)
- Pylon bauen (jeder Pylon bietet 10 Bevölkerungseinheiten und kostet 100 Kristalle)
- Zealot produzieren (jeder Zealot verbraucht 2 Bevölkerungseinheiten und kostet 100 Kristalle)
- Amon angreifen (Sieg oder Tod!)

### SA

> Die vielen-zu-vielen Beziehungen zwischen Subjekt-Rolle und Rolle-Berechtigung werden mit der mehrdimensionalen Tupel-Datenstruktur von Python dargestellt, ebenso in der Implementierung. Daher wird in dieser Anwendung keine Datenbank verwendet.

```python
subject_role = (('thrimbda', 'archon'),
                ('probe', 'crystal_collector'),
                ('probe', 'pylon_transporter'),
                ('gateway', 'portal'))
```

### PA

```python
role_permission = (('archon', 'get_status'),
                   ('archon', 'for_aiur'),
                   ('archon', 'scout'),
                   ('crystal_collector', 'get_crystal'),
                   ('crystal_collector', 'crystal_status'),
                   ('pylon_transporter', 'get_status'),
                   ('pylon_transporter', 'transport_pylon'),
                   ('portal', 'transport_zealot'),
                   ('portal', 'get_status'))
```

## Implementierung

[Repository-URL](https://github.com/Thrimbda/my-life-for-Aiur)

[Online-Bereitstellung](https://my-life-for-aiur.herokuapp.com/) (langsam)

### Übersicht

Zusammenfassend habe ich mit dem Flask-Framework von Python einen RESTful-Dienst erstellt. Die gesamte Anwendung beinhaltet keinen Frontend-Teil, daher gibt es auch keine Sicherheitsprobleme wie das Umgehen des Frontends.

Ein Merkmal dieses Demos ist, dass keine Datenbank verwendet wird. RBAC schreibt die Verwendung einer Datenbank nicht zwingend vor, und es ist eine intuitive und natürliche Sache, in RBAC eine Datenbank zu verwenden. In **Für Aiur** verwenden wir jedoch keine Datenbank, sondern stellen die RBAC-`Subjekt-Rolle-Berechtigung`-Beziehungen in Dateiform dar. Datenbanken haben sich auf Basis von Dateisystemen entwickelt. Hier werden Dateien verwendet, weil das System einfach genug ist, um die Komplexität des Systems weiter zu reduzieren und das Problem zu veranschaulichen. Die konkrete Dateiform ist in den obigen SA- und PA-Beziehungserklärungen zu sehen.

### Über RESTful

Hier kurz zu RESTful (**Re**presentational **S**tate **T**ransfer)

Wie der Name schon sagt: (Ressourcen-)Darstellungsschicht-Zustandsübertragung

In einem Webdienst sind die bereitgestellten Dienste die Ressourcen des Systems, die in Form von URIs dargestellt werden. Die Form des Dienstes ist die Operation auf die Ressource (Zustandsübertragung), die in Form von HTTP-Verben dargestellt wird. Mehrere Konzepte darin können gut den Ressourcen und Operationen in RBAC entsprechen. Daher muss ich lediglich die Berechtigungsverwaltung in RBAC auf die Operationen an Ressourcen in REST anwenden.

### Die verschiedenen Objekte in RBAC

Wie in diesen beiden Konfigurationsdateien zu sehen ist, können wir neben SA und PA implizit S, R, P ableiten:

```python
# Leite die S- und R-Listen aus dem obigen Tupel subject_role ab
subjects = list(set([item[0] for item in subject_role]))
roles = list(set([item[1] for item in subject_role]))
```

SE kann gut mit der Session in einer Webanwendung korrespondieren, als temporäres Objekt eines Subjekts während einer Anmeldung:

```python
# Das Subjekt meldet sich über die API des Spear of Adun-Taktikmanagementsystems an. Hier ist session ein globales Objekt von Flask, dessen Implementierungsdetails nicht weiter erläutert werden.
class SpearOfAdun(Resource):
    
    def post(self):
        args = self.putparser.parse_args()
        if args['subject'] is not None:
            abortInvalideSubject(args['subject'])
        if args['role'] is not None:
            abortInvalideRole(args['role'])
        checkRole(args['subject'], args['role'], subject_role)
        session['subject'] = args['subject']
        session['role'] = args['role']
        return {'message': 'login as %s using %s' % (session['subject'], session['role'])}, 201
```

Da die Modellierung von Subjekt-Rolle letztendlich dazu dient, Berechtigungen zu isolieren und zuzuweisen, damit die Ressourcen im System ordnungsgemäß genutzt und geschützt werden können.

In **Für Aiur** definiere ich Berechtigungen als interne Attribute der Web-API, z.B.:

```python
# API zum Beamen von Zealots
class Zealot(Resource):

    def put(self):
        permission = 'transport_zealot' # Berechtigung
        abortIfSubjectUnauthenticated(session) # Anmeldeüberprüfung
        checkPermission(session['role'], permission, role_permission) # Prüft, ob das Subjekt in dieser Rolle diese Berechtigung anfordern kann
        args = self.putparser.parse_args()
        amount = nexus.transport(args['amount'])
        return {'message': 'transport %d zealot warriors, En Taro Tassadar!' % amount}, 200
```

In den beiden oben als Beispiel genannten APIs stellt jede Klasse eine Ressource im System dar, und die bereitgestellten HTTP-Methoden sind Operationen auf die Ressource.

**Damit sind alle Objekttypen aus RBAC versammelt.**

### Geschäftslogik

Da **Für Aiur** eine echt spielbare Online-Echtzeitstrategie-Spiel-API ist, ist es notwendig, ihre Geschäftslogik zu erläutern:

Das Ziel des Spielers ist: **Ressourcen sammeln, eine Basis bauen und dann eine Armee erschaffen, die deinen Feind in Angst und Schrecken versetzt, um den Dunklen Amon zu besiegen.**

Die einzige Bedingung, um Amon zu besiegen, ist, eine ausreichende Anzahl von Zealots zu haben. Diese Anzahl ist eine zufällig generierte Ganzzahl zwischen 20 und 100. Gleichzeitig generiert das System basierend auf diesen Daten genau genug ungesammelte Kristalle, um Amon zu besiegen.

**Warum genau genug?**

Da das Beamen von Zealots eine ausreichende Menge an Pylonen-Energie und Kristallen erfordert und der Bau von Pylonen, die Energie liefern, ebenfalls Kristalle verbraucht. Wenn du also zu viele Pylonen baust, wirst du **wegen unzureichender Kristalle zum Beamen von Zealots diese entscheidende Schlacht um das Schicksal des gesamten Universums verlieren**.

Die gesamte Logik wird von einem Objekt bereitgestellt, dessen Lebenszyklus die gesamte Schlacht umspannt. Um Probleme zu vermeiden, habe ich eine Thread-Sperre hinzugefügt, um sicherzustellen, dass jede Operation atomar ist.

```python
# Da es der Kern des gesamten Spiels ist, nenne ich es Nexus
import random
from threading import Lock


class Nexus(object):
    _lock = Lock()
    crestalInControl = None
    crestalRemain = None
    populationCap = None
    zealot = None
    status = {}
    _amond = None

    def __init__(self):
        # Initialisiert das Objekt
        self._amond = random.randint(20, 100)
        self.crestalRemain = self._amond * 100 + (self._amond // 5 + 1) * 100
        self.crestalInControl = 0
        self.populationCap = 0
        self.zealot = 0

    def collect(self, amount=1000):
        # Sammelt Kristalle
        with self._lock:
            amount = min(amount, self.crestalRemain)
            self.crestalRemain -= amount
            self.crestalInControl += amount
            return amount

    def transport(self, amount=5):
        # Beamt Zealots
        with self._lock:
            capacity = self.populationCap / 2
            available = self.crestalInControl / 100
            amount = min(amount, capacity, available)
            self.zealot += amount
            self.crestalInControl -= amount * 100
            self.populationCap -= amount * 2
            return amount

    def build(self, amount=1):
        # Baut Pylonen
        with self._lock:
            available = self.crestalInControl / 100
            amount = min(amount, available)
            self.populationCap += amount * 10
            self.crestalInControl -= amount * 100
            return amount

    def forAiur(self):
        # Für Aiur kämpfen!
        with self._lock:
            if self.zealot >= self._amond:
                return True
            else:
                return False

    def getStatus(self, role):
        # Ruft den Status ab
        if role == 'archon':
            return {
                'crestalInControl': self.crestalInControl,
                'crestalRemain': self.crestalRemain,
                'populationCap': self.populationCap,
                'zealot': self.zealot
            }
        elif role == 'pylon_transporter':
            return {
                'crestalInControl': self.crestalInControl,
                'populationCap': self.populationCap
            }
        elif role == 'portal':
            return {
                'crestalInControl': self.crestalInControl,
                'populationCap': self.populationCap,
                'zealot': self.zealot
            }
        else:
            return {}


nexus = Nexus() # Instanziiert das Objekt
```

## Schlusswort

Eigentlich ist jede Partie in StarCraft II ein typisches DAC-Modell: Der Spieler beherrscht alles, und alle Operationen im Spiel können als Zustandstransformation der beiden Grundressourcen Kristalle und Vespengas (das hier vereinfacht wurde) betrachtet werden, um die vom Spieler benötigten Ressourcen (Produktionseinheiten, Kampfeinheiten) zu werden und die Ressourcen des Gegners zu verbrauchen, um die Partie zu gewinnen. Dies zeigt, dass der Gedanke von RESTful-Diensten sehr universell ist.

In dem kleinen Spiel **Für Aiur** habe ich mehrere Rollen festgelegt und ein RBAC-Modell konstruiert.

In dieser Praxis habe ich die Anwendung von RBAC in einem System verstanden und außerdem mehr über das großartige Flask-Framework gelernt, die RESTful-Idee tiefer verstanden und viele Erkenntnisse gewonnen.