---
"title": "実習日誌（一）"
"summary": "本稿は、筆者が実習三日目に記した日誌であり、Springフレームワークを学んだ初めての印象を共有し、そのコードのエレガントさに感銘を受けたと述べています。JSP、Django、Flaskに至るまでのWeb開発技術の経験を振り返り、それらとSpringの違いや類似点を比較しています。特に、SpringとFlaskの軽量さと柔軟性における類似点を指摘しています。また、RESTfulアーキテクチャの利点、例えばフロントエンドとバックエンドの分離やHTTPプロトコルの特性の活用についても考察しています。最後に、筆者は自身の理解が浅く、IoCやDIといったSpringのコア機能にはまだ深く踏み込んでいないと謙遜しつつも、Java言語とSpringフレームワークへの好感を示し、今後の学習への期待を表明しています。"
"tags":
  - "実習"
  - "Springフレームワーク"
  - "Java"
  - "Web開発"
  - "RESTful"
  - "Flask"
  - "プログラミング学習"
  - "技術比較"
"date": "2017-02-22"
---

---
title: 実習日誌（一）
date: 2017-02-22 22:55:06
taxonomies:
  tags:
    - 日常
---

さて、今日は実習の三日目です。現時点では、事前に想像していたものとはかなり違うと感じています。

以前、ここのネットワーク環境と回線速度について愚痴りました：寮には全くネットがなく、授業を行う場所の回線速度もあまり良くありません。このような状況に置かれて、自分がかなりのネット依存であることに気づかされました。とはいえ、これは特に問題ではないと個人的には考えています。ネットワークは、人々の心を啓発する「カラ」となり得るものであり、やがて私たちの種全体を高度に発達した存在へと昇華させる可能性を秘めているのですから……

本題に戻りましょう。ここ二日間、Spring Frameworkを学んでいますが、とても新鮮な感覚があります。初心者の私は、Javaのコードがこれほどまでにエレガントになり得るのかと、思わず感嘆してしまいました。

<!--more-->

このような感想を述べることで、自分がいかに未熟であるかを露呈してしまいました。よく考えてみれば、どの言語でもエレガントに書くことは可能です。エレガントさとは、緻密な思考の末に丹念に設計された知恵の結晶であり、それを記述する媒体（言語）とはあまり関係がないように思います。

## RESTful

現段階では、Springフレームワークを主にWebアプリケーション構築のために使用しています。公式サイトのチュートリアルを一通り進めながら、RESTfulアーキテクチャの利点についても復習しました。まとめると、以下のような点があります。

+ **フロントエンドとバックエンドの分離**: このアーキテクチャはリソース指向であるため、レスポンスとしてHTMLページ全体ではなく、フォーマット化されたテキスト（多くの場合JSONでしょうか？）が返されます。これにより、フロントエンドとバックエンドを完全に分離することが可能になります。
+ **表現の明確さ**: RESTfulはHTTPプロトコルの特性を十分に活用しています。`&`で区切られた長いQueryStringではなく、URIを使用してリソースを要求します。これは、HTTP（ハイパーテキスト転送プロトコル）を単なる低レベルの転送プロトコルとして扱い上層で# 1. 两数之和

## 题目

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**示例 1：**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**示例 2：**

```
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

**示例 3：**

```
输入：nums = [3,3], target = 6
输出：[0,1]
```

**提示：**

- `2 <= nums.length <= 104`
- `-109 <= nums[i] <= 109`
- `-109 <= target <= 109`
- **只会存在一个有效答案**

**进阶：**你可以想出一个时间复杂度小于 `O(n2)` 的算法吗？

## 思路

使用哈希表，遍历数组，将数组元素作为 key，下标作为 value 存入哈希表，在遍历过程中，判断 target - 当前元素 是否在哈希表中，如果在，则返回当前下标和哈希表中对应元素的下标。

## 代码

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> map;
        for (int i = 0; i < nums.size(); i++) {
            int complement = target - nums[i];
            if (map.find(complement) != map.end()) {
                return {map[complement], i};
            }
            map[nums[i]] = i;
        }
        return {};
    }
};
```