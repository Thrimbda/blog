---
"title": "二探并发(Actor)"
"summary": "本稿では、並行プログラミングにおける共有メッセージキューの限界について深く考察します。各ワーカーが非同期に動作する必要があるシステムにおいて、共有キューはメッセージの特定宛先への送信不能、時系列の乱れ、効率低下などの問題を引き起こすことを指摘します。著者は、識別子の追加やリプレイ機構などの解決策の欠陥を段階的に分析し、最終的にActorモデルを根本的な解決策として提案します。記事では、Actorモデルの概念、並列実行、メッセージの分離、アドレスによる通信といった中核的特性を詳細に説明し、Pythonスレッドによる実装例を提供します。まとめとして、並行プログラミングには抽象的な思考が必要であり、Actorモデルはこの分野への効果的な入門案内であると強調しています。"
"tags":
  - "python"
  - "並行処理"
  - "Actorモデル"
  - "メッセージキュー"
  - "非同期プログラミング"
  - "スレッド間通信"
"date": "2017-05-19"
---

---
title: 二探并发(Actor)
date: 2017-05-19
taxonomies:
  tags:
    - python
    - 並行処理
---

[前回](http://0xc1.space/2017/05/06/初探并发/)では、メッセージキューを用いてスレッド（プロセス）間でメッセージを渡し、それによってスレッド間通信を実現する方法について述べました。

<!--more-->

## 共有メッセージキュー

これは、**並行処理が単にシステムのスループットを向上させるためだけのもの**という前提に立っています。この仮定の下では、各ワーカーが行う作業は同じであるため、一つのメッセージキューを共有し、誰が次の命令を取得しても問題ありません。

### もし私たちが同種のワーカーではないなら

例えば、各ワーカーがそれぞれの役割を果たし、非同期に動作するシステム（例：IP電話）を実装する必要がある場合はどうでしょうか？ 先ほどの方法、つまり全てのワーカーが一つのメッセージキューを共有する方法を引き続き使用すると、問題が発生します：メッセージを特定のワーカーに送信することができません。

この問題をどう解決すればよいでしょうか？ 単純で直接的な解決策は、各メッセージに識別子を付加し、そのメッセージの送信先を明示することです：

```python
queue = Queue([('Send_to_worker_A', 'do_something1'),
               ('Send_to_worker_B', 'do_something2'),
               ('Send_to_worker_B', 'do_something3'),
               ('Send_to_worker_C', 'do_something4'),
               ('Send_to_worker_A', 'do_something5')])
```

これで問題は解決したように見えますね？ しかし、私たちは新たな問題を導入してしまいました。

### もし誤って他人宛の手紙を開封してしまったら

もしworker A宛のメッセージがworker Bに届いてしまった場合、彼にとってそのメッセージは実質的に役に立ちません。一方、本来そのメッセージを受け取るべきworker Aはそれを受け取れず、結果としてその情報は失われてしまいます。これはworker Bの時間を浪費し、worker Aの時間を無駄にし、さらにはステップの飛び越しによってシステム全体が何らかの不可解なバグに陥る可能性さえあります。

この問題はどう解決すればよいでしょうか？ 直感的には、各ワーカーに以下のような戦略を追加すれば問題は解決するように思えます：他人宛のメッセージを受け取ったら、そのメッセージをメッセージキューに戻す。

```python
class Worker_B:
    
    def run(self):
        while True:
            if not self.queue.empty():
                data = self.queue.get()
                if data['to_whom'] == 'worker_B':
                    do_something_with_data
                else:
                    self.queue.put(data)
```

一見、修正を加えて問題を解決したように見えます...しかし実際には、また新たな問題を導入してしまっています。

### これは行き止まりのように見える

第一に、メッセージキューはキューであり、これはFIFO（先入れ先出し）を意味します。優先順位付きメッセージキューを導入したとしても、本質的にはこの点は変わりません。このため、本来最初にworker Aに渡されるべきメッセージが、worker Bによる「中継」を経て、現在のメッセージキューの中でworker Aに最も遅く届くものになってしまい、システムが不可解なバグに陥る可能性があります。

第二に、誤って配信されたメッセージを何とかしてメッセージキューの先頭に戻せたとしても、誤ったメッセージを受け取ったworker Bの「受信-検査-戻し」操作をアトミック操作にするためのロック機構を導入しなければ、worker Bが戻し操作を実行している間に、他のワーカーが既にメッセージ受信操作を続行している可能性があり、依然として時系列上の大きな問題を引き起こす可能性があります。ロック機構を導入すれば論理的な誤り問題は解決できますが、これにより各ポーリングサイクルで実際に作業できるワーカーは一つだけになり、誤ったメッセージを受け取って「受信-検査-戻し」操作を実行する他のワーカーは、自分のタイムスライスを無駄に浪費することになり、**効率が低下します。**

したがって、非同期作業のために並行処理を導入するシステムにとっては、各ワーカーが同じメッセージキューを共有することは良い方法ではないようです。

この問題を根本的に解決する方法は、同一タスクを実行するワーカーのグループごとに専用のメッセージキュー（メールボックス）を設けること、さらには各ワーカーに独自のメッセージキューを設定し、スレッド間でのメモリ共有能力を完全に放棄することです。後者の方法が、本日お話しする主役、**Actorモデル（アクターモデル）** です。

## Actorモデル

まず、WikipediaによるActorモデルの定義と概念を見てみましょう：

### 概念

コンピュータ科学において、アクターモデル（Actor model）は並行計算におけるモデルの一つです。「アクター」はプログラム上の抽象概念であり、並行計算の基本単位と見なされます：アクターがメッセージを受信すると、いくつかの決定を行い、さらに多くのアクターを作成し、より多くのメッセージを送信し、次のメッセージにどのように応答するかを決定することができます。アクターモデルは、1973年にCarl Hewitt、Peter Bishop、Richard Steigerの論文で提唱されました。

アクターモデルが推奨する哲学は「すべてがアクターである」というもので、これはオブジェクト指向プログラミングの「すべてがオブジェクトである」という考えに似ていますが、オブジェクト指向プログラミングは通常逐次実行されるのに対し、アクターモデルは並列実行されます。アクターは計算実体であり、受信したメッセージに応答すると同時に、並列に以下のことができます：

- 他のアクターに有限数のメッセージを送信する；
- 有限数の新しいアクターを作成する；
- 次のメッセージを受信したときの動作を指定する。

上記の操作には逐次実行の前提が含まれていないため、並列に行うことができます。送信者と送信済みメッセージの分離は、アクターモデルの根本的な利点です。これにより、非同期通信が可能になり、メッセージパッシングの制御構造が満たされます。メッセージ受信者はアドレスによって識別され、これは時に「メールアドレス」とも呼ばれます。したがって、アクターは自分がアドレスを持っているアクターとしか通信できません。アクターは受信した情報からアドレスを取得したり、自分が作成したアクターのアドレスを取得したりすることができます。アクターモデルの特徴は、アクター内部または間で並列計算が行われ、アクターは動的に作成でき、アドレスはメッセージに含まれ、相互作用は直接的な非同期メッセージ通信のみを通じて行われ、メッセージの到着順序に制限がないことです。

### 実装

Actorは十分にシンプルで、並行処理のために生まれ、変化を隔離するのに十分なカプセル化性を持っています（例：マルチスレッドかマルチプロセスかを気にしない）。

典型的なActorのPythonスレッド実装を見てみましょう：

```python
from queue import Queue
from threading import Thread, Event


class WorkerExit(Exception):
    # タスク終了用の例外
    pass


class BaseWorker(object):
    # Actor
    def __init__(self):
        self._mailbox = Queue()
        super(BaseWorker, self).__init__()

    def send(self, msg):
        self._mailbox.put(msg)

    def recv(self):
        msg = self._mailbox.get()
        if msg is WorkerExit:
            raise WorkerExit()
        return msg

    def close(self):
        self.send(WorkerExit)

    def start(self):
        self._terminated = Event()
        t = Thread(target=self._bootstrap)

        t.daemon = True
        t.start()

    def _bootstrap(self):
        try:
            self.run()
        except WorkerExit:
            pass
        finally:
            self._terminated.set()

    def join(self):
        self._terminated.wait()

    def run(self):
        raise NotImplementedError
```

簡単に説明すると、このActor（私はBaseWorkerと名付け、実際のプロジェクトでは親クラスとして使用します）は、`Queue`をメールボックスとして、`Event`をメインスレッドをブロックする終了手段として維持する、二つのデータ構造を持っています。

ここでの外部インターフェースとなる中核操作は`send()`メソッド一つだけです。注意してください、**私たちは渡すことができるメッセージの型を制限していません**。これは非常に高い柔軟性を意味します。

Actor内部では、一つのスレッドを使用して`run()`メソッドを実行し、`recv()`メソッドと組み合わせて指定された具体的な作業を行います。特筆すべきは、タスクを停止させるための番兵信号`WorkerExit`を設定している点です。`WorkerExit`の動作原理は、それが識別された後に例外として送出されるというものです。この例外処理の部分では、さらに多くのことを行うこともできますが、ここではこの例外を捕捉したときにスレッドの実行を停止するだけに留めています。この例外処理の実装は、`run()`メソッドをラップする`_bootstrap()`メソッドに依存しています。

Actorモデルの哲学の下で、この単純な例を拡張し、さらに先へ進むことができます。

## まとめ

並行プログラミングには、通常よりもさらに抽象的な思考様式が必要であり、「高凝集、低結合」という思想の良い実践例ともなり得ます。

私にとってこの全く新しい分野での探求において、Actorモデルは確かに道を照らす灯台であり、私を本当の意味で入門させてくれました。ですから、ここで共有させていただきます。 :)