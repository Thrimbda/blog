---
"title": "Reflexionen nach einem Jahr Vollzeitarbeit bei NTNL"
"summary": "Dieser Artikel ist eine Rückschau und Reflexion des Autors nach einem Jahr Vollzeitarbeit bei NTNL. Er beschreibt detailliert den Weg des Teams, von den frühen Versuchen mit Kryptowährungsmodellen über die Entwicklung des Copy-Traders Yamcha bis hin zu den erheblichen Verlusten beim Betrieb des NTNL-001-Fonds. Der Autor analysiert die Gründe für das Scheitern, darunter falsche Ausrichtung, Unreife im Fondsmanagement und das Verfehlen der Hauptwidersprüche. Anschließend passte das Team seine Ausrichtung an und konzentrierte sich auf die Entwicklung der Quant-Plattform Yuan, den Betrieb des Multi-Signal-Fonds NTNL-LTS und die Entwicklung eigener Modelle. Der Artikel fasst die wichtigsten Fortschritte des Jahres zusammen, wie die Reifung von Yuan, finanzieller Druck und Fortschritte bei den eigenen Modellen, und blickt in die Zukunft, wobei Prinzipien wie das Festhalten an der Realität, Lernen aus Erfahrung und das Erfassen der Hauptwidersprüche betont werden. Abschließend endet der Autor mit einem Gedicht und philosophischen Überlegungen, die das Verständnis für die Mühen des Unternehmertums und das Streben nach einem intensiven Leben ausdrücken."
"tags":
  - "Arbeitsprotokoll"
  - "Unternehmerische Reflexion"
  - "Quantitatives Trading"
  - "NTNL"
  - "Lektionen aus dem Scheitern"
  - "Yuan-Plattform"
  - "Eigene Modelle"
"date": "31. Juli 2023"
---

*Den Fluch brechen: "Mit dem ersten Schwung kommt man voran, mit dem zweiten lässt man nach, mit dem dritten ist man erschöpft."*

An der Schwelle zur Produktisierung von Yuan sind alle Teammitglieder voller Tatendrang und bereit für eine völlig neue Reise. Ich halte es jedoch für notwendig, auf die Arbeit der letzten zwei Jahre bei NTNL zurückzublicken, unseren Gedankengang, unseren ursprünglichen Antrieb, unsere Bemühungen und die Umwege, die wir gegangen sind, in Erinnerung zu rufen.

Max Weber, der Begründer der modernen Soziologie, übt in "Die protestantische Ethik und der Geist des Kapitalismus" eine zentrale Kritik am Kapitalismus: Die instrumentelle Rationalität (Methode, Mittel) besiegt letztendlich die Wertrationalität (Zweck, Wert). Der Mensch verwirklicht seinen ursprünglichen Traum, wird aber zu einem ziellosen, leblosen Wesen.

Ich schreibe diesen Artikel einerseits, um eine Bilanz zu ziehen, unsere vergangenen Misserfolge zusammenzufassen, um künftig nicht zweimal über denselben Stein zu stolpern; andererseits, um unseren ursprünglichen Antrieb lebendig zu halten. Und auch, um mir selbst Mut zu machen.

**No Trade No Life – Change the World by trading. Aschente!**

## Die Anfänge

Im April 2021 startete NTNL sein erstes Modell für Kryptowährungen. Als Investor steckte ich meine gesamten 1580 USDT auf der Chain hinein. Zehn Minuten nach dem Deployment waren aus 1580 USDT 1740 USDT geworden; drei Monate später, als der Lebenszyklus des Modells endete, erhielt ich schließlich 2400 USDT.

Das war für mich der eigentliche Schlüsselmoment in Bezug auf quantitatives Trading: Quantitatives Trading kann tatsächlich "passives Einkommen" generieren.

Leider endete der Lebenszyklus dieses Modells zu früh, sodass wir nicht viel Geld damit verdienten.

Erfreulicherweise endete der Lebenszyklus dieses Modells zu früh, denn genau das gab uns den Anstoß, die NTNL-Unternehmung zu starten.

## Vorgeschichte

Nach dem ersten bescheidenen Erfolg mit dem Modell begann das NTNL-Team, mehr Kommilitonen, Kollegen und Freunde aufzunehmen, die daran interessiert waren, durch quantitatives Trading Geld zu verdienen. Wir begannen, teilweise in Teilzeit an der Entwicklung zu arbeiten.

Doch in diesem fast einjährigen Zeitraum kamen wir nur langsam voran; der damals geschriebene Code ist heute völlig nutzlos. Nachdem JQ dem Team beigetreten war und viele Innovationen im Team und in den Abläufen eingeführt hatte, fanden wir allmählich einen Rhythmus, wurden dann aber vom Lockdown in Shanghai aufgrund der Pandemie getroffen, und alle Arbeiten kamen erneut zum Erliegen.

Bis zum 14. Mai 2022. CZ rief mich an und war der Meinung, dass das Copy-Trading basierend auf externen Signalquellen vielversprechend sei. Also packten wir es an. Noch am selben Abend begannen wir mit der Entwicklung des Copy-Traders Yamcha und gingen zwei Tage später live. Dies markierte den Beginn einer neuen Phase für das NTNL-Team.

---

Mit dem Live-Gang des Yamcha Copy-Traders beschleunigte sich vieles:

* CZ kündigte am 6. Juni bei ByteDance und begann seine Vollzeitarbeit bei NTNL.
* Ich kündigte am 16. Juli bei ByteDance und begann meine Vollzeitarbeit bei NTNL.

Die ersten Erfolge zeigten sich schnell. Das Copy-Trading mit den Signalquellen ließ unseren Net Asset Value (NAV) innerhalb einer Woche auf 2,16 steigen. Wir konnten nicht anders, als täglich die Kurse zu beobachten, unsere Stimmung schwankte stark mit dem NAV. Insgesamt jedoch, mit dem schnellen Anstieg des NAVs, waren die Erwartungen jedes Einzelnen an die Zukunft sehr positiv.

Doch bald erlitten wir unseren ersten großen Rückschlag: Verluste des NTNL-001-Fonds in Höhe von fast einer Million.

Was verursachte dieses Scheitern? Die relevanten Unterlagen sind auch ein Jahr später noch relativ gut auffindbar:
- In der ersten Woche des Fonds verpassten wir eine Chance, bei der der NAV fast 2 erreicht hätte. Das war der erste Moment, in dem ich CZ nach unserem Vollzeiteinstieg emotional erlebte.
- 2022-06-30: Margin-Knappheitskrise – An dem Tag war ich gerade von Minhang nach Yangpu umgezogen, das Haus voller Umzugskartons, als wir auf das Problem stießen, dass aufgrund zu großer Ordergrößen die Margin nicht ausreichte und Orders nicht platziert werden konnten.
- 2022-07-07: Der Fonds verzeichnete an einem Tag einen Drawdown von 50% – Ein unerträglich schmerzhafter Nachmittag. Ich musste hilflos zusehen, wie der NAV von 220.000 USD auf 90.000 USD fiel.
- 2022-07-14: Anpassung der Erwartungen – Eine weitere Woche später erlitten wir erneut massive Verluste. Zu diesem Zeitpunkt hatte der NAV von NTNL-001 vom Höchststand bereits 66% eingebüßt. Von da an wurde uns klar, dass diese Betriebsweise nicht nachhaltig war. Nicht lange danach wurde der NTNL-001-Fonds für gescheitert erklärt.

Jüngste Erfahrungen nehmen mehr geistigen Raum ein. Damals, unmittelbar nach dieser großen Niederlage, befanden wir uns noch in großen emotionalen Turbulenzen und konnten unsere Fehler nicht wirklich nüchtern betrachten. Ein effektives Lernen daraus war unmöglich.

Daher blicken wir heute, ein Jahr später, zurück: Welche Fehler haben wir gemacht, und was können wir aus diesen Fehlern lernen?

**Unwissenheit führte zu einem grundlegenden Fehler in der Ausrichtung.** Nach der Beobachtung der Performance einiger Signalquellen über wenige Monate glaubten wir, die Beobachtungen hätten statistische Signifikanz, und begannen mit dem Copy-Trading. Die konkrete Copy-Trading-Methode geriet sogar in den Dogmatismus eines [Cargo-Kults](https://de.wikipedia.org/wiki/Cargo-Kult). Unter der enormen Verlockung, bereits Gewinne zu erzielen, konnte niemand mehr rational bleiben und innehalten, um die damaligen Risiken genau zu prüfen. Selbst nachdem der Fonds-NAV in der zweiten Betriebswoche innerhalb kürzester Zeit um etwa 50% geschwankt hatte, nahmen wir keine Änderungen an der Betriebsweise vor, sondern wurden noch aggressiver. Letztendlich, als das ohnehin nicht stabile Fundament – die Annahme, dass die Performance einer von einem emotional instabilen Menschen betriebenen Blackbox-Signalquelle statistische Signifanz besitze – ins Wanken geriet und unsere Grundannahme für den Betrieb dieses Fonds bröckelte, verloren alle Investoren Geld.

**Unreife im Fondsmanagement.** Nach Start des Fonds luden wir, getrieben von dem ursprünglichen Wunsch, dass alle bei NTNL gemeinsam Geld verdienen sollten, viele NTNL-Mitglieder zur Teilnahme am NTNL-001-Fonds ein. Obwohl wir keinerlei Zusagen bezüglich Kapitalerhalt oder Gewinnen machten, schadete das letztendliche Scheitern faktisch unseren Investoren, was wiederum unserer eigenen geschäftlichen Reputation schadete. Noch wichtiger ist, dass es Druck auf unser künftiges Fondsmanagement ausübte und zu einer Tendenz zur Übervorsicht führte.

**Das Verfehlen der Hauptwidersprüche.** Unzureichende Einschätzung des Teams selbst. Wir hatten unsere eigenen Stärken und Schwächen nicht klar erkannt. Obwohl wir alle aus den Bereichen Softwareentwicklung/Informatik stammten und unsere Hauptberufe professionelle Programmierer und nicht professionelle Finanzakteure waren, glaubten wir blind, dass dieses manuell betriebene Signal uns zu schnellem Erfolg verhelfen könnte, und vertieften uns darin. Wir leisteten viel Arbeit, die sich heute als völlig nutzlos erweist. Kurz gesagt, wir verbrachten enorme menschliche Ressourcen und Mühe mit nebensächlichen Problemen und erfassten nicht den Hauptwiderspruch.

## Etablierung einer neuen Hauptrichtung

Nach dem katastrophalen Scheitern des NTNL-001-Fonds besannen wir uns und beschlossen, die Richtung zu ändern:

1.  Entwicklung von Yuan als eine All-in-One-Plattform für quantitative Entwicklung, Forschung, Debugging und Deployment.
2.  Nach dem Beitritt mehrerer Signalquellen fassten wir die bisherigen Erfahrungen zusammen und starteten den aus mehreren Signalquellen bestehenden NTNL-LTS-Fonds.
3.  Die Entwicklung eigener Modelle wurde auf die Tagesordnung gesetzt.

Warum wurden genau diese drei Wege festgelegt?

"Wer sein Handwerk meisterlich ausüben will, muss erst sein Werkzeug schärfen." Wir sahen den Engpass in der Produktivität im Fehlen guter Werkzeuge. Bei NTNL-001 hatten wir aufgrund unzureichender Werkzeuge zu viele Nachteile erlitten und zu viel Energie in Feuerwehr-Aktionen gesteckt. Daher hielten wir die Verbesserung der Werkzeuge für äußerst notwendig.

Gleichzeitig standen CZ und ich, da wir beide Vollzeit arbeiteten, vor dem Problem, kein stabiles Einkommen zu haben. Daher mussten wir Wege finden, Einnahmen zu generieren. Da wir zu diesem Zeitpunkt keine profitablen Modelle besaßen, wurden externe Signalquellen, die wir über Geschäftskontakte gewannen, zu unserer Hoffnung auf Profit.

Externe Signalquellen sind jedoch Blackboxen. Einerseits bedeutet das, dass wir ihre Performance nicht vertrauensvoll statistisch erfassen können (unzureichende Handelsdauer, Strategiewechsel etc.), andererseits können wir externe Signalquellen nicht breit auf weiteren Märkten und Instrumenten einsetzen, was den Spielraum für Gewinne einschränkt. Daher konnten wir die Möglichkeit eigener Modelle nie aufgeben. Externe Signalquellen waren lediglich ein Übergangsersatz, bis genügend eigene, breit gefächerte Modelle entwickelt waren.

Seit der Festlegung dieser Wege, von August 2022 bis heute (Juli 2023), haben wir fleißig entlang dieser drei Hauptachsen gearbeitet. Entsprechend gibt es mehr Aufzeichnungen: Zweiwöchentliche Berichte, Jahresberichte und Quartalsberichte sind dokumentiert.

Was genau in dieser Zeit geschah, ist nicht der Schwerpunkt dieses Artikels. Ich möchte aus heutiger Sicht auf diese Zeit zurückblicken: Welche neuen Herausforderungen gab es? Welche Erfahrungen können wir daraus ziehen? Und haben wir die Lektionen aus dem Scheitern von NTNL-001 vollständig verinnerlicht und gelernt? Ebenso möchte ich durch die Auflistung einiger aus meiner Sicht entscheidender Punkte dieser Periode eine Zusammenfassung geben.

**Auch auf diesen Wegen sind wir Umwege gegangen.** Konkret zeigte sich das in einem übermäßigen Einsatz von Energie für externe Signalquellen. Von August bis April investierten wir kaum bewusst Energie in die Entwicklung von Modellen, die Entwicklungsressourcen konzentrierten sich zu sehr auf die Analyse externer Signalquellen. Damals war das eigentlich eine vernünftige Wahl. Diese Wahl als "Umweg" zu bezeichnen, ist eine qualitative Bewertung aus der Rückschau. Der Grund liegt darin, dass wir damals nicht wussten, wie schlecht Stabilität und Qualität der externen Signalquellen tatsächlich waren. Rückblickend betrachtet waren die von uns erhaltenen externen Signale fast ausnahmslos Martingale-Oszillationsstrategien – sie sahen beeindruckend aus, aber ein einziger Fehlschlag machte alle vorherigen Erfolge zunichte. Diese und andere Probleme führten schließlich dazu, dass wir den Weg, den Betrieb externer Signalquellen als Haupteinnahmequelle zu nutzen, aufgaben.

**Der NTNL-LTS-Fonds erreichte ein Volumen von 3 Millionen RMB.** Obwohl wir auf dem Weg des Signalbetriebs Umwege gingen, muss die positive Bedeutung dieser Zeit für uns anerkannt werden: Der NAV von NTNL-LTS erreichte auf Basis des Betriebs zahlreicher externer Signalquellen zeitweise 1,04, wodurch wir mehr Kapital anziehen konnten als zur Zeit von NTNL-001. Auch wenn der NAV des Fonds heute (Juli 2023) aufgrund von Verzögerungen in der Modellentwicklung stagniert, ist das ein anderes Problem.

**Yuan reift heran.** Die Entwicklung von Yuan selbst ist das wichtigste Ergebnis des vergangenen Jahres. Sie spielte eine entscheidende Rolle in der Forschung zu externen Signalquellen, der Modellentwicklung und -forschung, dem Account-Copy-Trading und dem Deployment. Aus strategischer Sicht war dies unser Weg, Stärken zu nutzen und Schwächen zu vermeiden. Unsere bisherige Ausbildung und Berufslaufbahn konzentrierte sich auf die Bereiche Softwareentwicklung/Informatik/Internet. Wir sind gut darin, durch Internet-Denken und Technologie andere Branchen tief zu durchdringen und zu befähigen. Zwar unterbrachen häufige Signalzugänge und Passwortänderungen die tägliche Entwicklungsarbeit, doch der umfangreiche Bedarf an Signalquellenanalyse trieb umgekehrt auch die Verbesserung der Analysetools von Yuan selbst voran. So wurden wir in die Lage versetzt, Risiken wie das Halten von Verlustpositionen (Averaging) und andere Probleme jenseits der schönen NAV-Kurve schnell zu identifizieren, was uns wiederum bei der Erforschung eigener Modelle erheblich half.

**Die Teilzeit-Entwicklungskräfte für Yuan gingen allmählich gegen Null.** Das ist wahrscheinlich eine konkrete Ausprägung von "Mit dem ersten Schwung kommt man voran, mit dem zweiten lässt man nach, mit dem dritten ist man erschöpft." Da Teilzeit an sich keine nennenswerten Anreize bot, die Entwicklung für die Plattform keine ausreichend klaren Beitragsrichtlinien hatte und es sehr schwierig war, Menschen durch die Aussicht auf hohe Gewinnbeteiligung für die Modellentwicklung zu motivieren, sind wir heute, im Juli 2023, faktisch nur noch zu dritt. Bis es neue Anreize oder Leitlinien für Teilzeitkräfte gibt, wird es wahrscheinlich bei diesem Status quo bleiben. Dahinter stecken eigentlich Probleme des Managements und der Motivation. In Zukunft, wenn Yuan den Weg der Open-Source-Veröffentlichung und Kommerzialisierung geht, werden wir vor ähnlichen Problemen stehen.

**Unsere finanzielle Situation hat sich verschlechtert.** Da CZ noch über etwas Bargeldreserven verfügt, kann er vorerst ohne Gehaltszahlung leben, während ich ein monatliches Gehalt beziehe. Dieses Geld fällt natürlich nicht vom Himmel. CZ und JQ haben gemeinsam Anleihen erworben, die im Namen von NTNL ausgegeben wurden. Bis heute (Juli 2023) wurden bereits Anleihen im Wert von 300.000 RMB ausgegeben. Das ist derzeit die schwerste Last auf unseren Schultern. Unter dem Druck des Überlebens ist unsere Zeit sehr, sehr knapp.

**Wir verfügen über mehrere nutzbare Modelle.** Inzwischen haben selbst entwickelte Modelle die externen Signalquellen vollständig ersetzt und übertreffen diese in Breite und Vielfalt der Märkte und Instrumente bei weitem. Noch wichtiger ist, dass die Diversifizierung der Strategieansätze und -typen der Modelle selbst unser Risikomanagement einfacher und natürlicher macht. Die Modelle selbst könnten unsere Einkommensstruktur verändern und den enormen finanziellen Druck auf uns verringern.

---
Der menschliche Faktor ist der wichtigste. Alle oben genannten Erfahrungen, Lektionen und Errungenschaften wurden von uns als handelnde Individuen persönlich herbeigeführt und verwirklicht. Wenn wir auf die Zeit vor zwei Jahren zurückblicken, als wir gerade mit der NTNL-Arbeit begannen, war unser Verständnis für das, was wir tun wollten, noch sehr, sehr oberflächlich. Ich selbst wusste zum Beispiel überhaupt nicht, aus welcher Perspektive ich diese Sache betrachten sollte.

![](upload://inRWoJb02gFqO3cYa8ykFwepsGp.png)

Das ist eine Diskussion mit CZ vor zwei Jahren über die NTNL-Unternehmung. Als wir über die Zukunft fantasierten, als wir über die Machbarkeit dieser Sache auf Prinzipienebene sprachen, hatten wir keine Ahnung, welche *intensiven* Erfahrungen wir in der Praxis machen würden. Heute, zwei Jahre später, haben wir ein völlig anderes Verständnis von den damals besprochenen Dingen. Zusammengefasst: Durch praktische, eigene Erfahrung haben wir viele, viele Entscheidungen getroffen. Mit unseren Entscheidungen kamen entsprechende Rückmeldungen, gefolgt von Leid oder Freude – und die Dosis an Leid und Freude ist ungleich größer als vor der Unternehmensgründung.

"Was du aus Büchern erlangst, scheint stets oberflächlich; um es wirklich zu verstehen, musst du es selbst praktizieren." Die Praxis ist der einzige Maßstab für die Wahrheit. Unternehmer können hohe Ideale haben, müssen aber materialistisch sein – alle Ideale müssen in der Realität verwurzelt sein# 1. 概述

本文，我们来分享 MyBatis 的日志模块，对应 `logging` 包。如下图所示：

![`logging` 包](http://static2.iocoder.cn/images/MyBatis/2020_01_07/01.png)

在 [《精尽 MyBatis 源码解析 —— 项目结构一览》](http://svip.iocoder.cn/MyBatis/intro) 中，简单介绍了这个模块如下：

> 无论在开发测试环境中，还是在线上生产环境中，日志在整个系统中的地位都是非常重要的。良好的日志功能可以帮助开发人员和测试人员快速定位 Bug 代码，也可以帮助运维人员快速定位性能瓶颈等问题。目前的 Java 世界中存在很多优秀的日志框架，例如 Log4j、 Log4j2、Slf4j 等。
>
> MyBatis 作为一个设计优良的框架，除了提供详细的日志输出信息，还要能够集成多种日志框架，其日志模块的一个主要功能就是**集成第三方日志框架**。

本文涉及的类如下图所示：

![类图](http://static2.iocoder.cn/images/MyBatis/2020_01_07/02.png)

下面，我们逐小节来分享。

# 2. LogFactory

`org.apache.ibatis.logging.LogFactory` ，Log 工厂类。

## 2.1 构造方法

```java
// LogFactory.java

/**
 * Marker to be used by logging implementations that support markers
 */
public static final String MARKER = "MYBATIS";

/**
 * 使用的 Log 的构造方法
 */
private static Constructor<? extends Log> logConstructor;

static {
    // <1> 逐个尝试，判断使用哪个 Log 的实现类，即初始化 logConstructor 属性
    tryImplementation(LogFactory::useSlf4jLogging);
    tryImplementation(LogFactory::useCommonsLogging);
    tryImplementation(LogFactory::useLog4J2Logging);
    tryImplementation(LogFactory::useLog4JLogging);
    tryImplementation(LogFactory::useJdkLogging);
    tryImplementation(LogFactory::useNoLogging);
}
```

`logConstructor` 静态属性，使用的 Log 的构造方法。在 `<1>` 处的静态代码块中，会**逐个**尝试，判断使用哪个 Log 的实现类，即初始化 `logConstructor` 属性。

`#tryImplementation(Runnable runnable)` 方法，尝试调用方法，若成功，则不再尝试。代码如下：

```java
// LogFactory.java

private static void tryImplementation(Runnable runnable) {
    // 若 logConstructor 为空，说明还未成功初始化
    if (logConstructor == null) {
        try {
            // 执行方法，初始化 logConstructor
            runnable.run();
        } catch (Throwable t) {
            // ignore
        }
    }
}
```

`#useSlf4jLogging()` 方法，尝试使用 Slf4j 。代码如下：

```java
// LogFactory.java

public static synchronized void useSlf4jLogging() {
    setImplementation(org.apache.ibatis.logging.slf4j.Slf4jImpl.class);
}
```

`#useCommonsLogging()` 方法，尝试使用 CommonsLogging 。代码如下：

```java
// LogFactory.java

public static synchronized void useCommonsLogging() {
    setImplementation(org.apache.ibatis.logging.commons.JakartaCommonsLoggingImpl.class);
}
```

`#useLog4J2Logging()` 方法，尝试使用 Log4J2 。代码如下：

```java
// LogFactory.java

public static synchronized void useLog4J2Logging() {
    setImplementation(org.apache.ibatis.logging.log4j2.Log4j2Impl.class);
}
```

`#useLog4JLogging()` 方法，尝试使用 Log4J 。代码如下：

```java
// LogFactory.java

public static synchronized void useLog4JLogging() {
    setImplementation(org.apache.ibatis.logging.log4j.Log4jImpl.class);
}
```

`#useJdkLogging()` 方法，尝试使用 JdkLogging 。代码如下：

```java
// LogFactory.java

public static synchronized void useJdkLogging() {
    setImplementation(org.apache.ibatis.logging.jdk14.Jdk14LoggingImpl.class);
}
```

`#useStdOutLogging()` 方法，尝试使用 StdOutImpl 。代码如下：

```java
// LogFactory.java

public static synchronized void useStdOutLogging() {
    setImplementation(org.apache.ibatis.logging.stdout.StdOutImpl.class);
}
```

`#useNoLogging()` 方法，尝试使用 NoLoggingImpl 。代码如下：

```java
// LogFactory.java

public static synchronized void useNoLogging() {
    setImplementation(org.apache.ibatis.logging.nologging.NoLoggingImpl.class);
}
```

`#setImplementation(Class<? extends Log> implClass)` 方法，设置 `logConstructor` 属性。代码如下：

```java
// LogFactory.java

private static void setImplementation(Class<? extends Log> implClass) {
    try {
        // 获得参数为 String 的构造方法
        Constructor<? extends Log> candidate = implClass.getConstructor(String.class);
        // 创建 Log 对象
        Log log = candidate.newInstance(LogFactory.class.getName());
        if (log.isDebugEnabled()) {
            log.debug("Logging initialized using '" + implClass + "' adapter.");
        }
        // 创建成功，意味着可以使用，设置为 logConstructor
        logConstructor = candidate;
    } catch (Throwable t) {
        throw new LogException("Error setting Log implementation.  Cause: " + t, t);
    }
}
```

## 2.2 getLog

`#getLog(...)` 方法，获得 Log 对象。代码如下：

```java
// LogFactory.java

public static Log getLog(Class<?> aClass) {
    return getLog(aClass.getName());
}

public static Log getLog(String logger) {
    try {
        return logConstructor.newInstance(logger);
    } catch (Throwable t) {
        throw new LogException("Error creating logger for logger " + logger + ".  Cause: " + t, t);
    }
}
```

# 3. Log

`org.apache.ibatis.logging.Log` ，MyBatis Log 接口。代码如下：

```java
// Log.java

public interface Log {

    boolean isDebugEnabled();

    boolean isTraceEnabled();

    void error(String s, Throwable e);

    void error(String s);

    void debug(String s);

    void trace(String s);

    void warn(String s);

}
```

## 3.1 BaseJdbcLogger

`org.apache.ibatis.logging.BaseJdbcLogger` ，实现 Log 接口，负责打印 JDBC 调试日志。

考虑到篇幅，我们放在 [《精尽 MyBatis 源码分析 —— 日志模块》](http://svip.iocoder.cn/MyBatis/logging-package) 中，详细解析。

## 3.2 ConnectionLogger

`org.apache.ibatis.logging.jdbc.ConnectionLogger` ，继承 BaseJdbcLogger 抽象类，负责打印 Connection 的调试日志。

考虑到篇幅，我们放在 [《精尽 MyBatis 源码分析 —— 日志模块》](http://svip.iocoder.cn/MyBatis/logging-package) 中，详细解析。

## 3.3 StatementLogger

`org.apache.ibatis.logging.jdbc.StatementLogger` ，继承 BaseJdbcLogger 抽象类，负责打印 Statement 的调试日志。

考虑到篇幅，我们放在 [《精尽 MyBatis 源码分析 —— 日志模块》](http://svip.iocoder.cn/MyBatis/logging-package) 中，详细解析。

## 3.4 PreparedStatementLogger

`org.apache.ibatis.logging.jdbc.PreparedStatementLogger` ，继承 BaseJdbcLogger 抽象类，负责打印 PreparedStatement 的调试日志。

考虑到篇幅，我们放在 [《精尽 MyBatis 源码分析 —— 日志模块》](http://svip.iocoder.cn/MyBatis/logging-package) 中，详细解析。

## 3.5 ResultSetLogger

`org.apache.ibatis.logging.jdbc.ResultSetLogger` ，继承 BaseJdbcLogger 抽象类，负责打印 ResultSet 的调试日志。

考虑到篇幅，我们放在 [《精尽 MyBatis 源码分析 —— 日志模块》](http://svip.iocoder.cn/MyBatis/logging-package) 中，详细解析。

# 4. 集成第三方日志框架

## 4.1 Slf4jImpl

`org.apache.ibatis.logging.slf4j.Slf4jImpl` ，实现 Log 接口，**Slf4j** 的实现类。代码如下：

```java
// Slf4jImpl.java

public class Slf4jImpl implements Log {

    private Log log;

    public Slf4jImpl(String clazz) {
        // 使用 SLF LoggerFactory 获得 SLF Logger 对象
        Logger logger = LoggerFactory.getLogger(clazz);

        // 如果是 LocationAwareLogger ，则创建 Slf4jLocationAwareLoggerImpl 对象
        if (logger instanceof LocationAwareLogger) {
            try {
                // check for slf4j >= 1.6 method signature
                logger.getClass().getMethod("log", Marker.class, String.class, int.class, String.class, Object[].class, Throwable.class);
                log = new Slf4jLocationAwareLoggerImpl((LocationAwareLogger) logger);
                return;
            } catch (SecurityException e) {
                // fail-back to Slf4jLoggerImpl
            } catch (NoSuchMethodException e) {
                // fail-back to Slf4jLoggerImpl
            }
        }

        // Logger is not LocationAwareLogger or slf4j version < 1.6
        // 否则，创建 Slf4jLoggerImpl 对象
        log = new Slf4jLoggerImpl(logger);
    }

    @Override
    public boolean isDebugEnabled() {
        return log.isDebugEnabled();
    }

    @Override
    public boolean isTraceEnabled() {
        return log.isTraceEnabled();
    }

    @Override
    public void error(String s, Throwable e) {
        log.error(s, e);
    }

    @Override
    public void error(String s) {
        log.error(s);
    }

    @Override
    public void debug(String s) {
        log.debug(s);
    }

    @Override
    public void trace(String s) {
        log.trace(s);
    }

    @Override
    public void warn(String s) {
        log.warn(s);
    }

}
```

`log` 属性，被委托的 SLF Logger 对象。在构造方法中，我们可以看到，根据不同的情况，创建 `Slf4jLocationAwareLoggerImpl` 或 `Slf4jLoggerImpl` 对象。那么，这两个类的代码如下：

```java
// Slf4jImpl.java

// Slf4jLocationAwareLoggerImpl.java 类
class Slf4jLocationAwareLoggerImpl implements Log {

    private static final Marker MARKER = MarkerFactory.getMarker(LogFactory.MARKER);

    private static final String FQCN = Slf4jImpl.class.getName();

    private final LocationAwareLogger logger;

    Slf4jLocationAwareLoggerImpl(LocationAwareLogger logger) {
        this.logger = logger;
    }

    @Override
    public boolean isDebugEnabled() {
        return logger.isDebugEnabled();
    }

    @Override
    public boolean isTraceEnabled() {
        return logger.isTraceEnabled();
    }

    @Override
    public void error(String s, Throwable e) {
        logger.log(MARKER, FQCN, LocationAwareLogger.ERROR_INT, s, null, e);
    }

    @Override
    public void error(String s) {
        logger.log(MARKER, FQCN, LocationAwareLogger.ERROR_INT, s, null, null);
    }

    @Override
    public void debug(String s) {
        logger.log(MARKER, FQCN, LocationAwareLogger.DEBUG_INT, s, null, null);
    }

    @Override
    public void trace(String s) {
        logger.log(MARKER, FQCN, LocationAwareLogger.TRACE_INT, s, null, null);
    }

    @Override
    public void warn(String s) {
        logger.log(MARKER, FQCN, LocationAwareLogger.WARN_INT, s, null, null);
    }

}

// Slf4jLoggerImpl.java 类
class Slf4jLoggerImpl implements Log {

    private final Logger logger;

    Slf4jLoggerImpl(Logger logger) {
        this.logger = logger;
    }

    @Override
    public boolean isDebugEnabled() {
        return logger.isDebugEnabled();
    }

    @Override
    public boolean isTraceEnabled() {
        return logger.isTraceEnabled();
    }

    @Override
    public void error(String s, Throwable e) {
        logger.error(s, e);
    }

    @Override
    public void error(String s) {
        logger.error(s);
    }

    @Override
    public void debug(String s) {
        logger.debug(s);
    }

    @Override
    public void trace(String s) {
        logger.trace(s);
    }

    @Override
    public void warn(String s) {
        logger.warn(s);
    }

}
```

## 4.2 JakartaCommonsLoggingImpl

`org.apache.ibatis.logging.commons.JakartaCommonsLoggingImpl` ，实现 Log 接口，**Jakarta Commons Logging** 的实现类。代码如下：

```java
// JakartaCommonsLoggingImpl.java

public class JakartaCommonsLoggingImpl implements Log {

    private final Log log;

    public JakartaCommonsLoggingImpl(String clazz) {
        // 获得 Commons Logging Log 对象
        log = LogFactory.getLog(clazz);
    }

    @Override
    public boolean isDebugEnabled() {
        return log.isDebugEnabled();
    }

    @Override
    public boolean isTraceEnabled() {
        return log.isTraceEnabled();
    }

    @Override
    public void error(String s, Throwable e) {
        log.error(s, e);
    }

    @Override
    public void error(String s) {
        log.error(s);
    }

    @Override
    public void debug(String s) {
        log.debug(s);
    }

    @Override
    public void trace(String s) {
        log.trace(s);
    }

    @Override
    public void warn(String s) {
        log.warn(s);
    }

}
```

## 4.3 Log4jImpl

`org.apache.ibatis.logging.log4j.Log4jImpl` ，实现 Log 接口，**Log4J** 的实现类。代码如下：

```java
// Log4jImpl.java

public class Log4jImpl implements Log {

    private static final String FQCN = Log4jImpl.class.getName();

    private final Logger log;

    public Log4jImpl(String clazz) {
        // 获得 Log4J Logger 对象
        log = Logger.getLogger(clazz);
    }

    @Override
    public boolean isDebugEnabled() {
        return log.isDebugEnabled();
    }

    @Override
    public boolean isTraceEnabled() {
        return log.isTraceEnabled();
    }

    @Override
    public void error(String s, Throwable e) {
        log.log(FQCN, Level.ERROR, s, e);
    }

    @Override
    public void error(String s) {
        log.log(FQCN, Level.ERROR, s, null);
    }

    @Override
    public void debug(String s) {
        log.log(FQCN, Level.DEBUG, s, null);
    }

    @Override
    public void trace(String s) {
        log.log(FQCN, Level.TRACE, s, null);
    }

    @Override
    public void warn(String s) {
        log.log(FQCN, Level.WARN, s, null);
    }

}
```

## 4.4 Log4j2Impl

`org.apache.ibatis.logging.log4j2.Log4j2Impl` ，实现 Log 接口，**Log4J2** 的实现类。代码如下：

```java
// Log4j2Impl.java

public class Log4j2Impl implements Log {

    private final Log log;

    public Log4j2Impl(String clazz) {
        // 获得 Log4J2 Logger 对象
        Logger logger = LogManager.getLogger(clazz);

        // 如果是 AbstractLogger ，则创建 Log4j2AbstractLoggerImpl 对象
        if (logger instanceof AbstractLogger) {
            log = new Log4j2AbstractLoggerImpl((AbstractLogger