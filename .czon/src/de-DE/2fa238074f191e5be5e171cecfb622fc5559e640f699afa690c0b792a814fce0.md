---
"title": "Analyse der Stärken des Beobachter-Musters"
"summary": "Dieser Artikel führt zunächst die grundlegenden Konzepte des Beobachter-Musters (auch bekannt als Publish-Subscribe-Muster), die GoF-Definition und seine Anwendungen in der realen Welt (z.B. RSS-Abonnements) ein. Der Artikel erläutert detailliert die Teilnehmer des Beobachter-Musters (Subject, Observer, ConcreteSubject, ConcreteObserver) und geeignete Anwendungsszenarien (Abhängigkeiten zwischen Objekten, Änderungen eines Objekts erfordern gleichzeitige Änderungen anderer Objekte). Anschließend demonstriert der Artikel am Beispiel von Action und ActionListener in J2EE anhand eines konkreten Java-Swing-Codebeispiels, wie das Beobachter-Muster im MVC-Paradigma angewendet werden kann, um die Kopplung zwischen Model und View zu reduzieren. Der Artikel weist darauf hin, dass das Beobachter-Muster im Vergleich zu normalen Funktionsaufrufen und Callback-Funktionen die Konsistenz zwischen Objekten mit geringen Kosten aufrechterhalten, Broadcast-Effekte erzielen und die Wiederverwendbarkeit des Codes erheblich verbessern kann."
"tags":
  - "Entwurfsmuster"
  - "Systemanalyse und -design"
  - "Beobachter-Muster"
  - "J2EE"
  - "ActionListener"
  - "MVC"
  - "Java"
  - "Kopplung"
"date": "2017-04-10"
---

---
title: Analyse der Stärken des Beobachter-Musters
date: 2017-04-10
taxonomies:
  tags:
    - Entwurfsmuster
    - Systemanalyse und -design
---

> Im Allgemeinen gibt es in der objektorientierten Analyse und Design drei Mechanismen zur Ereignisbehandlung: Neben normalen Funktionsaufrufen werden häufig Callback-Funktionen verwendet, und in J2EE gibt es außerdem einen ereignisbasierten Listener-Mechanismus. Recherchieren Sie bitte und analysieren Sie den Mechanismus von Action und ActionListener anhand eines Analysebeispiels.

Zunächst das Beobachter-Muster verstehen

<!--more-->

## Beobachter-Muster (Observer Pattern)

### Beobachter in der realen Welt

Das Beobachter-Muster wird auch als Publish-Subscribe-Muster bezeichnet, zum Beispiel RSS-Abonnements (der Vorläufer von WeChat-Push). Wenn ein Blogger (das beobachtete Subjekt) einen Blogbeitrag aktualisiert, erhalten die Abonnenten automatisch die Aktualisierung in ihrem Reader (dem Beobachter). Dieses Veröffentlichungs-Abonnement-Schema nennen wir das Beobachter-Muster.

### Das Beobachter-Muster

Die Beschreibung des Beobachter-Musters durch die **G**ang **O**f **F**our:

> - Absicht
>
>   Definiert eine Eins-zu-viele-Abhängigkeit zwischen Objekten, sodass bei einer Zustandsänderung eines Objekts alle abhängigen Objekte benachrichtigt und automatisch aktualisiert werden.
>
> - Alias
>
>   Abhängige (Dependents), Veröffentlichen-Abonnieren (Publish-Subscribe)
>
> - Motivation
>
>   Eine häufige Nebenwirkung der Aufteilung eines Systems in eine Reihe zusammenarbeitender Klassen ist die Notwendigkeit, die Konsistenz zwischen den beteiligten Objekten aufrechtzuerhalten. Wir möchten nicht, dass die Klassen eng gekoppelt sind, um die Konsistenz zu wahren, da dies ihre Wiederverwendbarkeit verringert.
>
> ...
>
> - Teilnehmer
>
>   - Subject (Ziel)
>
>     Das Ziel kennt seine Beobachter. Es können beliebig viele Beobachter dasselbe Ziel beobachten.
>
>     Bietet Schnittstellen zum Registrieren und Löschen von Beobachterobjekten.
>
>   - Observer (Beobachter)
>
>     Definiert eine Aktualisierungsschnittstelle für Objekte, die bei einer Änderung des Ziels benachrichtigt werden müssen.
>
>   - ConcreteSubject (Konkretes Ziel)
>
>     Speichert den relevanten Zustand in den ConcreteObserver-Objekten.
>
>     Sendet bei einer Zustandsänderung Benachrichtigungen an seine Beobachter.
>
>   - ConcreteObserver (Konkreter Beobachter)
>
>     Verwaltet eine Referenz auf ein ConcreteSubject-Objekt.
>
>     Speichert den relevanten Zustand, der mit dem Zustand des Ziels konsistent sein sollte.
>
>     Implementiert die Aktualisierungsschnittstelle von Observer, um den eigenen Zustand mit dem des Ziels konsistent zu halten.

Man erkennt, dass das Beobachter-Muster häufig angewendet wird bei:

- Zwei Objekten mit Abhängigkeitsbeziehung.
- Einem Objekt, dessen Änderung gleichzeitige Änderungen anderer Objekte erfordert.

Im Vergleich zu normalen Funktionsaufrufen und Callback-Funktionen ermöglicht das Beobachter-Muster eine kostengünstige Aufrechterhaltung der Konsistenz zwischen Objekten, **verringert den Kopplungsgrad zwischen Objekten erheblich und kann gleichzeitig Broadcast-Effekte erzielen, was die ersten beiden nicht können. Die Verwendung des Beobachter-Musters verbessert die Wiederverwendbarkeit des Codes erheblich**.

**Und Action und ActionListener in J2EE sind ein lebendiges Beispiel für das Beobachter-Muster.**

## Action & ActionListener in J2EE

Action & ActionListener können gut im MVC-Paradigma angewendet werden, um die Kopplung zwischen Model und View zu reduzieren.

Ein gutes [Beispiel](http://www.ulisespulido.com/2009/03/observer-design-pattern-and-java-swing.html) wurde gefunden, der Code ist wie folgt:

```java
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JTextField;

public class Frame extends JFrame {

  ActionListener observer1 = new Observer("First Observer");
  ActionListener observer2 = new Observer("Second Observer");
  ActionListener observer3 = new Observer("Third Observer");

  public Frame(){
    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    init();
  }

  private void init(){
    addChangingTextField();
    pack();
    setVisible(true);
  }

  private void addChangingTextField(){
    //Observable class TextField. each time
    //An action or event occurs the observers will be updated
    //Almost all the Swing classes has this kind of behavior
    JTextField dataTextField = new JTextField();

    // Observer registering to the observable class.
    dataTextField.addActionListener(observer1);
    dataTextField.addActionListener(observer2);
    dataTextField.addActionListener(observer3);

    add(dataTextField);
  }

  public static void main(String [] args){
  	Frame frame = new Frame();
  }
}

class Observer implements ActionListener{

  private String name;
  private String message;

  public Observer (String s){
  	name = s;
  }

  public void actionPerformed(ActionEvent e) {
    JTextField textField = (JTextField) e.getSource();
    message = textField.getText();
    JOptionPane.showMessageDialog(null,
    name + " has been confirmed about the change, Thanks!! "
    + " The Message was: " + message);
  }
}
```

### Analyse

Die beiden Klassen übernehmen die Rollen von Action/ActionListener. `frame.dataTextField` bindet in der Methode `addChangingTextField` drei Listener (`observer1`, `observer2`, `observer3`). Nachdem der Text im Frame bearbeitet wurde (Zustandsänderung), wird die Methode `actionPerformed` in Observer ausgelöst, die den entsprechenden Text anzeigt.

In diesem Beispiel fungiert `frame.dataTextField` als `ConcreteSubject`, und `observer1`, `observer2`, `observer3` als `ConcreteObserver`. Die Schnittstellen, die sie implementieren und die Action/ActionListener-Methoden definieren, sind das entsprechende `Subject` und `Observer`.

Nach dem Binden der Beobachter kümmert sich das Ziel nicht um das konkrete Verhalten der Beobachter, sondern benachrichtigt sie nur bei einer eigenen Zustandsänderung. Die Beobachter entscheiden selbst, welche Aktion sie ausführen. Daher ist diese Methode sehr elegant und um Welten besser als das explizite Aufrufen von Funktionen oder das Ausführen von Callback-Funktionen, um Aktionen auszulösen. Es lohnt sich, dies zu lernen.