---
title: 並行処理への初めての一歩
date: 2017-05-07
taxonomies:
  tags:
    - python
    - 並行処理
---

よかった。最近の小さな課題で、私が本当に意味のある並行プログラミングに触れる機会がありました。

<!--more-->

## デモ

そこで、Pythonの`queue`、`signal`、`time`モジュールを使って、真のマルチスレッドではない、説明用の小さなデモを作りました：

```python
# -*- coding: utf-8 -*-
# @Author: Michale
# @Date:   2017-05-04 15:00:41
# @Last Modified by:   Michale
# @Last Modified time: 2017-05-07 00:46:52
import signal
import queue
import time


class TestClass(object):
    queue = queue.Queue()

    def __init__(self):
        signal.signal(signal.SIGINT, self.stopIfPressKill)

    def stopIfPressKill(self, mySignal, stack):
        if mySignal == signal.SIGINT:
            print('you pressed CTRL-C')
            self.queue.put_nowait('stop')
            print(self.queue.qsize())

    def mainThread(self):
        while True:
            time.sleep(1)
            if not self.queue.empty():
                data = self.queue.get()
                print(data)
                if data == 'stop':
                    break
                else:
                    self.queue.put(data)


if __name__ == '__main__':
    yoo = TestClass()
    yoo.mainThread()

```

3つのモジュールの役割を説明します：

- `queue`：メッセージキューとして使用します。ここでは明らかに大げさな使い方です。
- `signal`：`KeyboardInterrupt`を捕捉し、停止信号をメッセージキューに挿入するために使用します。
- `time`：メインスレッドがこの`KeyboardInterrupt`を捕捉できるようにするために使用します。

## 考え方

マルチスレッドの導入により、メインスレッド以外のスレッドは起動後、制御が難しくなります。そのため、メッセージキューなどの方法を用いてスレッド間通信を実現することが求められます。

しかし、マルチスレッドであるかどうかに関わらず、システムの各モジュールは本来、詳細をカプセル化し、イベントを用いてそれらが協調して動作するようにすべきです。これはシステムの結合度を下げるのに大きく役立ち、良いシステムの設計思想でもあります：**変化のために設計する。**