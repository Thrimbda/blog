---
"title": "Zola-Blog: WYSIWYG-Editor-Integration mit GitHub-Backend – Entwurf"
"summary": "Dieses Dokument beschreibt detailliert den Plan, um einen bestehenden Zola-Blog um eine WYSIWYG-Echtzeit-Markdown-Editierfunktion zu erweitern. Das Hauptziel ist es, den bestehenden Designstil beizubehalten und die Einführung eines selbstgeschriebenen Backends zu vermeiden. Durch Analyse des Ist-Zustands und der Designprinzipien empfiehlt das Dokument eine Architektur, die auf reinem Frontend basiert, GitHub OAuth Device Flow zur Authentifizierung nutzt, Entwürfe lokal speichert und Inhalte über die Erstellung eines PRs zurück in das GitHub-Repository veröffentlicht. Dieser Ansatz gewährleistet eine Echtzeitvorschau und automatisches Speichern während der Bearbeitung, klärt gleichzeitig den Inhalts-Synchronisationspfad und zerstört nicht die bestehende Struktur. Das Dokument diskutiert auch alternative Kandidaten, Sicherheitsrisiken und Implementierungsphasen."
"tags":
  - "Zola"
  - "WYSIWYG"
  - "Markdown"
  - "GitHub"
  - "Frontend"
  - "Echtzeitbearbeitung"
  - "Backendlos"
  - "Blog"
"date": "2026-01-06"
---

# Zola-Blog: WYSIWYG-Markdown-Echtzeitbearbeitung + Supabase/GitHub-Backend-Entwurf

## Ziel

Für den aktuellen Zola-Blog einen Entwurf und Plan für einen WYSIWYG-Editor mit Echtzeit-Markdown-Bearbeitung und eine Integration mit einem "ohne selbstgeschriebenes Backend" (Supabase oder GitHub Issue/Discussion) zu erstellen, ohne den bestehenden CSS-Designstil zu zerstören.

## Designprinzipien (müssen eingehalten werden)

- Beibehaltung der bestehenden suCSS + CSS-Variablen-Visualsprache (inkl. Light/Dark-Theme-Umschaltung)
- Möglichst keine Einführung eines selbstgeschriebenen Backends; Vorrang für Frontend-Direktverbindung zu Supabase oder GitHub API
- Falls React/shadcn benötigt wird, müssen die Gründe für die Einführung der Build-Chain, die Kosten und ein Rollback-Plan angegeben werden
- Die Bearbeitungserfahrung muss Echtzeitvorschau/-Rendering und automatisches Speichern (mindestens Entwürfe) unterstützen
- Klärung des Synchronisationspfads für die Veröffentlichung von Inhalten zu Zola (ohne Zerstörung der bestehenden Content-Struktur)

## Zusammenfassung des Ist-Zustands (aus dem Audit)

- Dieses Projekt ist eine Zola-Site (ohne Node/React-Build-Chain), gesamtes CSS/JS läuft über `static/`, und das Einbinden von CDN-Abhängigkeiten in `templates/head.html` ist erlaubt.
- Theme/Farben werden vollständig durch CSS-Variablen in `static/css/suCSS.css` gesteuert; JS schaltet über `data-theme` zwischen Light/Dark um (`static/js/script.js`).
- Inhaltsquelle ist `content/**` Markdown; enthält YAML-Frontmatter (`---`) und Zola-Shortcodes (wie `{{ slideshow(...) }}`).

## Unklare Punkte, die du überprüfen musst (bitte beantworten/auswählen)

1.  **Bearbeitungsbereich**: Muss nur eine/einige wenige Dateien bearbeitet werden (z.B. `content/gcores-talks.md`) oder soll "jede beliebige `content/**`-Seite bearbeitbar" sein?
2.  **Echtzeitbearbeitung**: Dein "Echtzeit" bedeutet:
    - A) Echtzeitvorschau/-Rendering innerhalb des Editors reicht aus (Einzelperson)
    - B) Automatisches Hintergrundspeichern von Entwürfen ist erforderlich (Einzelperson)
    - C) Mehrbenutzer-Kollaboration/Bildschirmübergreifende Bearbeitung ist erforderlich (Mehrere Benutzer)
3.  **Veröffentlichungspfad**: Wie sollen die Bearbeitungsergebnisse letztendlich die Site beeinflussen?
    - A) Nur als Entwurfsbibliothek speichern (nicht automatisch in `content/` übernehmen)
    - B) Ein-Klick-Veröffentlichung: Automatische Synchronisation in das `content/`-Verzeichnis des Repos und Auslösen des Zola-Builds
    - C) Halbautomatisch: Datei exportieren/Patch generieren, manuelles Einreichen durch dich
4.  **Authentifizierung**: Admin wird nur von dir selbst genutzt, akzeptierst du "Supabase Email Magic Link + Allowlist Einzelbenutzer"?
5.  **Bilder**: Muss im Editor direkt ein Bild hochgeladen werden können? Wenn ja, akzeptierst du, dass Bilder in Supabase Storage gespeichert und im Markdown als externer Link referenziert werden?

> [REVIEW]
> 1.  Ich möchte beliebige Dateien bearbeiten und dann über eine bestimmte Methode in das GitHub-Repo einreichen. Wenn ein Backend benötigt wird, muss dessen Notwendigkeit begründet werden.
> 2.  A und B
> 3.  B
> 4.  Diese Version ist nur für mich selbst gedacht, nur Admin ist nötig, Hauptsache es ist sicher. Ich würde sogar ein elliptisches Kurven-Schlüsselpaar akzeptieren und mich damit authentifizieren, wie bei SSH.
> 5.  Bild-Upload ist erforderlich, und Bilder sollen im Repo gespeichert werden.
>
> [RESPONSE] Verstanden, ich passe die Standardannahmen/Planausrichtung basierend auf deinen Antworten an:
>
> 1) Bearbeitungsbereich: Geändert zu "beliebige `content/**`-Dateien bearbeitbar" (und erweiterbar auf `templates/**` etc., aber MVP zunächst auf `content/**` beschränken, um das Risiko zu reduzieren). Veröffentlichungspfad hat "Zurückschreiben in GitHub-Repo" als Kernziel; Supabase nicht mehr als Wahrheitsquelle.
>
> 2) Echtzeitbearbeitung: Auswahl A + B – Echtzeit-Rendering/Vorschau im Editor + automatisches Speichern (Entwurf).
>
> 3) Veröffentlichungspfad: Auswahl B – Ein-Klick-Einreichen der Bearbeitungsergebnisse zu GitHub (empfohlen über PR, nicht direkter Push auf Master, zur einfacheren Überprüfung/Rücknahme; falls du auf direktem Push bestehst, kann es als Option implementiert werden).
>
> 4) Authentifizierung: MVP nur für dich selbst. Deine Erwähnung von "elliptisches Kurven-Schlüsselpaar wie SSH" könnte als lokale Anmeldeinformationen-Sicherung dienen (z.B.: Deinen privaten Schlüssel zum Entschlüsseln eines in IndexedDB gespeicherten GitHub-Tokens verwenden oder als Entsperrschritt). Aber für tatsächliche Schreibvorgänge zu GitHub wird immer noch ein autorisierter GitHub-Token benötigt; um "möglichst kein Backend" zu erfüllen, tendiere ich zu GitHub OAuth *Device Flow* (keine Abhängigkeit von `client_secret`), komplett im Frontend durchgeführt, und speichere den Token dann nur lokal, optional mit deinem privaten Schlüssel verschlüsselt.
>
> 5) Bilder: Entsprechend deiner Präferenz sollen Bilder auch im Repo gespeichert werden (z.B. in `static/images/uploads/...` schreiben, im Markdown auf `/images/uploads/...` verweisen); Die Upload-Implementierung nutzt "dasselbe GitHub-Token über die API, um Blobs/Commits zu erstellen", kein zusätzliches Backend nötig.
>
> Mein nächster Schritt ist es, den Plan von "Standardempfehlung A (Supabase als Wahrheitsquelle)" auf "GitHub als Wahrheitsquelle + Discussions/Issues für Entwürfe + PR-Veröffentlichung" zu ändern und im Design Details und Einschränkungen für Token-Speicherung/Verschlüsselung und Bild-Schreibvorgänge ins Repo zu ergänzen (Einzeldateigröße, Commit-Strategie für häufiges Autosave usw.).
> [STATUS:resolved]

> [REVIEW] Wenn möglich, finde ich Device Flow akzeptabel, dann brauchen wir kein Schlüsselpaar. Ich kann meinem eigenen Gerät vertrauen.
>
> [RESPONSE] OK, unter der Annahme, dass Device Flow akzeptiert wird, können wir das "elliptische Kurven-Schlüsselpaar" aus dem MVP entfernen:
> - GitHub OAuth Device Flow verwenden, um einen Access Token mit Schreibrechten für das Repo zu erhalten
> - Token nur lokal speichern (IndexedDB/localStorage), du vertraust deinem eigenen Gerät
> - Falls du später "Zweite Entsperrung/Schutz vor lokalen Mitlesern" möchtest, kann das Schlüsselpaar/OS Keychain als optionale v2-Erweiterung hinzugefügt werden
> [STATUS:resolved]

## Kandidaten (High-Level-Architektur)

### Option D (Aktuelle Implementierung / Hauptoption): Reines JS `/admin` + Vditor + GitHub Device Flow + PR-Veröffentlichung

- **Frontend**: `static/admin/*` statische Seiten, Wiederverwendung des bestehenden `reset.css`/`suCSS.css`/`style.css` und des Theme-Toggle aus `static/js/script.js` (konsistente Designsprache beibehalten).
- **Editor**: Vditor (Standard IR), Haupttextbearbeitung + Frontmatter separat bearbeiten (vermeidet Zerstörung durch WYSIWYG).
- **Authentifizierung**: GitHub OAuth **Device Flow** (kein `client_secret` nötig, kein selbstgebautes Token-Exchange-Backend erforderlich); Token nur lokal in IndexedDB gespeichert.
- **Entwürfe**: Nur lokales Autosave (IndexedDB), keine geräteübergreifende Synchronisation, erzeugt kein Git-Commit-Rauschen.
- **Veröffentlichung**: Bei Veröffentlichung Branch + PR erstellen, einmaliges Schreiben von:
    - `content/**.md` (Frontmatter + Body zusammengeführt)
    - `static/images/uploads/**` (beim Einfügen von Bildern als ausstehende Assets registrieren, bei Veröffentlichung zusammen einreichen)

Vorteile: Komplett ohne selbstgebautes Backend; "Wahrheitsquelle" ist das GitHub-Repo; entspricht deinen Präferenzen.
Risiken: Editor-Treue zu Shortcodes/Frontmatter muss validiert werden (besonders Seiten mit `{{ ... }}`); Berechtigungsumfang (Scope) der GitHub API muss kontrolliert werden.

### Option A (Optional): Reines JS `/admin` + Vditor + Supabase (nur Entwürfe/geräteübergreifend)

Nur einführen, wenn du in Zukunft "geräteübergreifende Entwurfs-Synchronisation/Kollaboration" benötigst; nicht als Wahrheitsquelle.

### Option B (Optional): Reines JS `/admin` + TOAST UI Editor

Falls du die Bearbeitungserfahrung von TOAST UI bevorzugst, kann der Editor ausgetauscht werden (erfordert zusätzliche Kosten für Theme-Überschreibung).

### Option C (Optional): React `/admin` (Vite) + shadcn UI + Milkdown/TipTap

Geeignet für: Du benötigst komplexere UI/Interaktionen (Ressourcenverwaltung, Erweiterungsblöcke usw.). Kosten: Einführung einer Node-Build-Chain; strenge Abbildung auf bestehende suCSS-Variablen erforderlich, um Design-Drift zu vermeiden.

> [REVIEW] Ich denke, D ist eine gute Option. Kein Backend nötig, der Zustand liegt auf GitHub. Ich denke, ich kann die Einführung eines OAuth-Providers akzeptieren. Mein aktuelles Kommentarsystem macht das doch auch so. Schau dir an, wie das geht. Wenn Supabase unbedingt eingeführt werden muss, sollte es nur Entwürfe speichern, nicht als Wahrheitsquelle.
>
> [RESPONSE] Stimme deiner Richtung zu: GitHub (Issues/Discussions + Repo) als Hauptspeicher für "Zustand liegt auf GitHub" zu verwenden, entspricht besser deinen Präferenzen; Wenn Supabase eingeführt wird, sollte es auf "optionaler Entwurf/Cache" herabgestuft werden, nicht als System-Wahrheitsquelle.
>
> Ich brauche von dir noch die Bestätigung von 2 Punkten, um Fehler zu vermeiden:
>
> 1) **OAuth-Form**: Du sagst "kann die Einführung eines OAuth-Providers akzeptieren (Kommentarsystem macht das auch)". Das Schreiben im Kommentarsystem giscus erfolgt über eine GitHub App/einen Server, der den Token-Austausch und die Signierung durchführt; Wenn wir auch den traditionellen Web-OAuth-Flow verwenden, betrifft das die Geheimhaltung von `client_secret`, was normalerweise ein vertrauenswürdiges Backend/eine Funktion zum Token-Austausch erfordert. Um "kein selbstgeschriebenes Backend" zu erfüllen, schlage ich eher GitHub OAuth *Device Flow* vor: Reines Frontend kann die Autorisierung abschließen (kein Backend zur Aufbewahrung von `client_secret` nötig). Akzeptierst du Device Flow als Ersatz für den "OAuth-Provider"?
>
> 2) **Wo Entwürfe speichern**:
> - D1) GitHub Discussions: Jede Seite entspricht einer Discussion, Entwurf ist der Discussion-Body; Bei Veröffentlichung PR generieren, um in `content/**` zu schreiben.
> - D2) GitHub Issues: Gleiches Prinzip, aber Issues sind eher auf Aufgabenfluss ausgerichtet.
> - D3) Repo `drafts`-Branch: Autosave aktualisiert Dateien direkt (erzeugt viele Commits, erfordert Merge/Komprimierungsstrategie).
> Welches bevorzugst du, D1/D2/D3?
>
> Nach deiner Bestätigung werde ich "GitHub als Wahrheitsquelle + Entwurfsstrategie + PR-Veröffentlichungsstrategie + Bild-Einreichungsstrategie + Sicherheitsmodell (lokale Token-Speicherung/optionale Verschlüsselung mit privatem Schlüssel)" zu umsetzbaren Schritten ergänzen.
> [STATUS:need-info]
>
> [RESPONSE] Zustimmung und basierend auf deiner letzten Bestätigung abgeschlossen:
> - Option D (GitHub als Hauptspeicher) als Hauptoption, aber kein "OAuth-Provider + Backend Token Exchange" mehr nötig, stattdessen **Device Flow** verwenden.
> - Supabase aus dem Hauptpfad entfernt (falls in Zukunft geräteübergreifende Entwürfe/Kollaboration benötigt wird, als optionales Modul hinzufügen).
>
> Bedeutung für die Umsetzung (zur Bestätigung):
> - `draft/autosave`: Nur lokalen Cache schreiben, kein Git-Commit erzeugen; Vermeidung von "bei jedem Tastenanschlag ein Commit/PR-Rauschen".
> - `publish`: Einmaliges Einreichen der angegebenen `content/**`-Datei + Bildänderungen zu GitHub (standardmäßig PR empfehlen; kann auch als direkter Push auf Master konfiguriert werden).
>
> Wenn du diese konsolidierte Richtung akzeptierst, werde ich im nächsten Schritt (wenn du sagst, dass Code geändert werden kann) entsprechend implementieren.
> [STATUS:resolved]

> [REVIEW] 1. Device Flow ist akzeptabel. 2. Ich denke, entweder Frontend-Cache. Ich scheine keinen Bedarf an geräteübergreifender Synchronisation zu haben, also machen wir es nicht so kompliziert.
>
> [RESPONSE] Bestätigung erhalten:
> 1) OAuth: GitHub Device Flow verwenden (keine Abhängigkeit von `client_secret`, kein selbstgebautes Token-Exchange-Backend nötig).
> 2) Entwürfe: Nur lokalen Frontend-Cache durchführen (IndexedDB primär, localStorage als Fallback/kleine Daten), keine geräteübergreifende Synchronisation.
>
> Dementsprechend werde ich das Gesamtdesign konsolidieren zu:
> - **Wahrheitsquelle (veröffentlicht)**: GitHub-Repo `content/**` (über PR/push zurückschreiben)
> - **Entwürfe (draft/autosave)**: Lokaler Cache (kein Supabase/GitHub Discussions/Issues nötig)
> - **Bilder**: Bei Veröffentlichung zusammen ins Repo schreiben (z.B. `static/images/uploads/...`), Markdown referenziert interne Pfade
> [STATUS:resolved]

## Empfohlene Umsetzung (basierend auf Standardannahmen)

Aktuelle Implementierung setzt direkt Option D um (ohne Backend):

1. `/admin/` statische Seite: Verbindung zu GitHub (Device Flow), Abrufen der `content/**.md`-Liste.
2. Datei laden: Parsen und Trennung von Frontmatter und Haupttext; Haupttext mit Vditor bearbeiten.
3. Entwürfe: Bei Eingabe Debounce-Speicherung in lokales IndexedDB (nicht nach GitHub schreiben).
4. Bilder: Über "Bild einfügen" als ausstehendes Asset registrieren und internen Pfad einfügen (`/images/uploads/...`); Bei Veröffentlichung zusammen in `static/images/uploads/...` des Repos einreichen.
5. Veröffentlichung: Branch + PR erstellen (ein Commit, enthält Markdown + Bilder), nach Merge wird der bestehende Zola-Deploy-Workflow ausgelöst.

## Sicherheits- und Risikoliste (muss validiert/getestet werden)

- Editor-Treue zu `{{ ... }}` (Zola-Shortcodes) und Frontmatter (besonders im WYSIWYG-Modus).
- XSS: Wenn rohes HTML in Markdown erlaubt ist, kann das bei Veröffentlichung auf der Site Injektionsrisiken bringen (muss vor der "Veröffentlichung" durch Regeln eingeschränkt/gefiltert werden).
- GitHub-Token-Scope: Möglichst minimieren (`public_repo` für öffentliches Repo verwenden).
- Admin-Seiten-Indexierung: `noindex` erforderlich (oder auf nicht erratbaren Pfad legen/zusätzliche Zugangskontrolle), um Suchmaschinen-Erfassung zu vermeiden.

## Umfang

- static/css/*
- templates/*
- static/js/*
- scripts/*
- .github/*
- .legion/**

## Phasenübersicht

1.  **Ist-Zustands-Audit und Einschränkungen** - 2 Aufgaben
2.  **Editor-Auswahl-Recherche** - 2 Aufgaben
3.  **Backend- und Datenmodell-Design** - 2 Aufgaben
4.  **Integrationsplan Detailliertes Design und Umsetzungsplan** - 2 Aufgaben

---

*Erstellt am: 2026-01-06 | Letzte Aktualisierung: 2026-01-06*