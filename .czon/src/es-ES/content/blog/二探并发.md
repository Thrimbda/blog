---
"title": "Una segunda mirada a la concurrencia (Actor)"
"summary": "El artículo comienza discutiendo cómo, en programación concurrente, cuando múltiples trabajadores necesitan operar de forma asincrónica y con roles distintos, compartir una única cola de mensajes puede causar problemas como la imposibilidad de enviar mensajes dirigidos, la recepción errónea de mensajes y problemas de secuenciación.\
  A través de un análisis paso a paso, el autor señala la ineficiencia y los posibles errores de compartir una cola de mensajes en este escenario. Luego, introduce el modelo Actor como solución fundamental, asignando a cada trabajador una cola de mensajes independiente (buzón), logrando un aislamiento completo de mensajes y comunicación asincrónica.\
  El artículo explica en detalle los conceptos del modelo Actor, incluyendo su ejecución paralela, paso de mensajes y mecanismo de direcciones, y proporciona un ejemplo de implementación en Python usando hilos, mostrando cómo construir un Actor básico (BaseWorker).\
  Finalmente, el autor resume las ventajas del modelo Actor en programación concurrente, destacando su valor en el pensamiento abstracto y la práctica de 'alta cohesión, bajo acoplamiento'."
"tags":
  - "python"
  - "concurrencia"
  - "modelo Actor"
  - "cola de mensajes"
  - "programación asincrónica"
  - "multihilo"
  - "modelo de programación"
"date": "2017-05-19"
---

---
title: Una segunda mirada a la concurrencia (Actor)
date: 2017-05-19
taxonomies:
  tags:
    - python
    - concurrencia
---

[En la entrega anterior](http://0xc1.space/2017/05/06/初探并发/) hablamos sobre el uso de colas de mensajes para pasar mensajes entre hilos (o procesos) y así lograr comunicación entre ellos.

<!--more-->

## La cola de mensajes compartida

Esto se basa en la premisa de que **la concurrencia solo sirve para mejorar la tasa de procesamiento del sistema**. Bajo esta suposición, cada trabajador realiza el mismo trabajo, por lo que pueden compartir una cola de mensajes; no importa quién reciba la siguiente instrucción.

### ¿Y si no somos iguales?

¿Qué pasa si necesitamos implementar un sistema donde cada trabajador tenga un rol específico y funcione de forma asincrónica (por ejemplo, nuestro teléfono IP)? Supongamos que seguimos usando el método anterior, donde todos los trabajadores comparten una cola de mensajes. En este caso, surge un problema: los mensajes no se pueden enviar a un trabajador específico.

¿Cómo solucionar esto? Una solución simple y directa es agregar una etiqueta a cada mensaje para identificar a quién va dirigido:

```python
queue = Queue([('Send_to_worker_A', 'do_something1'),
               ('Send_to_worker_B', 'do_something2'),
               ('Send_to_worker_B', 'do_something3'),
               ('Send_to_worker_C', 'do_something4'),
               ('Send_to_worker_A', 'do_something5')])
```

Parece que el problema se resuelve fácilmente, ¿verdad? Pero hemos introducido un nuevo problema.

### Si accidentalmente abro una carta destinada a otro

Si un mensaje destinado al trabajador A es recibido por el trabajador B, este mensaje no le sirve de nada, mientras que el trabajador A, que debería haberlo recibido, no lo obtiene, por lo que el mensaje se pierde. Esto no solo desperdicia el tiempo del trabajador B, sino que también consume el tiempo del trabajador A, e incluso podría llevar a todo el sistema a un error extraño debido a un paso saltado.

¿Cómo solucionar este problema? Intuitivamente, agregar la siguiente estrategia a cada trabajador parece resolverlo: si recibe un mensaje destinado a otro, lo vuelve a poner en la cola de mensajes.

```python
class Worker_B:
    
    def run(self):
        while True:
            if not self.queue.empty():
                data = self.queue.get()
                if data['to_whom'] == 'worker_B':
                    do_something_with_data
                else:
                    self.queue.put(data)
```

Parece que con parches hemos solucionado el problema... pero en realidad hemos introducido un nuevo problema.

### Esto parece un callejón sin salida

Primero, una cola de mensajes es una cola, lo que significa FIFO (primero en entrar, primero en salir). Incluso si introducimos una cola de mensajes con prioridades, esto no cambia en esencia. Así, un mensaje que debería entregarse primero al trabajador A, después de ser manipulado por el trabajador B, se convierte en el último en la cola para ser entregado al trabajador A, lo que podría llevar al sistema a un error extraño.

Segundo, incluso si logramos que los mensajes mal dirigidos se vuelvan a insertar al principio de la cola, si no introducimos un mecanismo de bloqueo para que la operación de `recibir-revisar-devolver` del trabajador B que recibió el mensaje por error sea una operación atómica, entonces, mientras el trabajador B realiza la operación de devolución, otros trabajadores podrían estar continuando con la operación de recibir mensajes, lo que aún podría causar grandes problemas de secuenciación. Introducir un mecanismo de bloqueo puede resolver el problema lógico, pero haría que en cada ciclo de consulta solo un trabajador pueda trabajar realmente, mientras que otros trabajadores que reciben mensajes erróneos y ejecutan la operación `recibir-revisar-devolver` desperdician su tiempo de CPU, **lo que es ineficiente**.

Por lo tanto, parece que, para un sistema que introduce concurrencia para trabajar de forma asincrónica, que cada trabajador comparta la misma cola de mensajes no es una buena idea.

La solución radical a este problema es crear una cola de mensajes dedicada (buzón) para cada grupo de trabajadores que realizan la misma tarea, o incluso asignar a cada trabajador su propia cola de mensajes, renunciando por completo a la capacidad de memoria compartida entre hilos. Este último método es el protagonista de hoy: **el modelo Actor (o patrón Actor)**.

## El modelo Actor

Primero, veamos la definición y los conceptos del modelo Actor según Wikipedia:

### Conceptos

En ciencias de la computación, el modelo Actor es un modelo de computación concurrente. Un "actor" es una abstracción conceptual en programación, considerado la unidad básica de computación concurrente: cuando un actor recibe un mensaje, puede tomar decisiones, crear más actores, enviar más mensajes y decidir cómo responder a los próximos mensajes. El modelo Actor fue propuesto en 1973 en un artículo de Carl Hewitt, Peter Bishop y Richard Steiger.

La filosofía que promueve el modelo Actor es "todo es un actor", similar al "todo es un objeto" de la programación orientada a objetos, pero la programación orientada a objetos suele ser secuencial, mientras que el modelo Actor es paralelo. Un actor es una entidad computacional que responde a los mensajes que recibe y, en paralelo:

- Envía un número limitado de mensajes a otros actores;
- Crea un número limitado de nuevos actores;
- Especifica el comportamiento al recibir el siguiente mensaje.

Las operaciones anteriores no asumen una ejecución secuencial, por lo que pueden realizarse en paralelo. La desvinculación entre el remitente y los mensajes ya enviados es la ventaja fundamental del modelo Actor. Esto permite la comunicación asincrónica y satisface las estructuras de control de paso de mensajes. Los destinatarios de los mensajes se distinguen por direcciones, a veces llamadas "direcciones de correo". Por lo tanto, un actor solo puede comunicarse con actores cuyas direcciones posee. Puede obtener direcciones a través de la información recibida o de las direcciones de los actores que crea. Las características del modelo Actor son: computación paralela dentro o entre actores, los actores pueden crearse dinámicamente, las direcciones de los actores se incluyen en los mensajes, la interacción solo se realiza a través de comunicación asincrónica directa por mensajes, y no se restringe el orden de llegada de los mensajes.

### Implementación

El Actor es lo suficientemente simple, está hecho para la concurrencia y tiene una encapsulación lo suficientemente buena para aislar los cambios (por ejemplo, no importa si es multihilo o multiproceso).

Veamos una implementación típica de un Actor en Python usando hilos:

```python

from queue import Queue
from threading import Thread, Event


class WorkerExit(Exception):
    # Excepción para finalizar la tarea
    pass


class BaseWorker(object):
	# Actor
    def __init__(self):
        self._mailbox = Queue()
        super(BaseWorker, self).__init__()

    def send(self, msg):
        self._mailbox.put(msg)

    def recv(self):
        msg = self._mailbox.get()
        if msg is WorkerExit:
            raise WorkerExit()
        return msg

    def close(self):
        self.send(WorkerExit)

    def start(self):
        self._terminated = Event()
        t = Thread(target=self._bootstrap)

        t.daemon = True
        t.start()

    def _bootstrap(self):
        try:
            self.run()
        except WorkerExit:
            pass
        finally:
            self._terminated.set()

    def join(self):
        self._terminated.wait()

    def run(self):
        raise NotImplementedError
```

En pocas palabras, este Actor (lo llamé BaseWorker, y en proyectos reales se usa como clase base) mantiene dos estructuras de datos: un `Queue` como buzón y un `Event` como mecanismo para bloquear el hilo principal.

Aquí, la operación central que sirve como interfaz externa es solo el método `send()`. Nótese que **no restringimos el tipo de mensaje que se puede pasar**, lo que ofrece una flexibilidad enorme.

Dentro del Actor, usamos un hilo para ejecutar el método `run()` combinado con el método `recv()` para realizar el trabajo específico asignado. Vale la pena mencionar que configuramos una señal centinela, `WorkerExit`, para detener la tarea. Nótese que `WorkerExit` funciona como una excepción que se lanza cuando se identifica, y en el manejo de excepciones aquí podríamos hacer muchas más cosas, aunque en este caso solo detenemos la ejecución del hilo cuando se captura esta excepción. Esta implementación del manejo de excepciones depende del método `_bootstrap()`, que envuelve a `run()`.

Bajo la filosofía del modelo Actor, podemos extender este ejemplo simple para ir más allá.

## Conclusión

La programación concurrente requiere una forma de pensar más abstracta de lo habitual y puede ser una buena práctica de la idea de "alta cohesión, bajo acoplamiento".

En mi exploración de este campo completamente nuevo para mí, el modelo Actor ha sido realmente una luz guía, que me ha llevado a entrar de lleno en él, por eso lo comparto aquí. :)