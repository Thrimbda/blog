---
"title": "Registro de trabajo 2020"
"summary": "Este documento es el registro de trabajo del autor para la primera mitad de 2020, detallando las actividades laborales desde abril hasta julio. Incluye principalmente el desarrollo del sistema de compilación de datos de mapas, corrección de errores, refactorizaciones técnicas (como la refactorización TLM), colaboración en equipo (por ejemplo, discusiones sobre interfaces y soluciones con colegas), entrevistas y reflexiones sobre el desarrollo profesional personal. El documento no solo cubre tareas técnicas específicas (como límites de velocidad personalizados, vinculación de líneas de carril, corrección de fugas de memoria), sino que también contiene reflexiones del autor sobre eficiencia laboral, calidad del código, gestión de proyectos (como tuberías CI/CD) y planificación profesional. En el registro, el autor expresa en múltiples ocasiones la búsqueda del significado del trabajo, el pensamiento crítico sobre decisiones técnicas y los cambios en su mentalidad bajo un entorno de entrega de alta presión."
"tags":
  - "Registro de trabajo"
  - "Desarrollo de software"
  - "Datos de mapas"
  - "Reflexión técnica"
  - "Colaboración en equipo"
  - "Gestión de proyectos"
  - "Desarrollo profesional"
"date": "2020-01-01"
---

### 2020-04-13

- Completé la autoevaluación de desempeño.
- Revisión de la Agregación del Centro del Carril (Lane Center Aggregation).

### 2020-04-14

- [ ] Compilación de límites de velocidad.
- [ ] Límites de velocidad personalizados.

### 2020-04-15

- Determiné la solución para límites de velocidad personalizados con @guangcong.
  1. Usar un nuevo `module-dynamicEvent` para resolver este problema.
  2. La actualización de límites de velocidad personalizados actúa como un nuevo evento que desencadena la actualización de los datos del horizonte.
  3. Es necesario considerar la detección de excepciones y problemas de memoria.
     Después de discutir con Guangcong, él encontró algunos problemas.
- Revisión de Xiaokang.
  Java, como un lenguaje sólido, tiene mucho que ofrecer.
- Compilación de límites de velocidad.
  Progreso mínimo, añadí la lógica para extraer `RoadCenterTile`.
- Resolución del problema de Seccionamiento (Sectioning), análisis del plan de optimización `edgeLifting`, propuesta de un algoritmo de optimización:
  Dada una cabeza de recorrido (`traverse head`) y una función de conectividad, se proporciona el método de recorrido.
- Investigación del principio de los JAR auto-ejecutables.

### 2020-04-16

- Aclaré la interfaz de `custom speed limit` con Yiming: él garantiza que el par de ubicaciones de entrada pueda determinar una única ruta más corta.
  Luego, con Guangcong, analicé el algoritmo para generar límites de velocidad personalizados.
  1. Dada una ruta.
  2. Sabiendo que | `start DiRoadOnPath::count` - `end DiRoadOnPath::count` | ≤ 1,
     entonces siempre se puede encontrar un par (`start DiRoadOnPath`, `end DiRoadOnPath`) que minimice la distancia.
- Proporcioné a Xiaokang una versión instantánea utilizable del compilador pylon-v0.1.1.
- Di un paseo informal con Hanteng, echando la charla.
- Aclaré con Zizhe y Yicheng la interfaz de uso del mapa SUMO.
- La compilación de `SpeedLimit` fue exitosa pero aún no se ha verificado.

### 2020-04-17

- Verificación de la compilación de `SpeedLimit`:
  `OSMSerializable` no es muy adecuado porque el `SpeedLimit` después de la vinculación no tiene geometría.
  Posible problema: la vinculación de límites de velocidad puede fallar en las rampas de entrada/salida.
- [ ] Interpolación.
- [ ] Distancia de Hausdorff.
- [ ] `LcInJunctionTile`.

#### Algunas ideas peculiares

- ¿Implementar Spark directamente?
- ¿Qué necesita el Contexto de OSM?

### 2020-04-18

Completé los límites de velocidad.

### 2020-04-20

#### Límites de velocidad personalizados

- Guangcong cambió la entrada a un vector y añadió pruebas.
- Un pequeño problema es que Guangcong no entiende realmente el principio de funcionamiento de los punteros en C++.
- [ ] ¿Quizás intentar resolver [https://github.com/scalameta/scalafmt/issues/337](https://github.com/scalameta/scalafmt/issues/337)?
- [ ] Convertir los archivos compartidos por el "tío" en compartidos anónimos a través de Resilio Sync.

#### Reparación de `RoadBorder`

Descubrí que había hecho una suposición incorrecta. La información de `lc` y `rb` registrada en `rc` podría presentar:

1. Solo hay un `lc`, por lo que no se puede asumir que `lc` tenga al menos dos.
2. El `rb` en un lado podría no existir, por lo que no se puede asumir que `rb` siempre exista.

### 2020-04-21

#### Reparación de `RoadBorder`

- Completé la migración de los casos de prueba.
- Mejoré Dune y su `ReadMe` para que pueda generar datos de prueba directamente.
  Hablé con Weiyu sobre el futuro, me centraré en el sistema de compilación.

#### Vinculación de POI en carriles opuestos

- Realicé la vinculación (`binding`) para los datos después de `multidigitize`.

### 2020-04-22

#### Vinculación de POI en carriles opuestos

- Realicé la vinculación (`binding`) para los datos después de `multidigitize`.
- Construí datos de prueba.

### 2020-04-23

- Completé y depuré la vinculación de POI en carriles opuestos [4].

### 2020-04-27

Hoy principalmente hice lo siguiente:

#### Completé la sincronización de `mdm proto` y `mdm spec`

1. Junto con Linnan, corregimos partes con expresiones erróneas en la especificación `mdm` de Ruogan.
2. Dejamos varios elementos pendientes que Linnan y yo no podíamos decidir solos.
3. En la reunión matutina del 2020-04-26, decidimos posponer las modificaciones más problemáticas de `LaneSplitMerge` y `Polyline`.
4. Completé la modificación del `proto`.
5. Completé la modificación de `nexus`.
6. Completé la modificación de `mdk`.
7. De paso, también solucioné un problema con los datos de prueba (reportaba errores de datos frenéticamente).

#### Corrección de errores

Cerca del lanzamiento del 30/04, el número de errores aumentó drásticamente.

[HDMAPMDK-1111](https://jira.momenta.works/browse/HDMAPMDK-1111) analizado.

- [ ] Script para copiar automáticamente casos de prueba.
- [ ] Exportar recordatorios de Apple.

### 2020-04-28

El examen teórico de conducir (科一) me tomó medio día.

HDMAPMDK-1130 Problema de ancho, tres problemas:

1. La especificación establece que no hay ancho de carril durante el cambio de carril.
2. Líneas de intersección demasiado largas que causan división de líneas (`split line`).

HDMAPMDK-1121 reparado nuevamente.

Estado muy pobre.

### 2020-04-29

#### Corrección de errores

- HDMAPMDK-1143
  Problema de que `RoadObstacle` no se compilaba.
- HDMAPMDK-1090

### 2020-05-06

#### Du Valid

- Uso de `mill`.
- Uso de `nexus-osm`.

#### Lluvia de ideas (`Brain Storm`)

### 2020-05-08

#### Problema de fuga de memoria

- La causa directa de la fuga de memoria fue crear punteros salvajes (`new`) y no eliminarlos (`delete`).
- Después de `update current position`, `map kit` llamó a `prepareGuidanceData`, con el objetivo de encontrar los datos de guía más cercanos a la posición actual.
- `prepareGuidanceData` llamó a `NavInfoProviderImpl::getTrafficLights` y `NavInfoProviderImpl::getCarParks`.
- Tomando `NavInfoProviderImpl::getTrafficLights` como ejemplo, al llamarlo se creaban (`new`) punteros de datos en `NaviEventOnPath`.
- Sin embargo, no se realizaba `delete`.
- También se descubrió que `DestEvent` tenía este problema.

Solución: La clave está en no permitir punteros salvajes. Decidí refactorizar `NaviEventProvider`.

- Primero, añadir dos campos `traffic_light_events` y `car_park_events` en `NaviInfoProvider`.
- En `NaviInfoGenerator`, actualizar estos dos campos después de que la ruta se actualice.
- Luego, en cada llamada `get`, filtrar según la posición actual del vehículo.
- Por lo tanto, es necesario refactorizar `PathReader::getAttributes`, porque la implementación anterior solo consideraba el `offset` relativo al vehículo actual, ahora se necesita una interfaz de `Offset` relativo a la `Path`.

### 2020-05-09

#### Reparación y pruebas de `PolyLine`

El problema principal de `PolyLine` es que podrían introducirse puntos duplicados durante su generación, lo que causaría una serie de problemas en los cálculos geométricos relacionados con segmentos:

1. Cálculo de vectores, dos puntos duplicados producen un vector cero.
2. Cálculo de longitud, la longitud del segmento es 0, fácilmente conduce a problemas de `NaN`.

Por lo tanto, al construir `PolyLine`, se verifican los puntos dentro de ella. Si se encuentran puntos duplicados, se lanza una excepción.

Se detectaron los siguientes problemas:

- Problema con `getEnd` en Jts.
- Problema de `normalize` en `Jts LinearLocation`.

  ```scala
  val loc1 = new LinearLocation(0, 1, 1.0)
  val loc2 = new LinearLocation(0, 2, 0.0)

  loc1 compareTo loc2
  // la salida es -1
  ```

- Al interpolar, podrían tomarse dos puntos demasiado cercanos.

### 2020-05-11

- HDMAPMDK-1122
  El problema de la falta de líneas de borde de la carretera no se pudo reproducir, decidí no investigar más la causa.
- Media hora sobre la teoría del crecimiento metabólico.
- Refactorización de `Visitor` para que admita líneas con el mismo punto de inicio y fin.
- Preparé una pregunta de entrevista.

### 2020-05-12

- Entrevista: dos candidatos no calificaron. Reflexioné sobre cómo identificar rápidamente a los candidatos, tomó 3 horas.
- Corrección de error: HDMAPMDK-1211 Problema de eliminación incorrecta de `border`. No se solucionó correctamente en la reparación anterior.
  Tengo una idea pero no la he terminado de escribir.
- Fui al gimnasio.

### 2020-05-13

Corrección de error: HDMAPMDK-1211 Encontré una solución.

- La causa raíz fue una segmentación de línea de producción irrazonable.

#### Análisis de la causa

Se puede observar que la segmentación se realizó antes de que finalizara el cambio de carril (la línea central del carril aún cruzaba la línea del carril), y esta segmentación podría cruzar `Rp`.

Dado que la información de observación de `lane border` adjunta a los puntos de forma de `lanecenter` registra fielmente las líneas de carril a ambos lados según la geometría, utilizando un método de `scan line`, sin filtrar según la semántica. Por lo tanto, en la posición donde la línea del carril cruza el carril, la línea central del carril que intersecta con la línea del carril registrará esa línea del carril simultáneamente en las referencias de `border` izquierda y derecha.

Bajo la lógica de código existente, al filtrar las referencias de `border` de las líneas de carril intersectadas según la semántica, se inferirá la referencia de `border` a eliminar según el tipo de cambio de carril.

La lógica actual falla al encontrar este tipo de segmentación, lo que lleva a este problema.

#### Solución

El punto clave es **encontrar la tendencia de cambio de carril de la línea de carril intersectada**. Dado que este tipo de segmentación puede cruzar `Rp`, el filtrado no debe realizarse por unidad de `Rp`.

1. Primero, organizar las líneas de carril en `path` (puede considerarse para una futura refactorización de `graph`) utilizando `edge lifting`: `Seq[LaneCenter]`.
2. Encontrar el `LaneCenter` a corregir y el `lane border` a corregir (asumiendo que este tipo de `LaneCenter` es causado por un cambio de carril).
3. Calcular la tendencia de cambio de carril de este `LaneCenter` según el `path` de `LaneCenter`.
4. Realizar el filtrado.

Se lo asigné a Ziliang.

Entrevisté a una persona, no pasó.

### 2020-05-14

HDMAPMDK-1132 Rastreo de ID (`Id tracing`) para los puntos finales de las líneas de carril de señales de poste.

El problema de rastreo para los puntos finales de las líneas de carril de señales de poste es muy simple en comparación con el rastreo de objetos lineales, solo existe un mapeo de ID, sin mapeo de `offset` y `length`.

Sin embargo, hay varios problemas a considerar:

1. Procedimiento.
2. El sistema de tipado de ID (`Id Typing System`) es un problema persistente, necesitamos encontrar una manera de manejarlo.

Esencialmente, la raíz de este problema es que al definir los ID, usamos todos ID `Long`, mientras que en la definición de MDM se usan `Int`, lo que podría causar problemas de desbordamiento.

### 2020-05-15

#### Corrección de errores

- HDMAPMDK-1215 completado.
- HDMAPMDK-1218 Hecho.

### 2020-05-18

Refactoricé el `OSM Assembler`, utilizando la serialización OSM anterior. La facilidad de comprensión del código y la facilidad de escritura mejoraron.

### 2020-05-19

Solucioné un error en `OSM Assembler` (en realidad no era exactamente un error).

Hoy tuve la reunión de planificación del sprint (`sprint planning`):
Las tareas para este sprint no son muchas, pero hay mucho en qué pensar. Este es un estado saludable.

### 2020-05-20

- [ ] Escribir documentación describiendo el estado actual de CI de `nexus/mdk` y los requisitos.
- [x] Prestar atención al error HDMAPMDK-1263.
  - Realmente es un problema de segmentación de línea de producción.
- [ ] Concertar una reunión con Yangchuan para discutir CI.
- [ ] HDMAPMDK-1262.
      No terminado.
- [x] Problema de `Custom Speed Limit`.

### 2020-05-21

#### Tareas pendientes (`TODOs`)

- [x] Saludar a Qiaobo.
- [x] HDMAPMDK-1262.
- [x] HDMAPMDK-755.

#### Trabajos realizados (`Works`)

- Por la mañana fui al área de trabajo de Yiming para depurar en línea el `hotfix` de ayer. El resultado fue un problema de `offset`. Ayer lo escribí demasiado apresuradamente y no añadí pruebas en absoluto. Este tipo de comportamiento no debería repetirse. Pensé que ahorraba mucho tiempo, **pero al final perdí más tiempo**.
- La razón por la que no se podían obtener los datos en 1262 era que MDK no cargaba `road mark` a nivel de carril (y `road obstacle`).
- Ayudé al hermano Du a compilar datos.

### 2020-05-22

¿Qué hice este día???
¿Qué hice hoy???

### 2020-05-25

Hoy recibí una nueva tarea: HDMAPMDK-1249 - Investigar métodos para calcular la agregación de carriles (`lane aggregation`) utilizando información geométrica de la carretera. Esto aumentó un poco las tareas de esta semana. Hasta ahora, tengo tres cosas por hacer:

1. 1249.
2. Estado actual, requisitos y soluciones para la tubería CI (`CI Pipeline`) del equipo.
3. Refactorización del grafo de `Nexus`.

Cada una de estas cosas requiere una cuidadosa planificación y no son fáciles. Lamentablemente, no puedo estimar claramente el tiempo para cada una. Solo Weiyu estimó y escribió los `story points` en las tareas de Jira. Una cosa tengo clara: **si no empiezo a estimar y revisar, nunca estimaré con precisión**. Así que a partir de ahora, debo estimar cuidadosamente.

Además, planeo comenzar con 1249 hoy, porque es un asunto de negocio, generalmente más urgente, y Weiyu también le dará más importancia. En cuanto a la refactorización, si no me preocupo por ello, probablemente a nadie más le importará (porque, cruelmente, no afecta la funcionalidad, pero sí la eficiencia, y la eficiencia es lo más difícil de medir, incluso yo solo tengo análisis cualitativos).

### 2020-05-26

Hoy hubo muchos imprevistos. Primero, `parking` reportó dos errores. Originalmente planeaba entregar hoy, pero debido a estos errores, no pude hacerlo. Wang Wei negoció con los equipos posteriores y pospuso la entrega dos días hasta pasado mañana. Así que mi trabajo principal estos dos días se convirtió en resolver errores. Esto me hizo reflexionar sobre si la planificación durante las entregas es razonable. Luego, el problema HDMAPMDK-1290.

Lo que completé hoy:

- Seguimiento de HDMAPMDK-1290: Cuando se está extremadamente cerca de la `stop line`, el `lane offset` coincidente puede ser mayor que la longitud del carril (`lane length`).

  > Pasé todo el día investigando y tratando de resolver este problema (actualmente son las 8:56 p.m.), la eficiencia fue muy baja.

  La razón esencial es que MDK calcula la longitud tomando la longitud entre cada dos puntos y luego aplicando una `coordinate transform`. Aunque esto es más preciso, introduce una fuerte incertidumbre en los resultados.

  Finalmente, usé una solución algo improvisada (`hack`): si el `offset` calculado es mayor que la longitud, solo se toma la longitud.

- HDMAPMDK-1297 Vinculación incorrecta de plazas de estacionamiento.
  Aunque ya era casi la hora de salida original (9 p.m.), ¡hoy tenía que al menos analizar este problema!
  Vaya, lo resolví. Resultó ser un problema simple.

### 2020-05-27

Hoy, si no hay imprevistos, debo terminar el asunto de la tubería CI (`CI Pipeline`).

Pero hubo imprevistos - -

Recibí errores reportados por Yiming:

1.  Vinculación de semáforos: Un semáforo que debería estar vinculado a un área de espera (`待转区`) se vinculó a la `partition` anterior al área. Ya reparado (1.5h).
2.  Omisión de vinculación de semáforos: No se pudo reproducir.
    Actualización: Después de una ronda difícil de depuración, finalmente encontré el problema. Durante la compilación, la geometría utilizada para la vinculación de `rc` con `offset` no era la misma línea, lo que causaba que el `offset` excediera la longitud de la carretera, por lo que no se encontraba el semáforo (2h).

### 2020-05-28

Mañana es el examen práctico de conducir (科二), hoy practiqué conducción todo el día, regresé a las 5 p.m. Me sentí bastante bien, espero aprobar mañana.

Comencé la descripción del estado actual y el análisis de requisitos de la tubería CI (`CI Pipeline`) - -

### 2020-05-29

No aprobé. Ay, es muy difícil para mí.

Por la mañana fui al examen. Por la tarde hice algunas cosas:

1.  Fui donde Yiming para ver una situación anómala, resultaron ser dos errores.
2.  Después del `townhall` de la tarde, sincronicé sobre el asunto de `MDK python binding`.
3.  Junto con Shanle y Weiyu, bajamos a resolver un problema de los equipos posteriores. Finalmente resumimos una solución a corto plazo y una a largo plazo.

Descubrí que al enfrentar problemas imprevistos, el método para resolverlos generalmente debería seguir este patrón:
Una solución a corto plazo y una a largo plazo. Porque el valor expuesto por el problema es limitado y tiene una temporalidad. Por lo tanto, la solución a corto plazo se centra en resolver la urgencia de manera rápida y precisa. ¿Se necesita una solución a largo plazo? Generalmente sí, porque un caso particular de un problema refleja un punto ciego en las soluciones anteriores no considerado. En este caso, analizar la causa raíz y resolverla sistemáticamente permite que este tipo de problemas se resuelvan bien en el futuro, haciendo que la solución original sea más completa. También hay casos donde no se necesita una solución a largo plazo, y es cuando **después de un análisis exhaustivo** concluimos que el costo de resolver el problema sistemáticamente es mayor que el beneficio. (Incluso así, en la mayoría de los casos, subjetivamente queremos resolverlo sistemáticamente. ¿Qué ingeniero no desea resolver problemas de manera sistemática? Pero esto también deja una trampa, que puede llevar a las personas a resolver cosas importantes pero no urgentes, o cosas ni importantes ni urgentes, desperdiciando así un tiempo valioso que podría usarse para resolver otros problemas más valiosos).

4.  Por la noche, continué con el asunto de la tubería CI (`CI Pipeline`).

### 2020-06-01

Hoy, al llegar por la mañana, fui donde Yiming a analizar un problema. Lo analicé toda la mañana. Resultó ser un problema conocido anteriormente (falta de puntos causada por la interpolación del compilador antiguo) que provocó otro problema: al capturar la ruta (`抓路`), justo cerca del segmento faltante, el `lane offset` resultaba negativo.

Terminé hasta bastante tarde, las 4 p.m., después de una noche de trabajo ineficiente y doloroso (siento que en mi estado actual, siempre que trabajo hasta tarde, básicamente se asocia con baja eficiencia).

### 2020-06-02

Llegué por la tarde. Para que Yiming subiera al vehículo, resolví algunos errores y logré que Yiming subiera al vehículo por la noche.

### 2020-06-03

Al llegar por la mañana, fui a ayudar a Yiming con los problemas descubiertos la noche anterior, específicamente el problema de no poder obtener los semáforos.

### 2020-06-04

Esta mañana tenía tres cosas que hacer:

1.  Limpieza de datos y carga de los datos finales del 05/06.
2.  Revisar el problema de anomalía en el ancho - se debía a que no había carril en esa posición.
3.  Revisar el problema de que los puntos de interpolación asignaban el carril incorrecto.
4.  Revisión.

### 2020-06-05

Un día intenso y emocionante. Completé HDMAPMDK-1347 y HDMAPMDK-1352, y también hice una gran refactorización.

Aprendí una lección valiosa: No arriesgarse a hacer cambios enormes cerca de una entrega. Porque sin suficientes pruebas de QA, incluso la refactorización más impresionante puede traer riesgos. Además, sin suficiente tiempo para revisar el diseño (me refiero a mí mismo, porque a veces mientras se escribe el código uno se da cuenta de que el diseño podría estar mal, pero descubrir problemas de diseño durante la implementación es otro problema: comenzar demasiado pronto).

Complemento del lunes:
En este día de refactorización intensa y emocionante, casi no descansé, ni siquiera tuve tiempo para pensar, solo pude confiar en la familiaridad y el estado de flujo (`flow`), escribiendo código con una eficiencia extremadamente alta. En realidad, si no consideramos el principio anterior de no hacer grandes refactorizaciones antes de una entrega, disfruté mucho de este estado. Pero todo debe tener un objetivo y un significado, no solo buscar el placer personal; de lo contrario, ese placer se convierte en un gusto de bajo nivel.

### 2020-06-08

El sábado me mudé a trabajar a Beijing.

La sensación de volver a trabajar en Beijing es un poco desconcertante, todo ha cambiado. Primero, no tengo un puesto de trabajo fijo (Xiuyun contrató a un pasante, y para facilitar el trabajo, su pasante ocupa mi lugar). Esta es la más incómoda de todas las pérdidas. Es como cuando llegué a la clase uno en segundo año de secundaria y me senté en un nuevo asiento sin conocer a nadie, sin querer hablar con ellos. La gente aquí parece familiar pero extraña. Siento que tengo pocos amigos aquí, lo cual juzgo racionalmente que es una ilusión. Pero la sensación de no querer comunicarme con la gente, de querer encontrar un rincón para estar, es real, y de hecho encontré un rincón para estar, al lado de Yuzhang. ¿Por qué no quiero comunicarme con la gente? Todavía no puedo entender este problema. ¿Quizás porque no tengo una razón justificada? Si me preguntan por qué vine a Beijing y por cuánto tiempo me quedaré, balbuceo y digo "un tiempo, uno o dos meses". O tal vez muestra que, en esencia, sigo siendo una persona introvertida, que no le gusta causar molestias y se preocupa mucho por parecer estúpido a los ojos de los demás. Sin embargo, cuanto más escribo, más creo que el segundo componente es mayor e innecesario. Primero, parecer estúpido es mejor que ser realmente estúpido. Pedir ayuda a los demás con sinceridad, incluso de manera torpe, está bien. No temas, no temas cuando eres joven. No temas en ningún momento. Todo está bien (`All is well`).

Ahora, hablemos del trabajo. Durante este tiempo, después de completar la entrega, principalmente la refactorización de TLM (`typed lane model`), esta vez debo definir claramente los objetivos y controlarme, no refactorizar por impulso. Debo tener una estrategia y controlar mi progreso.

Además, configuré mi computadora de escritorio. Resulta que antes no podía conectarme a Internet porque había cambiado la contraseña. Después de un corte de energía, la red perdió completamente la conexión. Así que también necesito configurar la máquina. Esta vez, los objetivos por prioridad son:

1.  Productividad.
2.  Genialidad.
3.  Estética.

Hoy pasé mucho tiempo leyendo el blog de Wang Yin - - Continuando con la desintoxicación. Antes siempre era un fanático religioso frenético, incapaz de ver la esencia de las cosas. Siempre pensaba que algo era la solución definitiva a todos los problemas, pero en realidad, estas "soluciones definitivas" rara vez existen. La mayoría de las veces es solo fervor religioso, como:

-   Vim vs Emacs
-   OOP vs FP
-   Go vs Rust

Etc., etc... Cuando recién me familiaricé con OOP, pensé que OOP era invencible, podía resolver todo. Pero al final solo escribí una gran clase que servía para todo (`天下大同类`), cuando en realidad, tener o no esa clase era irrelevante; lo realmente útil eran las funciones individuales dentro de la clase. Más tarde (estos últimos dos años), me familiaricé con FP y pensé que FP era la bala de plata para resolver todos los problemas. Pero después de escribir programas en Scala por un tiempo, descubrí que mi productividad no mejoró mucho; al contrario, a menudo me enredaba con la sintaxis y la inmutabilidad (`Immutable`), lo que reducía mi eficiencia.

### 2020-06-09

Encontré un poco de ritmo. Instalé Arch, y siento que es incluso más cómodo de usar que Mac.

Jugué Battlegrounds (`酒馆战棋`) con Yuzhang por un buen rato - -

### 2020-06-10

Hoy planeo hacer estas cosas:

1.  HDMAPMDK-1199 `RoadMark` se convierte en una subclase, proporcionando información más rica.
2.  HDMAPMDK-892 Proporcionar trayectorias de experiencia (`经验轨迹`).

Si me sobra energía, trabajaré en la documentación para el lanzamiento de versiones.

Resultado: Completé el 892.

### 2020-06-11

Revisé HDMAPMDK-892 - Proporcionar trayectorias de experiencia.

Descubrí que MDK aún no tenía la adaptación correspondiente. Esta tarde me dediqué a hacer esta adaptación.

Terminé la adaptación, estoy muy cansado.

Sigo experimentando con mi Arch, tratando de registrar algunos pasos de mi configuración como parte de la automatización.

### 2020-06-12

La tarea de hoy es resolver HDMAPMDK-1199. Antes me había olvidado de este problema.

Finalmente lo resolví a las 8 p.m.

### 2020-06-13

Un día muy tranquilo. Después de enviar las pruebas, estuve jugando con mis scripts de automatización.

Al principio pensé en usar shell para escribirlos, pero realmente no me gusta shell, así que comencé a experimentar con scheme. ¡Qué divertido!

### 2020-06-15

Guau, son las 3 p.m. y he estado holgazaneando (`划水`) casi todo el día, navegando por varios sitios web relacionados con scheme y cosas por el estilo. ¡No puedo seguir así!

Hoy debo resolver HDMAPMDK-1378, que es algo que siempre hemos querido evitar: agregar la llamada dirección de la marca del carril (`lane mark direction`) dentro de las intersecciones. Pero las carreteras dentro de las intersecciones no tienen marcas de carril, ¿cómo puede haber dirección de la marca del carril?

Ay, me siento muy incómodo. Después de varios intentos, trabajé hasta muy tarde.

### 2020-06-16

Hoy, después de llegar, estuve revisando todo el tiempo. Había bastantes cosas que modificar, y luego comencé a sentirme un poco desmotivado. Finalmente, lo completé a duras penas, y luego el hermano Kuan (`宽哥`) encontró varios errores más.

Por la tarde, me enteré de que el hermano Xiao (`潇哥`) se iba. Me quedé atónito por un buen rato.

Por la noche, experimenté un poco con scheme y logré compilar y referenciar bibliotecas personalizadas.

### 2020-06-17

El trabajo principal de hoy es terminar los detalles del último ciclo de iteración, es decir, corregir errores.

### 2020-06-18

Hasta hoy, finalmente vamos a terminar las cosas del último ciclo de iteración.

Me siento muy mal en general. La razón es que el significado de lo que estoy haciendo no es claro; de hecho, creo que básicamente no tiene mucho sentido.

Entonces, ¿cómo defino el significado aquí?

El significado del trabajo actual para mí, en orden de importancia de mayor a menor, es:

1.  La capacidad de identificar problemas, de descubrir problemas valiosos y significativos.
2.  Acumular la capacidad de modelar problemas, para poder resolver más problemas de diversos tipos en el futuro.
3.  Modelar problemas, haciendo posible resolver una clase de problemas descritos por el modelo a través de un esfuerzo único.
4.  A través de mi esfuerzo, poder resolver problemas específicos y significativos. Resolver un problema de una vez tiene menos significado que invertir un esfuerzo para resolver múltiples problemas de una clase.
5.  Mantener el placer, la sensación de logro al resolver problemas, la naturaleza interesante del problema en sí.
6.  La comunicación y las relaciones con las personas.
7.  El salario (es una garantía, no es que no sea importante, sino que las demás partes deben construirse sobre él).

Puede que no incluya todas mis motivaciones laborales, pero al menos refleja parte de la realidad.

La razón por la que me siento desanimado hoy, creo, se debe principalmente a la pérdida de interés. Primero, el significado del problema en sí no me es claro, lo que reduce un poco la motivación. Segundo, el modelado de este tipo de problemas no es lo suficientemente preciso, lo que hace que los métodos de solución no resuelvan todos los problemas (por supuesto, rara vez existe un modelo que resuelva todos los problemas, porque el modelo en sí es una simplificación y abstracción del problema; aquí hablamos de resolver problemas dentro de un rango aceptable), lo que lleva a repeticiones. Específicamente, los errores reportados uno tras otro por los compañeros de QA, aunque algunos se deben a una comprensión insuficiente de los requisitos o son problemas de las pruebas mismas, el tiempo dedicado a analizar el problema ocupa la parte más larga de todo el proceso de solución.

A veces, una comprensión superficial del problema conduce a soluciones no esenciales, haciendo que las personas inviertan tiempo en trabajo inútil. Básicamente, los puntos 3, 4 y 5 del significado anterior no se satisfacen, lo que me hace sentir desanimado.

Además, hay que considerar que hasta ahora solo he estado resolviendo problemas que deberían haberse resuelto en el último ciclo de iteración. Aún no he comenzado en