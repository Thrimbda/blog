---
"title": "オブザーバーパターン実力分析"
"summary": "本稿ではまず、オブザーバーパターンの基本概念を紹介します。定義、別名、動機、参加者を含み、このパターンがオブジェクト間の依存関係と状態同期の処理によく用いられることを指摘します。J2EEにおけるActionとActionListenerの実例を通じて、オブザーバーパターンがModelとViewの結合度を低減する実際の応用を示します。実例では、JTextFieldが具体的な目標（ConcreteSubject）として、複数のActionListenerが具体的な観察者（ConcreteObserver）として機能し、テキストボックスの状態が変化した際に自動的に観察者に通知して対応する操作を実行します。本稿は、オブザーバーパターンが通常の関数呼び出しやコールバック関数と比較して、オブジェクト間の一貫性をより効果的に維持し、コードの再利用性を高めることを強調しています。"
"tags":
  - "デザインパターン"
  - "オブザーバーパターン"
  - "J2EE"
  - "Action"
  - "ActionListener"
  - "システム分析と設計"
  - "MVC"
  - "結合度"
"date": "2017-04-10"
---

---
title: オブザーバーパターン実力分析
date: 2017-04-10
taxonomies:
  tags:
    - デザインパターン
    - システム分析と設計
---

> 一般的に、オブジェクト指向分析と設計には、通常の関数呼び出し以外に、コールバック関数がよく用いられる三つのイベント処理メカニズムが存在します。J2EEではさらに、リスナー方式に基づくイベント処理メカニズムが提供されています。資料を調査し、ActionおよびActionListenerのメカニズムを分析し、分析実例を完成させてください。

まずオブザーバーパターンを理解します。

<!--more-->

## オブザーバーパターン (Observer Pattern)

### 現実世界におけるオブザーバー

オブザーバーパターンは、Publish-Subscribe（発行-購読）パターンとも呼ばれます。例えば、RSS（WeChatプッシュの元祖）の購読では、あるブログ（被観察者）の投稿者が記事を更新すると、購読者のリーダー（観察者）が自動的に更新を受け取ることができます。この発行-購読の仕組みを、オブザーバーパターンと呼びます。

### オブザーバーパターン

**G**ang **O**f **F**our（GoF）によるオブザーバーパターンの記述：

> - 意図
>
>   オブジェクト間の一対多の依存関係を定義します。あるオブジェクトの状態が変化したとき、それに依存するすべてのオブジェクトに通知が届き、自動的に更新されます。
>
> - 別名
>
>   依存(Dependents)、発行-購読(Publish-Subscribe)
>
> - 動機
>
>   システムを一連の相互に協調するクラスに分割すると、関連するオブジェクト間の一貫性を維持する必要が生じるという一般的な副作用があります。一貫性を維持するためにクラスを密結合にすることは望ましくありません。なぜなら、それはクラスの再利用性を低下させるからです。
>
> ...
>
> - 参加者
>
>   - Subject（目標）
>
>     目標は自身の観察者を知っています。任意の数の観察者が同一の目標を観察することができます。
>
>     観察者オブジェクトの登録と削除のインターフェースを提供します。
>
>   - Observer（観察者）
>
>     目標が変化したときに通知を受け取る必要があるオブジェクトに対して、更新インターフェースを定義します。
>
>   - ConcreteSubject（具体的な目標）
>
>     関連する状態を各ConcreteObserverオブジェクトに保存します。
>
>     自身の状態が変化したとき、各観察者に通知します。
>
>   - ConcreteObserver（具体的な観察者）
>
>     ConcreteSubjectオブジェクトへの参照を保持します。
>
>     関連する状態を保存します。この状態は目標の状態と一致している必要があります。
>
>     Observerの更新インターフェースを実装し、自身の状態を目標の状態と一致させます。

オブザーバーパターンは、以下のような場合によく適用されることがわかります：

- 二つのオブジェクトが依存関係にある場合。
- あるオブジェクトを変更する際に、同時に他のオブジェクトも変更する必要がある場合。

通常の関数呼び出しやコールバック関数と比較して、オブザーバーパターンの使用は、低コストでオブジェクト間の一貫性を維持することができ、オブジェクト間の**結合度を大幅に低下させ**、同時にブロードキャスト効果を達成できます。これは前者の二つでは実現できないことです。オブザーバーパターンの使用は、コードの再利用性を**大幅に向上させます**。

**そして、J2EEにおけるActionとActionListenerは、まさにオブザーバーパターンの生きた例です。**

## J2EEにおけるAction&ActionListener

Action&ActionListenerは、MVCパラダイムにおいて、ModelとViewの結合度を低減するためにうまく適用できます。

非常に良い[例](http://www.ulisespulido.com/2009/03/observer-design-pattern-and-java-swing.html)を見つけました。コードは以下の通りです：

```java
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JTextField;

public class Frame extends JFrame {

  ActionListener observer1 = new Observer("First Observer");
  ActionListener observer2 = new Observer("Second Observer");
  ActionListener observer3 = new Observer("Third Observer");

  public Frame(){
    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    init();
  }

  private void init(){
    addChangingTextField();
    pack();
    setVisible(true);
  }

  private void addChangingTextField(){
    //Observable class TextField. each time
    //An action or event occurs the observers will be updated
    //Almost all the Swing classes has this kind of behavior
    JTextField dataTextField = new JTextField();

    // Observer registering to the observable class.
    dataTextField.addActionListener(observer1);
    dataTextField.addActionListener(observer2);
    dataTextField.addActionListener(observer3);

    add(dataTextField);
  }

  public static void main(String [] args){
  	Frame frame = new Frame();
  }
}

class Observer implements ActionListener{

  private String name;
  private String message;

  public Observer (String s){
  	name = s;
  }

  public void actionPerformed(ActionEvent e) {
    JTextField textField = (JTextField) e.getSource();
    message = textField.getText();
    JOptionPane.showMessageDialog(null,
    name + " has been confirmed about the change, Thanks!! "
    + " The Message was: " + message);
  }
}
```

### 分析

二つのクラスはそれぞれAction/ActionListenerの役割を担っています。`frame.dataTextField`は`addChangingTextField`メソッド内で三つのリスナー（`observer1`, `observer2`, `observer3`）にバインドされています。フレーム内のテキストボックスが編集されると（状態が変化）、Observerクラスの`actionPerformed`メソッドがトリガーされ、対応するテキストが表示されます。

この例では、`frame.dataTextField`が`ConcreteSubject`として、`observer1`, `observer2`, `observer3`が`ConcreteObserver`として機能します。そして、それらが実装しているAction/ActionListenerメソッドを定義したインターフェースが、それぞれの`Subject`と`Observer`となります。

観察者をバインドした後、目標は観察者の具体的な動作を気にせず、自身の状態が変化したときに観察者に通知するだけです。観察者が何をするかは観察者自身が決定します。したがって、この方法は非常に優れており、関数を明示的に呼び出したり、コールバック関数を実行して動作をトリガーする方法よりもはるかに優れており、学ぶ価値があります。