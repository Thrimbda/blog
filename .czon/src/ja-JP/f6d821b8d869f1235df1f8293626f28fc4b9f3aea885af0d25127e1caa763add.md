---
"title": "並行処理の再考（アクターモデル）"
"summary": "本稿ではまず、並行プログラミングにおいて、複数のワーカーが非同期に動作し、それぞれが異なる役割を担う場合、単一のメッセージキューを共有すると、メッセージの宛先指定ができず、誤った受信や時系列の問題が発生することを論じています。\
  著者は段階的な分析を通じて、このようなシナリオにおける共有メッセージキューの非効率性と潜在的なバグを指摘します。続いて、根本的な解決策としてアクターモデルを導入します。このモデルでは各ワーカーに独立したメッセージキュー（メールボックス）を割り当て、完全なメッセージ分離と非同期通信を実現します。\
  本稿では、並列実行、メッセージパッシング、アドレス機構を含むアクターモデルの概念を詳細に説明し、Pythonスレッドによる実装例として基本的なアクター（BaseWorker）の構築方法を示すサンプルコードを提供します。\
  最後に、著者は並行プログラミングにおけるアクターモデルの利点をまとめ、その抽象的な思考法と「高凝集、低結合」の実践的価値を強調しています。"
"tags":
  - "python"
  - "並行処理"
  - "アクターモデル"
  - "メッセージキュー"
  - "非同期プログラミング"
  - "マルチスレッド"
  - "プログラミングモデル"
"date": "2017-05-19"
---

---
title: 並行処理の再考（アクターモデル）
date: 2017-05-19
taxonomies:
  tags:
    - python
    - 並行処理
---

[前回](http://0xc1.space/2017/05/06/初探并发/)は、メッセージキューを用いてスレッド（プロセス）間でメッセージをやり取りし、それによってスレッド間通信を実現する方法について述べました。

<!--more-->

## 共有メッセージキュー

これは、**並行処理がシステムのスループット向上のみを目的としているという前提**に基づいています。この仮定の下では、各ワーカーは同じ仕事を行うため、単一のメッセージキューを共有し、誰が次の命令を受け取っても問題ありません。

### もし私たちが同じ仕事をしないなら

例えば、各ワーカーが異なる役割を担い、非同期に動作するシステム（例：IP電話）を実装する必要がある場合はどうでしょうか？ 上記の方法をそのまま使用し、すべてのワーカーが単一のメッセージキューを共有すると、問題が発生します：メッセージを特定のワーカーに送信することができません。

この問題をどう解決するでしょうか？ 単純で直接的な解決策は、各メッセージに識別子を付けて、そのメッセージの送信先を指定することです：

```python
queue = Queue([('worker_Aへ送信', 'do_something1'),
               ('worker_Bへ送信', 'do_something2'),
               ('worker_Bへ送信', 'do_something3'),
               ('worker_Cへ送信', 'do_something4'),
               ('worker_Aへ送信', 'do_something5')])
```

これで問題は解決したように見えますね？ しかし、新たな問題を導入してしまいました。

### もし誤って他人への手紙を開封してしまったら

もしworker A宛のメッセージがworker Bによって受信されてしまった場合、worker Bにとってそのメッセージは何の役にも立ちません。一方、本来そのメッセージを受け取るべきworker Aはそれを受け取れず、メッセージは失われてしまいます。これはworker Bの時間を浪費し、worker Aの時間を無駄にし、さらにはステップの飛び越しによってシステム全体が奇妙なバグに陥る可能性さえあります。

この問題はどう解決すればよいでしょうか？ 直感的には、各ワーカーに以下の戦略を追加すれば問題は解決するように思えます：他人宛のメッセージを受け取ったら、そのメッセージをメッセージキューに戻す。

```python
class Worker_B:
    
    def run(self):
        while True:
            if not self.queue.empty():
                data = self.queue.get()
                if data['to_whom'] == 'worker_B':
                    do_something_with_data
                else:
                    self.queue.put(data)
```

一見、修正を重ねて問題を解決したように見えます... しかし実際には、また新たな問題を導入してしまいました。

### これは行き止まりのように見える

第一に、メッセージキューはキューであり、FIFO（先入れ先出し）を意味します。優先順位付きメッセージキューを導入したとしても、本質的にはこの点は変わりません。このため、本来最初にworker Aに渡されるべきメッセージが、worker Bによって「いじくり回された」結果、現在のメッセージキューの中でworker Aに渡されるのが最も遅くなってしまい、システムが奇妙なバグに陥る可能性があります。

第二に、たとえ誤って配信されたメッセージをメッセージキューの先頭に戻す方法を考えたとしても、誤ったメッセージを受け取ったworker Bの「受信-確認-戻し」操作をアトミック操作にするためのロック機構を導入しなければ、worker Bがメッセージを戻す操作を実行している間に、他のワーカーがすでにメッセージ受信操作を続行している可能性があり、依然として時系列上の大きな問題を引き起こす可能性があります。ロック機構を導入すれば論理的なエラー問題は解決できますが、これにより各ポーリングサイクルで実際に作業できるワーカーは1つだけになり、誤ったメッセージを受け取って「受信-確認-戻し」操作を実行する他のワーカーは自分のタイムスライスを無駄にし、**効率が非常に低下します。**

したがって、非同期作業のために並行処理を導入するシステムにとって、各ワーカーが単一のメッセージキューを共有することは良い方法ではないようです。

この問題を根本的に解決する方法は、同じタスクを実行するワーカーのグループごとに専用のメッセージキュー（メールボックス）を設けること、あるいは各ワーカーに独自のメッセージキューを設定し、スレッド間でのメモリ共有能力を完全に放棄することです。後者の方法が、本日お話しする主役である**アクターモデル（Actor model、参加者モデル）**です。

## アクターモデル

まず、ウィキペディアによるアクターモデルの定義と概念を見てみましょう：

### 概念

コンピュータ科学において、アクターモデル（英語: Actor model）は並行計算におけるモデルの一つです。「アクター」はプログラム上の抽象概念であり、並行計算の基本単位と見なされます：アクターがメッセージを受信すると、いくつかの決定を行い、より多くのアクターを作成し、より多くのメッセージを送信し、次のメッセージにどのように応答するかを決定することができます。アクターモデルは1973年にCarl Hewitt、Peter Bishop、Richard Steigerの論文で提唱されました。

アクターモデルが提唱する哲学は「すべてがアクターである」というもので、オブジェクト指向プログラミングの「すべてがオブジェクトである」という考えに似ていますが、オブジェクト指向プログラミングは通常逐次実行されるのに対し、アクターモデルは並列実行されます。アクターは計算実体であり、受信したメッセージに応答し、同時に並列に以下の操作を行います：

- 他のアクターに有限数のメッセージを送信する；
- 有限数の新しいアクターを作成する；
- 次のメッセージを受信したときの動作を指定する。

上記の操作には逐次実行の前提が含まれていないため、並列に行うことができます。送信者と送信済みメッセージの分離は、アクターモデルの根本的な利点です。これにより、非同期通信が可能になり、メッセージパッシングの制御構造が満たされます。メッセージの受信者はアドレスによって区別され、これは「メールアドレス」とも呼ばれることがあります。したがって、アクターは自分がアドレスを持っているアクターとのみ通信できます。アクターは受信した情報からアドレスを取得したり、自分が作成したアクターのアドレスを取得したりすることができます。アクターモデルの特徴は、アクター内部またはアクター間で並列計算が行われ、アクターは動的に作成でき、アドレスはメッセージに含まれ、相互作用は直接的な非同期メッセージ通信のみを通じて行われ、メッセージの到着順序に制限がないことです。

### 実装

アクターは十分にシンプルで、並行処理のために生まれ、変化を隔離するのに十分なカプセル化を備えています（例：マルチスレッドかマルチプロセスかを気にしない）。

典型的なアクターのPythonスレッド実装を見てみましょう：

```python
from queue import Queue
from threading import Thread, Event


class WorkerExit(Exception):
    # タスク終了用の例外
    pass


class BaseWorker(object):
    # Actor
    def __init__(self):
        self._mailbox = Queue()
        super(BaseWorker, self).__init__()

    def send(self, msg):
        self._mailbox.put(msg)

    def recv(self):
        msg = self._mailbox.get()
        if msg is WorkerExit:
            raise WorkerExit()
        return msg

    def close(self):
        self.send(WorkerExit)

    def start(self):
        self._terminated = Event()
        t = Thread(target=self._bootstrap)

        t.daemon = True
        t.start()

    def _bootstrap(self):
        try:
            self.run()
        except WorkerExit:
            pass
        finally:
            self._terminated.set()

    def join(self):
        self._terminated.wait()

    def run(self):
        raise NotImplementedError
```

簡単に説明すると、このアクター（BaseWorkerと名付け、実際のプロジェクトでは親クラスとして使用します）は、メールボックスとしての`Queue`と、メインスレッドをブロックする終了手段としての`Event`という2つのデータ構造を維持します。

ここでの外部インターフェースとしての核心操作は`send()`メソッドのみです。注意してください、**私たちは渡すことができるメッセージの型を制限しません**。これは非常に高い柔軟性を意味します。

アクター内部では、1つのスレッドを使用して`run()`メソッドを実行し、`recv()`メソッドと組み合わせて指定された具体的な作業を実行します。特筆すべきは、タスクを停止するための番兵信号`WorkerExit`を設定している点です。`WorkerExit`の動作原理は、それが識別された後に例外としてスローされることです。この例外処理ではさらに多くのことを行うこともできますが、ここではこの例外をキャッチしたときにスレッドの実行を停止するだけです。この例外処理の実装は、`run()`メソッドをラップする`_bootstrap()`メソッドに依存しています。

アクターモデルの哲学の下で、このシンプルな例を拡張し、さらに先へ進むことができます。

## まとめ

並行プログラミングには、通常よりもさらに抽象的な思考法が必要であり、「高凝集、低結合」という思想の良い実践ともなり得ます。

私にとってこの全く新しい分野の探求において、アクターは確かに道を照らす明るい灯台であり、私を本当の意味で入門させてくれました。ですから、ここで共有させていただきます。 :)