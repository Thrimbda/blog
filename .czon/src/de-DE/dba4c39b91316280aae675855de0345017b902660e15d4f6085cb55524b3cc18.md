---
"title": "Erste Schritte in die Nebenläufigkeit"
"summary": "Der Autor dieses Artikels kam durch eine kleine Aufgabe mit nebenläufiger Programmierung in Berührung und erstellte mit Pythons queue-, signal- und time-Modulen eine einfache Demo, die zeigt, wie Thread-Kommunikation über eine Nachrichtenwarteschlange realisiert werden kann. Der Artikel erklärt die Rolle von queue als Nachrichtenwarteschlange, signal zum Abfangen von KeyboardInterrupt und time für die Reaktion des Hauptthreads. Er beleuchtet zudem das Designkonzept der Verwendung von Nachrichtenwarteschlangen in Multithreading-Umgebungen zur Reduzierung der Systemkopplung und betont die Bedeutung von 'Design für Veränderung'."
"tags":
  - "python"
  - "Nebenläufigkeit"
  - "Multithreading"
  - "Nachrichtenwarteschlange"
  - "queue"
  - "signal"
  - "time"
"date": "2017-05-07"
---

---
title: Erste Schritte in die Nebenläufigkeit
date: 2017-05-07
taxonomies:
  tags:
    - python
    - Nebenläufigkeit
---

Gut, eine kleine Aufgabe hat mich kürzlich dazu gebracht, wirklich sinnvolle nebenläufige Programmierung kennenzulernen.

<!--more-->

## Demo

Also habe ich mit Pythons `queue`-, `signal`- und `time`-Modulen eine kleine Demo erstellt, die zwar nicht wirklich multithreaded ist, aber zur Veranschaulichung dient:

```python
# -*- coding: utf-8 -*-
# @Author: Michale
# @Date:   2017-05-04 15:00:41
# @Last Modified by:   Michale
# @Last Modified time: 2017-05-07 00:46:52
import signal
import queue
import time


class TestClass(object):
    queue = queue.Queue()

    def __init__(self):
        signal.signal(signal.SIGINT, self.stopIfPressKill)

    def stopIfPressKill(self, mySignal, stack):
        if mySignal == signal.SIGINT:
            print('you pressed CTRL-C')
            self.queue.put_nowait('stop')
            print(self.queue.qsize())

    def mainThread(self):
        while True:
            time.sleep(1)
            if not self.queue.empty():
                data = self.queue.get()
                print(data)
                if data == 'stop':
                    break
                else:
                    self.queue.put(data)


if __name__ == '__main__':
    yoo = TestClass()
    yoo.mainThread()

```

Erklärung der drei Module:

- `queue`: Dient als Nachrichtenwarteschlange – hier vielleicht etwas überdimensioniert.
- `signal`: Wird verwendet, um nach dem Abfangen von `KeyboardInterrupt` das Stoppsignal in die Nachrichtenwarteschlange zu legen.
- `time`: Ermöglicht es dem Hauptthread, diesen `KeyboardInterrupt` abzufangen.

## Konzept

Die Einführung von Multithreading erschwert die Kontrolle von Nicht-Hauptthreads nach ihrem Start erheblich, weshalb man gezwungen ist, Methoden wie Nachrichtenwarteschlangen für die Thread-Kommunikation zu verwenden.

Aber unabhängig davon, ob Multithreading im Spiel ist oder nicht, sollten Systemmodule ihre Details kapseln und Ereignisse für die Zusammenarbeit nutzen. Dies trägt erheblich zur Reduzierung der Systemkopplung bei und ist ein gutes Designprinzip für Systeme: **Entwurf für Veränderung.**