---
"title": "Diario de Prácticas (II): Resumen del Desarrollo de API Backend y Gestión de Proyectos"
"summary": "Este artículo es un diario de resumen del autor tras completar la versión básica del servidor API backend del proyecto de prácticas. El artículo detalla el diseño del proyecto 'Seed' (un sistema de gestión de objetivos centrado en Mini Program de WeChat), incluyendo la definición clara del posicionamiento del producto, las características principales (como sistema de usuarios, gestión de objetivos, compatibilidad multi-cliente, etc.) y la adopción de la arquitectura RESTful API. En cuanto a la implementación, el autor presenta la elección del stack tecnológico utilizando Spring y comparte la estrategia de pruebas durante el desarrollo. Además, el autor reflexiona sobre sus deficiencias como gestor de proyecto en el control del progreso, asignación de personal y formación técnica, y analiza el equilibrio entre la capacidad de arquitectura de sistemas y la capacidad de implementación de algoritmos específicos que requiere un ingeniero de software, considerando que las prácticas son un complemento importante a la educación en el aula."
"tags":
  - "Prácticas"
  - "Gestión de Proyectos"
  - "Desarrollo Backend"
  - "Framework Spring"
  - "Mini Program de WeChat"
  - "RESTful API"
  - "Diseño de Software"
  - "Resumen Personal"
"date": "2017-03-12"
---

---
title: Diario de Prácticas (II)
date: 2017-03-12 16:09:19
taxonomies:
  tags:
    - Cotidiano
    - Prácticas
    - Reflexiones
---

Las prácticas están a punto de llegar a su fin. En este punto, el trabajo de codificación de la versión básica del servidor API backend está prácticamente terminado. Es momento de hacer un resumen.

Como líder del grupo del proyecto, mi único conocimiento sobre gestión de proyectos de software proviene de haber leído *The Mythical Man-Month* durante las vacaciones de invierno. Tras esta práctica, me doy cuenta de que aún soy muy inexperto. Sin embargo, creo que he aprendido algunas cosas.

<!--more-->

## Diseño

Comparado con hace dos años, cuando empezaba a escribir las tareas de C en VS sin pensarlo dos veces, hoy en día he cambiado bastante.

~~En primer lugar, hace mucho que no abro VS.~~

En resumen, durante estos dos años he pasado por la etapa de aprendizaje puro e inocente de Python, la experiencia de desarrollar la interfaz de usuario del robot en el equipo de robótica, la experiencia de escribir crawlers para el sitio web de la oficina académica (tanto para profesores como para estudiantes), y el desarrollo de la herramienta de gestión de archivos para el proyecto "Zumo de Naranja". Al principio, por supuesto, me lancé sin pensar, pero supongo que después de sufrir las consecuencias de las contradicciones, aprendí la importancia de diseñar con antelación. Una vez dentro del mundo del diseño, la cuestión pasa a ser el grado de profundidad; por lo tanto, esta experiencia de dirigir todo el proyecto ha sido un ejercicio muy beneficioso.

**Primero, aclarar qué se quiere hacer**. Esta pregunta es crucial para un equipo que realmente quiere crear un producto: **definir su propio producto** es una cuestión a nivel estratégico. Lamentablemente, esta vez no surgieron ideas particularmente interesantes, y con la responsabilidad sobre mis hombros, mi expectativa para estas prácticas era hacer un proyecto sólido y sencillo.

En pocas palabras, se trata de una **aplicación web tradicional con las Mini Programs de WeChat como característica principal**: concretamente, un sistema de gestión de objetivos.

Hay mucha gente que hace esto, por lo que es posible encontrar muchos esquemas maduros para modelar las tareas a enfrentar: como Worktile, orientado a proyectos; WonderList, orientado a la gestión personal de la vida; My Study Life, orientado a estudiantes; e incluso las "Recordatorios" de Apple y otras herramientas que he oído mencionar pero no he usado. Sintetizando las características de estas herramientas, se puede resumir un clásico sistema de gestión de objetivos con características de WeChat: así nació nuestro `Seed`.

### Características que debería tener

Entonces, ¿qué debería poder hacer `Seed`?

+ Tener un sistema de usuarios sencillo para facilitar la sincronización y aumentar la fidelidad del usuario.
+ Los usuarios pueden crear y gestionar libremente objetivos, similares a los "proyectos" de Worktile.
+ Los usuarios pueden ser invitados a los objetivos de otros.
+ Los objetivos se dividen en tipo "check-in diario" (recurrente) y tipo "proyecto específico" (único, pueden incluir hitos).
+ El frontend principal son las Mini Programs de WeChat.
+ También es compatible con otros clientes potenciales.

De esto se deduce que `Seed` debería ser un servicio práctico, pequeño y minimalista, lo que coincide con el propósito original de las Mini Programs de WeChat.

Es necesario enfatizar aquí la característica de "**pequeño y minimalista**". ¿Por qué pequeño y simple? Primero, porque no hay suficiente personal y el tiempo es limitado. Segundo, para evitar el error común en los "segundos proyectos" mencionado en *The Mythical Man-Month*: la arrogancia ciega que lleva a añadir infinitas características redundantes a un proyecto. Esto es un esfuerzo inútil, especialmente porque no involucramos ingresos por publicidad. Un ejemplo simple: la versión de Mac OS de Xunlei y la versión de Windows de Xunlei; obviamente, a todos les gusta más la versión Mac, minimalista y útil.

También debe tener una buena compatibilidad con las Mini Programs de WeChat. Para proporcionar una transición fluida en la experiencia del usuario, se debe admitir tanto el email como nombre de usuario para iniciar sesión, como el openId de WeChat como credencial de acceso.

### Estructura del sistema

Como se mencionó anteriormente, queremos hacer una aplicación web con las Mini Programs de WeChat como característica principal. Esto significa que `Seed` tiene la capacidad (~~y la ambición~~) de ser compatible con otros frontends. Por lo tanto, una API de estilo RESTful se convierte en la mejor opción: desacoplamiento total entre frontend y backend, estructura clara y fácil de consumir.

Por lo tanto, `Seed` debería consistir en las Mini Programs de WeChat y otras formas potenciales como frontend, consumiendo los "recursos" proporcionados por el backend a través del protocolo HTTP.

El backend proporciona servicios seguros y confiables a través de la API.

Para ello también he aprendido un poco, conociendo la idea de HATEOAS (Hypermedia As The Engine Of Application State). Aunque aún no está madura, representa un posible futuro.

## Implementación

Dado que solo participé en el trabajo de codificación del servidor API, aquí solo hablaré de la implementación del backend.

Me gusta clasificar el diseño en el nivel estratégico (el "Tao"), y el trabajo restante en el nivel táctico (el "Shu"). Por lo tanto, la elección de tecnologías y cómo implementar concretamente un sistema pueden incluirse aquí.

### Tecnología

Debido a los requisitos de las prácticas, y también por el deseo de utilizar el lenguaje Java de manera adecuada, elegí `Spring Framework` como framework backend, utilizando también el ecosistema completo de Spring:

+ Spring Boot como contenedor de aplicaciones
+ Spring Framework para implementar la lógica de negocio
+ Spring Data como DAO
+ Spring Session para gestionar las sesiones
+ Spring Test para pruebas

Además, utilicé herramientas como Git, TravisCI y Heroku para mejorar la experiencia de desarrollo.

### Proceso de desarrollo

Como mencioné antes, la experiencia de escribir Controllers en Spring es muy similar a la de usar el framework web Flask de Python. ¿Quizás Flask tomó alguna inspiración de Spring? Creo que las clases controladoras orientadas a recursos son mucho más compactas que la tradición de Java Web de escribir un Servlet para cada recurso.

Spring promueve el desarrollo guiado por pruebas (TDD). Hacerlo realmente no es fácil, ya que las pruebas no suelen ser un trabajo popular. Asignar a una persona específica para escribir código de pruebas tiene un alto costo de aprendizaje y también plantea algunos problemas interpersonales. Por lo tanto, durante el desarrollo decidí que cada persona fuera responsable de probar su propio código. Finalmente, yo revisaría el código.

## Resumen

La parte más destacable sobre `Seed` en sí ya ha sido comentada. Ahora hablemos de otras cosas.

### Resumen personal

Aprendí mucho durante las prácticas, pero aún hay problemas.

Como gestor de proyecto, soy bastante incompetente. El control del progreso, la asignación de personal y otros detalles tienen muchas deficiencias.

Por ejemplo:

- La falta de conocimiento sobre tecnologías frontend probablemente resulte en que solo el servidor API sea funcional al final del proyecto.
- Solo la mitad de los miembros del grupo participaron realmente.
- La formación para quienes participaron en el trabajo fue vaga y careció de paciencia.

Obviamente, todavía necesito seguir desarrollándome. Pero el hecho de actuar tanto como gestor de proyecto como desarrollador me llevó a reflexionar sobre otro tema.

### Discusión sobre dos capacidades del Ingeniero de Software

**La capacidad de arquitectura y control de todo el sistema** y **la capacidad de seleccionar, adaptar y utilizar algoritmos para implementar una funcionalidad concreta**.

La educación en el aula de nuestra facultad de software parece centrarse solo en lo segundo. Esto no es extraño, ya que el dominio de los algoritmos es fácil de medir; se podría decir que las diferencias en habilidad son evidentes, como resolver problemas matemáticos: bajo condiciones y restricciones estrictas, la creatividad de las personas es muy fácil de evaluar. Sin embargo, la capacidad de establecer racionalmente estas llamadas "condiciones y restricciones estrictas", aunque importante, es difícil de medir.

En cuanto a por qué digo que es contradictorio, pongamos un ejemplo simple y comprensible, aunque quizás no del todo apropiado: todos saben que es ingenuo e irrealista que los padres prohíban a sus hijos tener relaciones sentimentales tempranas con el pretexto de que afectan los estudios, y luego esperen que formen una familia inmediatamente después de graduarse. Esperar implícitamente que los estudiantes, **solo** con buenas calificaciones académicas, se conviertan en personas completas al graduarse es también una idea algo distorsionada. La diferencia entre estos dos casos es que la contradicción en el segundo no es tan aguda como en el primero.

Creo que este tipo de prácticas son efectivamente una compensación por las deficiencias de la educación en el aula, y representan una oportunidad para evitar la contradicción entre el **rendimiento académico** como medio de formación y la **capacidad** como objetivo de formación, que estos dos símbolos representan.