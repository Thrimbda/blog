---
"title": "Arbeitsprotokoll 2020"
"summary": "Dieses Dokument ist das Arbeitsprotokoll des Autors für das erste Halbjahr 2020. Es enthält detaillierte Aufzeichnungen der Arbeitsinhalte von April bis Juli, darunter hauptsächlich die Entwicklung eines Map-Daten-Kompilierungssystems, Bugfixes, technische Refactorings (wie TLM-Refactoring), Teamarbeit (z.B. Diskussionen mit Kollegen über Schnittstellen und Lösungen), Interviews sowie Gedanken zur persönlichen Karriereentwicklung. Das Dokument behandelt nicht nur konkrete technische Aufgaben (wie benutzerdefinierte Geschwindigkeitsbegrenzungen, Lane-Line-Bindung, Behebung von Speicherlecks), sondern auch Reflexionen des Autors über Arbeitseffizienz, Codequalität, Projektmanagement (wie CI/CD-Pipelines) und Karriereplanung. Im Protokoll äußert der Autor wiederholt die Suche nach dem Sinn der Arbeit, kritisches Nachdenken über technische Entscheidungen und mentale Veränderungen in einem Hochdruck-Lieferumfeld."
"tags":
  - "Arbeitsprotokoll"
  - "Softwareentwicklung"
  - "Kartendaten"
  - "Technische Reflexion"
  - "Teamarbeit"
  - "Projektmanagement"
  - "Karriereentwicklung"
"date": "2020-01-01"
---

### 2020-04-13

- Leistungsbewertung (Self-Assessment) abgeschlossen
- Überarbeitung der Lane Center Aggregation

### 2020-04-14

- [ ] Geschwindigkeitsbegrenzungskompilierung
- [ ] Benutzerdefinierte Geschwindigkeitsbegrenzungen

### 2020-04-15

- Lösung für benutzerdefinierte Geschwindigkeitsbegrenzungen mit @guangcong festgelegt
  1.  Ein neues `module-dynamicEvent` verwenden, um dieses Problem zu lösen.
  2.  Updates benutzerdefinierter Geschwindigkeitsbegrenzungen als neues Event veröffentlichen, das ein Update der Horizon-Daten auslöst.
  3.  Ausnahmebehandlung und Speicherprobleme müssen berücksichtigt werden.
      Nach der Diskussion mit Guangcong stieß dieser auf einige Probleme.
- Code-Review von Xiaokang
  Java als solide Sprache hat doch einiges zu bieten.
- Geschwindigkeitsbegrenzungskompilierung
  Kaum Fortschritte, lediglich Logik zum Extrahieren von RoadCenterTile hinzugefügt.
- Sectioning-Problem gelöst, EdgeLifting-Optimierungsansatz analysiert, Optimierungsalgorithmus vorgeschlagen:
  Gegeben einen Traverse-Kopf und eine Konnektivitätsfunktion, wird die Traversierungsweise angegeben.
- Prinzip von selbstausführenden JARs untersucht.

### 2020-04-16

- Mit Yiming die Schnittstelle für benutzerdefinierte Geschwindigkeitsbegrenzungen abgestimmt: Er stellt sicher, dass ein eingegebenes Location-Pair eine eindeutig kürzeste Route bestimmt.
  Anschließend mit Guangcong den Algorithmus zur Generierung benutzerdefinierter Geschwindigkeitsbegrenzungen durchgearbeitet.
  1.  Gegeben eine Route.
  2.  Bekannt: | start DiRoadOnPath::count - end DiRoadOnPath::count | ≤ 1
      Dann kann definitiv ein Paar (start DiRoadOnPath, end DiRoadOnPath) gefunden werden, das den kürzesten Abstand hat.
- Für Xiaokang eine nutzbare Schnappschussversion des Pylon-v0.1.1-Compilers temporär veröffentlicht.
- Mit Hanteng herumgelaufen und gequatscht.
- Mit Zizhe und Yicheng die SUMO-Kartennutzungsschnittstelle abgestimmt.
- SpeedLimit-Kompilierung erfolgreich, aber noch nicht verifiziert.

### 2020-04-17

- SpeedLimit-Kompilierung verifiziert:
  `OSMSerializable` funktioniert nicht gut, da gebundene SpeedLimits keine Geometry haben.
  Mögliches Problem: Geschwindigkeitsbegrenzungsbindung bei Auffahrten könnte Probleme verursachen.
- [ ] Interpolation
- [ ] Hausdorff-Distanz
- [ ] LcInJunctionTile

#### Einige verrückte Ideen

- Direkt mit Spark anfangen?
- Was braucht der OSM-Kontext?

### 2020-04-18

Geschwindigkeitsbegrenzungen abgeschlossen.

### 2020-04-20

#### Benutzerdefinierte Geschwindigkeitsbegrenzungen

- Guangcong hat die Eingabe in einen Vektor geändert und Tests hinzugefügt.
- Ein kleines Problem: Guangcong versteht das Wirkprinzip von C++-Zeigern nicht wirklich.
- [ ] Vielleicht versuchen, [https://github.com/scalameta/scalafmt/issues/337](https://github.com/scalameta/scalafmt/issues/337) zu lösen?
- [ ] Die vom Onkel geteilten Dateien anonym über Resilio Sync teilen.

#### RoadBorder-Reparatur

Festgestellt, dass ich eine falsche Annahme gemacht habe. Die in `rc` aufgezeichneten `lc`- und `rb`-Informationen könnten folgendes enthalten:

1.  Es gibt nur ein `lc`, daher kann nicht angenommen werden, dass es mindestens zwei `lc` gibt.
2.  `rb` auf einer Seite könnte nicht existieren, daher kann nicht angenommen werden, dass `rb` immer existiert.

### 2020-04-21

#### RoadBorder-Reparatur

- Migration der Testfälle abgeschlossen.
- Dune und dessen ReadMe verbessert, sodass es direkt Testdaten ausgeben kann.
  Mit Weiyu gesprochen, Zukunftsperspektiven besprochen. Ich konzentriere mich auf das Kompilierungssystem.

#### POI-Bindung für Gegenfahrbahn

- Binding der nach `multidigitize` verarbeiteten Daten.

### 2020-04-22

#### POI-Bindung für Gegenfahrbahn

- Binding der nach `multidigitize` verarbeiteten Daten.
- Testdaten erstellt.

### 2020-04-23

- POI-Bindung für Gegenfahrbahn abgeschlossen und Debugging beendet [4].

### 2020-04-27

Heute hauptsächlich folgende Punkte:

#### Synchronisierung von mdm proto und mdm spec abgeschlossen

1.  Mit Linnan Teile des mdm spec korrigiert, die falsch formuliert waren.
2.  Einige offene Punkte hinterlassen, die Linnan und ich nicht allein entscheiden konnten.
3.  In der Daily am 2020-04-26 beschlossen, die schwierigsten Änderungen an LaneSplitMerge und Polyline zu verschieben.
4.  Änderungen am proto abgeschlossen.
5.  Änderungen am nexus abgeschlossen.
6.  Änderungen am mdk abgeschlossen.
7.  Nebenbei ein Testdatenproblem behoben (ständige Datenfehler).

#### Bugfixes

Kurz vor dem 430-Release stieg die Bugzahl stark an.

[HDMAPMDK-1111](https://jira.momenta.works/browse/HDMAPMDK-1111) analysiert.

- [ ] Skript zum automatischen Kopieren von Testfällen
- [ ] Apple Reminder exportieren

### 2020-04-28

Habe den halben Tag für die theoretische Führerscheinprüfung (Kategorie 1) gebraucht.

HDMAPMDK-1130 Breitenproblem, drei Probleme:

1.  Spec legt fest, dass bei Spurwechsel keine Lane-Breite vorhanden ist.
2.  Zu lange Intersection-Linien führen zu Split-Line-Problemen.

HDMAPMDK-1121 erneut repariert.

Sehr schlechter Zustand.

### 2020-04-29

#### Bugfix

- HDMAPMDK-1143
  Problem, dass RoadObstacle nicht kompiliert wurde.
- HDMAPMDK-1090

### 2020-05-06

#### Du Valid

- Mill verwenden.
- nexus-osm verwenden.

#### Brainstorming

### 2020-05-08

#### Speicherleck-Problem

- Die direkte Ursache für das Speicherleck war, dass nach dem `new` eines Wildzeigers kein `delete` erfolgte.
- Nach `update current position` rief das Map Kit `prepareGuidanceData` auf, um die nächstgelegenen Guidance-Daten zur aktuellen Position zu finden.
- `prepareGuidanceData` rief `NavInfoProviderImpl::getTrafficLights` & `NavInfoProviderImpl::getCarParks` auf.
- Beispiel `NavInfoProviderImpl::getTrafficLights`: Beim Aufruf wurden Datenzeiger in `NaviEventOnPath` per `new` erzeugt.
- Es erfolgte jedoch kein `delete`.
- Gleiches Problem bei `DestEvent` festgestellt.

Lösung: Kernpunkt ist, keine Wildzeiger zuzulassen. Entscheidung, `NaviEventProvider` zu refactoren.

- Zuerst zwei Felder `traffic_light_events` & `car_park_events` in `NaviInfoProvider` hinzufügen.
- In `NaviInfoGenerator` diese Felder nach einem Route-Update aktualisieren.
- Dann bei jedem `get` basierend auf der aktuellen Fahrzeugposition filtern.
- Daher muss `PathReader::getAttributes` refaktoriert werden, da die vorherige Implementierung nur den Offset relativ zum aktuellen Fahrzeug berücksichtigte. Jetzt wird eine Schnittstelle für den Offset relativ zum Path benötigt.

### 2020-05-09

#### PolyLine-Reparatur und Tests

Das Hauptproblem bei PolyLine bestand darin, dass bei der Generierung möglicherweise doppelte Punkte hinzugefügt wurden, was zu einer Reihe von Problemen bei geometriebezogenen Segmentberechnungen führte:

1.  Vektorberechnung: Zwei doppelte Punkte ergeben einen Nullvektor.
2.  Längenberechnung: Segmentlänge ist 0, was leicht zu NaN-Problemen führt.

Daher wurde bei der Konstruktion von PolyLine eine Prüfung der Punkte hinzugefügt. Wenn doppelte Punkte gefunden werden, wird eine Exception geworfen.

Folgende Probleme wurden entdeckt:

- Problem mit `getEnd` in Jts.
- `Jts LinearLocation` hat ein Normalisierungsproblem.

  ```scala
  val loc1 = new LinearLocation(0, 1, 1.0)
  val loc2 = new LinearLocation(0, 2, 0.0)

  loc1 compareTo loc2
  // die Ausgabe ist -1
  ```

- Bei der Interpolation könnten zwei zu nahe beieinander liegende Punkte ausgewählt werden.

### 2020-05-11

- HDMAPMDK-1122
  Problem mit fehlenden Road-Border-Lines konnte nicht reproduziert werden. Entscheidung, keine weitere Zeit für die Untersuchung der Ursache aufzuwenden.
- Eine halbe Stunde "Metabolic Growth Theory".
- Visitor-Refactoring, damit es Lines mit gleichem Start- und Endpunkt unterstützt.
- Eine Interviewfrage vorbereitet.

### 2020-05-12

- Interview: Beide Kandidaten ungeeignet. Nachgedacht, wie man Kandidaten schnell einschätzen kann. Dauer: 3 Stunden.
- Bugfix: HDMAPMDK-1211 Problem mit falsch gelöschten Borders, bei der letzten Reparatur nicht erfolgreich behoben.
  Habe eine Idee, aber noch nicht fertig geschrieben.
- War zum Sport.

### 2020-05-13

Bugfix: HDMAPMDK-1211 Lösung gefunden.

- Grundursache war eine unangemessene Segmentierung der Produktionslinie.

#### Ursachenanalyse

Es ist zu sehen, dass die Segmentierung erfolgte, bevor der Spurwechsel abgeschlossen war (die Lane-Center-Linie kreuzte noch die Lane-Line), und diese Segmentierung möglicherweise Rp überspannte.

Da die an Lane-Center-Shape-Points haftenden Lane-Border-Beobachtungsinformationen treu der Geometrie folgen und mithilfe von Scan-Line die Lane-Lines auf beiden Seiten aufzeichnen, ohne semantische Filterung, wird die kreuzende Lane-Line an der Position, wo sie die Lane-Center-Linie kreuzt, gleichzeitig in den linken und rechten Lane-Border-Refs aufgezeichnet.

Unter der bestehenden Logik filtert die semantische Filterung der kreuzenden Lane-Lines die zu löschenden Border-Refs basierend auf dem Spurwechseltyp ab.

Die aktuelle Logik versagt bei dieser Art von Segmentierung, was zu diesem Problem führt.

#### Lösung

Der Kernpunkt liegt darin, **den Spurwechselfortschritt der kreuzenden Lane-Line zu finden**. Da diese Segmentierung Rp überspannen kann, sollte die Filterung nicht pro Rp erfolgen.

1.  Zuerst die Lane-Lines mithilfe von Edge Lifting in Paths organisieren (kann für zukünftige Graph-Refactorings berücksichtigt werden): `Seq[LaneCenter]`
2.  Den zu korrigierenden Lane Center und den zu korrigierenden Lane Border finden (hier wird angenommen, dass dieser Lane Center definitiv durch Spurwechsel verursacht wird).
3.  Den Spurwechselfortschritt dieses Lane Centers basierend auf dem LaneCenter-Path berechnen.
4.  Filterung durchführen.

Habe es Ziliang übergeben.

Ein Interviewkandidat nicht bestanden.

### 2020-05-14

HDMAPMDK-1132 ID-Tracing für Lane-Line-Endpunkte von Poles/Signs.

Das Tracing-Problem für Lane-Line-Endpunkte von Poles/Signs ist im Vergleich zum Tracing linearer Objekte sehr einfach, es gibt nur ID-Mapping, kein Offset- und Längen-Mapping.

Dennoch sind einige Punkte zu beachten:

1.  Prozedur.
2.  Das ID-Typing-System ist ein hartnäckiges Problem, das angegangen werden muss.

Im Wesentlichen liegt die Wurzel dieses Problems darin, dass wir bei der ID-Definition durchgängig Long-IDs verwendet haben, während die MDM-Definition Int verwendet, was möglicherweise zu Überlaufproblemen führt.

### 2020-05-15

#### Bugfixes

- HDMAPMDK-1215 abgeschlossen.
- HDMAPMDK-1218 erledigt.

### 2020-05-18

OSM Assembler refaktoriert, verwendete das vorherige OSM serialize. Die Verständlichkeit und Schreibbarkeit des Codes haben sich verbessert.

### 2020-05-19

Einen Bug im OSM Assembler gelöst (eigentlich kein richtiger Bug).

Heute Sprint-Planning-Meeting:
In diesem Sprint gibt es nicht viel zu tun, aber viel nachzudenken. Das ist ein gesunder Zustand.

### 2020-05-20

- [ ] Dokumentation zum aktuellen CI-Status von nexus/mdk und den Anforderungen schreiben.
- [x] HDMAPMDK-1263 Bug verfolgen.
  - Es handelt sich tatsächlich um ein Produktionslinien-Segmentierungsproblem.
- [ ] Meeting mit Yang Chuan über CI vereinbaren.
- [ ] HDMAPMDK-1262
      Nicht fertig geworden.
- [x] Problem mit benutzerdefinierten Geschwindigkeitsbegrenzungen.

### 2020-05-21

#### TODOs

- [x] Qiaobo begrüßen.
- [x] HDMAPMDK-1262
- [x] HDMAPMDK-755

#### Arbeiten

- Morgens im Arbeitsbereich von Yiming online den Hotfix von gestern debuggt. Grund war ein Offset-Problem. Gestern zu hastig geschrieben und überhaupt keine Tests hinzugefügt. Solches Verhalten sollte nicht wieder vorkommen. Dachte, ich hätte viel Zeit gespart, **aber habe tatsächlich mehr Zeit verschwendet**.
- Grund für fehlende Daten bei 1262: MDK lädt keine Lane-Level-Road-Marks (und Road Obstacles).
- Du geholfen, Daten zu kompilieren.

### 2020-05-22

Was habe ich heute gemacht???
Was habe ich eigentlich gemacht???

### 2020-05-25

Heute eine neue Aufgabe erhalten: HDMAPMDK-1249 - Untersuchung einer Methode zur Berechnung der Lane-Aggregation unter Verwendung von Straßengeometrieinformationen. Dadurch sind die Aufgaben für diese Woche etwas mehr geworden. Bisher habe ich noch drei Dinge zu erledigen:

1.  1249
2.  Aktueller Stand, Anforderungen und Lösung für die CI-Pipeline im Team.
3.  Nexus-Graph-Refactoring.

Jede dieser Aufgaben erfordert sorgfältige Planung und ist nicht einfach. Leider kann ich für keine der Aufgaben die Zeit genau abschätzen. Es sind nur die von Weiyu geschätzten Story Points in den Jira-Aufgaben. Eines ist mir klar: **Wenn ich nicht anfange, abzuschätzen und zu reflektieren, werde ich es nie genau schätzen können**. Also von jetzt an genau abschätzen.

Außerdem plane ich, heute mit 1249 anzufangen, da es sich um eine geschäftliche Angelegenheit handelt, die in der Regel dringender ist und Weiyu mehr daran liegt. Was das Refactoring betrifft, wenn ich mich nicht darum kümmere, wird es wahrscheinlich niemand tun (weil es hart ist: Es beeinflusst nicht die Funktionalität, aber die Effizienz, und Effizienz ist am schwierigsten zu messen, selbst ich habe nur eine qualitative Analyse).

### 2020-05-26

Heute viele unerwartete Dinge. Zuerst wurden zwei Bugs im Parking gemeldet, ursprünglich für heute geplant. Wegen dieser Bugs kann die Auslieferung nicht heute erfolgen. Wang Wei hat mit Downstream vereinbart, die Lieferung um zwei Tage auf übermorgen zu verschieben. Daher besteht meine Hauptarbeit in den nächsten zwei Tagen wieder aus Bugfixes. Das lässt mich über die Planung bei Auslieferungen nachdenken. Dann das Problem HDMAPMDK-1290.

Heute erledigte Dinge:

- Folge von HDMAPMDK-1290: Wenn sehr nah an der Stop-Line, ist der gematchte Lane-Offset länger als die Lane-Länge.

  > Habe den ganzen Tag damit verbracht, dies zu untersuchen und eine Lösung zu finden (aktuell 20:56 Uhr). Sehr ineffizient.

  Der Grund ist, dass MDK bei der Längenberechnung die Länge zwischen je zwei Punkten berechnet und dann eine Koordinatentransformation durchführt. Obwohl dies genauer ist, führt es zu starker Unvorhersehbarkeit.

  Schlussendlich eine Art Hack-Lösung: Wenn der berechnete Offset länger als die Länge ist, wird nur die Länge genommen.

- HDMAPMDK-1297 Falsche Parkplatzbindung.
  Obwohl es fast Feierabend ist (21 Uhr), muss ich dieses Problem heute zumindest analysieren!
  Habe es geschafft. Es war ein einfaches Problem.

### 2020-05-27

Heute sollte ich, wenn nichts dazwischenkommt, die CI-Pipeline-Sache abschließen.

Es kam etwas dazwischen - -

Bugs von Yiming erhalten:

1.  Ampelsetzung: Eine Ampel, die im Abbiegebereich hätte gesetzt werden sollen, wurde im vorherigen Partition gesetzt. Bereits behoben (1,5h).
2.  Fehlende Ampelsetzung: Konnte nicht reproduziert werden.
    Update: Nach schwierigem Debugging endlich das Problem gefunden. Beim Kompilieren wurde für die Bindung von rc und Offset eine andere Geometry-Linie verwendet, was zu einem Offset führte, der die Straßenlänge überschritt, daher wurde die Ampel nicht gefunden (2h).

### 2020-05-28

Morgen praktische Führerscheinprüfung (Kategorie 2), heute den ganzen Tag Fahrstunde. Fühlt sich gut an, hoffe, morgen zu bestehen.

Begonnen, den aktuellen Stand und die Anforderungsanalyse der CI-Pipeline zu beschreiben - -

### 2020-05-29

Habe nicht bestanden. Ach, ist das schwer.

Morgens zur Prüfung, nachmittags ein paar Dinge erledigt:

1.  Bei Yiming eine Anomalie angeschaut, stellte sich als zwei Bugs heraus.
2.  Nach dem Townhall die MDK-Python-Binding-Sache synchronisiert.
3.  Mit Shanle und Weiyu nach unten gegangen, um ein Downstream-Problem zu lösen. Schlussendlich eine kurzfristige und eine langfristige Lösung erarbeitet.

Ich stelle fest, dass die Methode zur Problemlösung bei unerwarteten Problemen in der Regel diesem Muster folgen sollte:
Eine kurzfristige Lösung und eine langfristige Lösung. Denn der Wert, den ein Problem offenbart, ist begrenzt und hat eine zeitliche Begrenzung. Daher zielt die kurzfristige Lösung darauf ab, die dringendsten Probleme schnell und präzise zu lösen. Braucht es dann noch eine langfristige Lösung? Im Allgemeinen ja, denn ein spezifisches Problem zeigt eine blinde Stelle in bisherigen Lösungsansätzen auf, die nicht berücksichtigt wurde. Dann gilt es, die Ursache zu analysieren und sie systematisch zu lösen, damit solche Probleme in Zukunft gut gelöst werden können und die ursprüngliche Lösung vollständiger wird. Es gibt auch Fälle, in denen keine langfristige Lösung nötig ist: wenn wir **nach gründlicher Analyse** zu dem Schluss kommen, dass der Aufwand für eine systematische Lösung den Nutzen übersteigt. (Selbst dann wollen wir subjektiv meistens systematisch lösen, welcher Ingenieur möchte nicht systematisch Probleme lösen? Aber das birgt eine Falle: Man könnte sich in die Lösung wichtiger, aber nicht dringender oder sogar unwichtiger und nicht dringender Probleme verstricken und damit wertvolle Zeit verschwenden, die für andere, wertvollere Probleme hätte verwendet werden können.)

4.  Abends weiter an der CI-Pipeline gearbeitet.

### 2020-06-01

Heute morgen gleich zu Yiming gegangen, um ein Problem zu analysieren, den ganzen Vormittag. Ergebnis: Ein bekanntes Problem (fehlende Punkte aufgrund von Interpolation im alten Compiler) verursachte ein anderes Problem: Beim Routenabgleich genau in der Nähe des fehlenden Segments, wodurch der Lane-Offset negativ wurde.

Gearbeitet bis nach 16 Uhr, nach einer ineffizienten und schmerzhaften Nachtschicht (das Gefühl, dass Nachtschichten im aktuellen Zustand fast immer mit Ineffizienz einhergehen).

### 2020-06-02

Erst nachmittags gekommen, um Yimings Fahrt vorzubereiten, einige Bugs behoben, rechtzeitig für Yimings Abendfahrt.

### 2020-06-03

Heute morgen gleich zu Yiming, um das über Nacht entdeckte Problem zu lösen: Ampeln wurden nicht gefunden.

### 2020-06-04

Heute morgen drei Dinge zu erledigen:

1.  Datenbereinigung und Upload der finalen 0605-Daten.
2.  Überprüfung des Breitenanomalie-Problems - Grund: An dieser Position gab es keine Lane.
3.  Überprüfung des Problems mit falschen Interpolationspunkten für Lanes.
4.  Nachkontrolle.

### 2020-06-05

Ein aufregender Tag. HDMAPMDK-1347 und HDMAPMDK-1352 abgeschlossen und ein großes Refactoring durchgeführt.

Eine wertvolle Lektion gelernt: Kurz vor einer Auslieferung keine riesigen Änderungen vornehmen, denn ohne ausreichende QA-Tests kann selbst das brillanteste Refactoring Risiken bergen, und ohne genügend Zeit für Design-Reviews (ich meine für mich selbst, denn manchmal stellt man beim Schreiben fest, dass das Design vielleicht falsch ist – allerdings ist das Erkennen von Designfehlern während der Implementierung ein anderes Problem: zu früh mit der Implementierung begonnen).

Montag, Ergänzung:
Während dieses aufregenden Refactoring-Tages hatte ich kaum eine Pause, nicht einmal Zeit zum Nachdenken, konnte mich nur auf Vertrautheit und Flow verlassen und mit hoher Effizienz Code schreiben. Eigentlich, wenn man das Prinzip ignoriert, kurz vor Auslieferungen keine großen Refactorings zu machen, genieße ich diesen Zustand sehr. Aber alles muss ein Ziel und einen Sinn haben, man kann nicht nur seinem eigenen Vergnügen nachgehen, sonst wird dieses Vergnügen zu einem niederen Instinkt.

### 2020-06-08

Samstag nach Beijing gezogen, um dort zu arbeiten.

Die Rückkehr nach Beijing fühlt sich wirklich etwas ungewohnt an, alles hat sich verändert. Zuerst habe ich keinen festen Arbeitsplatz mehr (Xiuyun hat einen Praktikanten eingestellt, und für die Arbeitserleichterung sitzt ihr Praktikant jetzt dort). Das ist das Unangenehmste an all den Enttäuschungen. Es ist, als wäre ich in der Oberstufe in eine neue Klasse gekommen, auf einem neuen Platz sitze, niemanden kenne und nicht mit ihnen reden will. Die Leute hier wirken vertraut und doch fremd. Ich habe das Gefühl, hier wenige Freunde zu haben, was ich rational für eine Täuschung halte. Aber das Gefühl, nicht mit Menschen kommunizieren zu wollen und eine Ecke zum Verstecken zu suchen, ist real, und ich habe tatsächlich eine Ecke gefunden, neben Yuzhang. Warum will ich nicht mit Menschen kommunizieren? Ich verstehe das Problem immer noch nicht. Vielleicht weil es keinen offiziellen Grund gibt? Auf die Frage, warum ich nach Beijing gekommen bin und wie lange ich bleibe, antworte ich ausweichend: eine Weile, ein oder zwei Monate. Vielleicht zeigt es auch, dass ich im Grunde ein introvertierter Mensch bin, der keine Umstände mag und besonders darauf bedacht ist, in den Augen anderer nicht dumm zu wirken. Je mehr ich schreibe, desto mehr denke ich, dass der zweite Grund überwiegt und unnötig ist. Erstens: Dumm wirken ist besser als wirklich dumm zu sein. Aufrichtig um Rat fragen, auch wenn es unbeholfen ist. Hab keine Angst, sei in jungen Jahren furchtlos. Sei immer furchtlos. Alles ist gut.

Nun zur Arbeit: In dieser Zeit war ich mit der Auslieferung beschäftigt, hauptsächlich dem TLM-Refactoring (Typed Lane Model). Diesmal muss ich das Ziel klar definieren und mich selbst kontrollieren, nicht impulsiv zu refactoren, sondern strategisch und mit Kontrolle über den Fortschritt vorgehen.

Außerdem habe ich meinen Desktop-PC eingerichtet. Der Grund, warum er vorher keine Netzwerkverbindung hatte, war, dass ich das Passwort geändert hatte. Nach einem Stromausfall war die Verbindung komplett verloren. Also musste ich den PC noch einrichten. Diesmal sind die Prioritäten:

1.  Produktivität
2.  Coolness
3.  Aussehen

Heute lange Wang Yins Blog gelesen - - Entgiftung im Gange. Ich war früher immer ein fanatischer Religionsanhänger, der die Essenz der Dinge nicht sehen konnte. Ich dachte immer, etwas sei die ultimative Lösung für alle Probleme, aber solche "ultimativen Lösungen" gibt es selten, meistens ist es nur religiöser Eifer, wie z.B.

-   Vim vs Emacs
-   OOP vs FP
-   Go vs Rust

usw. usw... Als ich zum ersten Mal mit OOP in Berührung kam, dachte ich, OOP sei unschlagbar und könne alle Probleme lösen, aber am Ende schrieb ich nur eine riesige Klasse, die eigentlich unnötig war. Was wirklich nützlich waren, waren die einzelnen Funktionen in dieser Klasse. Später (in den letzten zwei Jahren) kam ich mit FP in Berührung und dachte, FP sei die Silberkugel für alle Probleme. Aber nachdem ich eine Weile in Scala programmiert hatte, stellte ich fest, dass meine Produktivität nicht wirklich gestiegen war, sondern ich mich wegen Grammatik und Immutability ineffizienter fühlte.

### 2020-06-09

Habe etwas meinen Zustand gefunden, Arch installiert. Fühlt sich sogar angenehmer an als Mac?

Habe eine Weile mit Yuzhang Hearthstone Battlegrounds gespielt - -

### 2020-06-10

Heute geplante Aufgaben:

1.  HDMAPMDK-1199 RoadMark als Subklasse, um reichhaltigere Informationen bereitzustellen.
2.  HDMAPMDK-892 Erfahrungstrajektorien bereitstellen.

Falls noch Kapazität da ist, die Release-Dokumentation bearbeiten.

Habe 892 abgeschlossen.

### 2020-06-11

HDMAPMDK-892 - Bereitstellung von Erfahrungstrajektorien reviewed.

Festgestellt, dass MDK noch keine entsprechende Anpassung hat, heute Nachmittag daran gearbeitet.

Anpassung abgeschlossen, bin müde.

Weiter an meinem Arch gebastelt, versucht, die Schritte zur PC-Einrichtung als Teil der Automatisierung zu dokumentieren.

### 2020-06-12

Heutige Aufgabe: HDMAPMDK-1199 abschließen, hatte das Problem vorher vergessen.

Habe es endlich um 20 Uhr geschafft.

### 2020-06-13

Ein sehr entspannter Tag. Nach dem Test-Release nur an meinen Automatisierungsskripten gebastelt.

Zuerst dachte ich an Shell, aber ich mag Shell nicht, also habe ich mit Scheme angefangen. Wirklich cool.

### 2020-06-15

Wow, es ist schon 15 Uhr und ich habe den halben Tag nur herumgesurft, verschiedene Scheme-Websites besucht usw. Das darf nicht so weitergehen.

Heute muss HDMAPMDK-1378 erledigt werden, also das, was wir immer vermeiden wollten: die sogenannte Lane-Mark-Direction innerhalb von Kreuzungen hinzufügen. Aber Kreuzungen haben keine Lane-Marks, wie kann es da eine Lane-Mark-Direction geben?

Es war sehr mühsam, mit vielen Rückschlägen, bis spät in die Nacht.

### 2020-06-16

Heute nach dem Kommen nur Reviews gemacht, es gab viel zu ändern, dann begann ich wieder, etwas zu prokrastinieren, habe es mit Mühe geschafft, und dann hat Kuange noch ein paar Bugs gefunden.

Nachmittags erfuhr ich, dass Xiaoge geht. Ich war lange schockiert.

Abends an Scheme gebastelt, das Kompilieren und Referenzieren eigener Libraries hinbekommen.

### 2020-06-17

Heutige Hauptarbeit: Abschlussarbeiten des letzten Sprints, also Bugfixes.

### 2020-06-18

Bis heute haben wir endlich die Dinge des letzten Sprints abgeschlossen.

Ich fühle mich insgesamt sehr schlecht, weil die Bedeutung der getanen Arbeit nicht klar ist, eigentlich denke ich, dass sie fast bedeutungslos ist.

Wie definiere ich hier Bedeutung?

Die Bedeutung der aktuellen Arbeit für mich ist, in absteigender Priorität:

1.  Die Fähigkeit, Probleme zu identifizieren, wertvolle, sinnvolle Probleme zu erkennen.
2.  Die Fähigkeit aufbauen, Probleme zu modellieren, um in Zukunft mehr Probleme verschiedener Art lösen zu können.
3.  Probleme modellieren, um Lösungen zu ermöglichen, die mit einmaligem Aufwand eine ganze Klasse von Problemen lösen, die durch das Modell beschrieben werden.
4.  Durch meine Bemühungen konkrete, sinnvolle Probleme lösen. Dabei ist das einmalige Lösen eines einzelnen Problems weniger bedeutend als der Einsatz von Aufwand, um mehrere Probleme dieser Klasse zu lösen.
5.  Freude bewahren, die Zufriedenheit der Problemlösung, die intrinsische Interessantheit des Problems selbst.
6.  Kommunikation und Beziehungen zu Menschen.
7.  Gehalt (das ist eine Absicherung, nicht unwichtig, aber der Rest sollte darauf aufbauen).

Das umfasst wahrscheinlich nicht alle meine Arbeitsmotive, aber es spiegelt zumindest einen Teil der Realität wider.

Der Grund für meine heutige Niedergeschlagenheit ist meiner Meinung nach hauptsächlich der Verlust an Interessantheit. Erstens ist die Bedeutung des Problems selbst für mich nicht klar, was die Motivation mindert. Zweitens ist die Modellierung dieser Art von Problemen nicht präzise genug, was dazu führt, dass die Lösungsansätze nicht alle Probleme lösen können (natürlich gibt es selten Modelle, die alle Probleme lösen, da Modelle per Definition Vereinfachungen und Abstraktionen von Problemen sind; hier sprechen wir vom Lösen akzeptabler Probleme), was zu Wiederholungen führt, konkret: die vielen Bugs, die QA-Mitarbeiter melden. Obwohl einige auf unzureichendes Verständnis der Anforderungen oder sogar Testprobleme zurückzuführen sind, nimmt die Analyse der Probleme selbst den zeitaufwändigsten Teil der Problemlösung ein.

Manchmal führt unzureichendes Problemverständnis zu nicht-fundamentalen Lösungen, was dazu führt, dass man Zeit mit nutzlosen Dingen verbringt, und die Punkte 3, 4 und 5 der oben genannten Bedeutung werden nicht erfüllt, was mich niedergeschlagen macht.

Ein weiterer zu bedenkender Punkt ist, dass ich bisher nur Probleme des letzten Sprints gelöst habe und noch gar nicht mit den Aufgaben dieses Sprints begonnen habe. Das wird die Zeit dieses Sprints verkürzen und möglicherweise auch nachfolgende Sprints beeinflussen. Das ist ein sehr unerwünschter Teufelskreis, der, wenn man noch weiter denkt, sogar zwischenmenschliche Beziehungen beeinflussen könnte, was noch unerwünschter ist.

Daher sollte ich ab morgen, bevor ich etwas angehe, versuchen, alle Aspekte zu berücksichtigen und dann erst das Problem lösen.

Ein Blick auf die letzten zwei Wochen zeigt, dass die Arbeitsfortschritte fast völlig auf der Stelle traten. An dem Montag, als ich nach Beijing kam, am 8. Juni, sagte ich bereits: `Dann zur Arbeit: In dieser Zeit war ich mit der Auslieferung beschäftigt, hauptsächlich dem TLM-Refactoring (Typed Lane Model). Diesmal muss ich das Ziel klar definieren und mich selbst kontrollieren, nicht impulsiv zu refactoren, sondern strategisch und mit Kontrolle über den Fortschritt v