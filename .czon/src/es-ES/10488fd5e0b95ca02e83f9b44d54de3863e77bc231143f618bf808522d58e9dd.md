---
"title": "Notas sobre el artículo de MapReduce"
"summary": "Este texto es un resumen del artículo sobre MapReduce, que analiza en detalle sus orígenes, lógica de ejecución, estructuras de datos, mecanismos de tolerancia a fallos y optimización de rendimiento. El artículo señala que MapReduce es un modelo abstracto propuesto para abordar los desafíos del cálculo paralelo, la distribución de datos y la tolerancia a fallos en el procesamiento de datos a gran escala, inspirándose en los conceptos de Map y Reduce de la programación funcional. La implementación incluye aspectos clave como la división de tareas, la planificación por parte del Master, el almacenamiento de resultados intermedios y las tareas de respaldo. En cuanto a la tolerancia a fallos, se garantiza la fiabilidad mediante la supervisión del Master y la reprogramación de tareas. Las pruebas de rendimiento demuestran una alta eficiencia en tareas como grep y ordenación. En resumen, MapReduce proporciona un modelo de programación sencillo pero potente para la computación distribuida."
"tags":
  - "MapReduce"
  - "Sistemas distribuidos"
  - "Notas de artículo"
  - "Tolerancia a fallos"
  - "Optimización de rendimiento"
  - "Procesamiento de datos"
"date": "2019-11-25"
---

## Orígenes

Los autores, en su trabajo con cantidades masivas de datos, escribieron cientos de programas de procesamiento de datos que presentaban algunas características:

1.  La lógica de negocio era simple.
2.  El volumen de datos era enorme, por lo que requerían computación distribuida en cientos de máquinas.

Esto planteaba varios desafíos:

1.  Cómo paralelizar la computación.
2.  Cómo distribuir los datos.
3.  Cómo manejar la tolerancia a fallos.

Una gran parte del código de estos programas de procesamiento de datos se dedicaba a resolver problemas similares en lugar de implementar la lógica de negocio.

Por lo tanto, se propuso un nuevo modelo de abstracción que, tomando prestados dos conceptos de Lisp y otros lenguajes funcionales, permitía a los ingenieros centrarse en la lógica de negocio mientras se ocultaban los requisitos no funcionales mencionados. Este modelo es MapReduce.

## Implementación

### Lógica de ejecución

1.  Los datos de entrada se dividen en M fragmentos asignados a M trabajadores Map.
2.  El Master actúa como canal de datos realizando la planificación.
3.  Las tareas Map invocan la función Map del usuario y almacenan los resultados en la memoria local.
4.  Periódicamente, se vuelcan a disco y se dividen en R partes para preparar la asignación a R trabajadores Reduce.
5.  Los trabajadores Reduce, una vez asignadas las tareas por el Master, leen los datos mediante RPC, los ordenan en disco tras la lectura.
6.  Los trabajadores Reduce iteran sobre los datos ordenados invocando la función Reduce del usuario, realizando un cálculo incremental.
7.  Una vez completado el cálculo, finaliza el proceso y se retorna a la lógica del código del usuario.

Se puede observar que el método de partición es crucial, idealmente para evitar operaciones de shuffling innecesarias.

### Estructuras de datos

-   Se almacena el estado (inactivo/en progreso/completado) para cada tarea map/reduce.
-   Para cada tarea map completada, se almacena la ubicación y el tamaño de los archivos intermedios, y se notifica a los trabajadores Reduce.

### Tolerancia a fallos

-   Básicamente, el Master no falla, aunque también se podría implementar un almacenamiento periódico del estado para recuperarse en caso de fallo.
-   El Master hace ping periódicamente a los trabajadores. Si no responde, se considera al trabajador como fallido.
    -   Para las tareas Map, se reinician y reprograman todas, independientemente de si estaban completadas o no. Esto se debe a que los resultados de Map se almacenan localmente en el trabajador, por lo que si este falla, los resultados son inaccesibles.
    -   Para las tareas Reduce, solo se reprograman las no completadas. Esto se debe a que los resultados de Reduce se almacenan en un sistema de archivos de acceso global.
    -   Tras reprogramar una tarea Map, se notifica a todos los trabajadores Reduce, que procederán a obtener los datos desde la nueva ubicación.

### Tareas de respaldo (Backup Tasks)

Las últimas tareas en ejecución pueden ralentizar significativamente el progreso de MapReduce, posiblemente debido a la presencia de "rezagados" (stragglers) que, por diversas razones, se ejecutan muy lentamente. En este caso, el Master inicia tareas de respaldo para las últimas tareas en ejecución. Esto incrementa el uso de recursos en unos pocos puntos porcentuales, pero puede reducir masivamente el tiempo total de ejecución.

## Mejoras

### Partición

Dado que los archivos de salida están distribuidos, es posible agrupar los resultados de claves relacionadas mediante una función de partición proporcionada por el usuario.

### Depuración local

Se puede ejecutar localmente.

## Rendimiento

Se realizaron pruebas en dos grandes clústeres, uno para ordenación y otro para coincidencia de patrones.

### Grep

Búsqueda de un patrón en 10^10 archivos de 100 bytes. 1500 máquinas tardaron 150 segundos, de los cuales un minuto se dedicó a distribuir el programa. Muy eficiente.

### Ordenación

10^10 archivos de 100 bytes.

## Conclusión

Con total confianza.