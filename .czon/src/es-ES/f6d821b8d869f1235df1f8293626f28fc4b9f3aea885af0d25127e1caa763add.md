---
"title": "Segunda exploración de la concurrencia (Actor)"
"summary": "El artículo comienza discutiendo cómo en programación concurrente, cuando múltiples trabajadores necesitan operar de forma asincrónica y con roles específicos, compartir una única cola de mensajes provoca problemas de direccionamiento, recepción errónea y sincronización.\
  El autor analiza paso a paso cómo una cola de mensajes compartida resulta ineficiente y propensa a errores en este escenario. Luego introduce el modelo Actor como solución definitiva, asignando a cada trabajador una cola de mensajes independiente (buzón) que logra aislamiento total y comunicación asincrónica.\
  El artículo explica en detalle los conceptos del modelo Actor, incluyendo ejecución paralela, paso de mensajes y mecanismos de direccionamiento, y proporciona un ejemplo de implementación en Python con hilos, mostrando cómo construir un Actor básico (BaseWorker).\
  Finalmente, el autor resume las ventajas del modelo Actor en programación concurrente, destacando su valor en el pensamiento abstracto y la práctica de 'alta cohesión, bajo acoplamiento'."
"tags":
  - "python"
  - "concurrencia"
  - "Modelo Actor"
  - "cola de mensajes"
  - "programación asincrónica"
  - "multihilo"
  - "modelo de programación"
"date": "2017-05-19"
---

---
title: Segunda exploración de la concurrencia (Actor)
date: 2017-05-19
taxonomies:
  tags:
    - python
    - concurrencia
---

[En la entrega anterior](http://0xc1.space/2017/05/06/初探并发/) hablamos sobre el uso de colas de mensajes para pasar mensajes entre hilos (o procesos) y así lograr comunicación entre ellos.

<!--more-->

## La cola de mensajes compartida

Esto se basa en la premisa de que **la concurrencia solo sirve para mejorar la tasa de procesamiento del sistema**. Bajo esta suposición, cada trabajador realiza el mismo trabajo, por lo que pueden compartir una cola de mensajes; no importa quién reciba la siguiente instrucción.

### ¿Y si no somos iguales?

¿Qué pasa si necesitamos implementar un sistema donde cada trabajador tenga un rol específico y opere de forma asincrónica (por ejemplo, nuestro teléfono IP)? Supongamos que seguimos usando el método anterior, donde todos los trabajadores comparten una cola de mensajes. En este caso surge un problema: los mensajes no pueden enviarse a un trabajador específico.

¿Cómo solucionar esto? Una solución simple y directa es agregar una etiqueta a cada mensaje para identificar a quién va dirigido:

```python
queue = Queue([('Send_to_worker_A', 'do_something1'),
               ('Send_to_worker_B', 'do_something2'),
               ('Send_to_worker_B', 'do_something3'),
               ('Send_to_worker_C', 'do_something4'),
               ('Send_to_worker_A', 'do_something5')])
```

Parece que el problema se resuelve fácilmente, ¿verdad? Pero hemos introducido un nuevo problema.

### Si accidentalmente abro una carta destinada a otro

Si un mensaje destinado al trabajador A es recibido por el trabajador B, este mensaje no le sirve de nada, mientras que el trabajador A, que debería haberlo recibido, no lo obtiene, por lo que el mensaje se pierde. Se desperdicia el tiempo del trabajador B, se consume el tiempo del trabajador A, e incluso podría llevar a que todo el sistema caiga en algún error extraño debido a un salto en la secuencia.

¿Cómo solucionar este problema? Intuitivamente, agregar la siguiente estrategia a cada trabajador parece resolverlo: si recibe un mensaje destinado a otro, lo vuelve a poner en la cola de mensajes.

```python
class Worker_B:
    
    def run(self):
        while True:
            if not self.queue.empty():
                data = self.queue.get()
                if data['to_whom'] == 'worker_B':
                    do_something_with_data
                else:
                    self.queue.put(data)
```

Parece que con parches hemos solucionado el problema... pero en realidad hemos introducido un nuevo problema.

### Esto parece un callejón sin salida

Primero, una cola de mensajes es una cola, lo que significa FIFO (primero en entrar, primero en salir). Incluso si introducimos una cola de mensajes con prioridades, esto no cambia en esencia. Así, un mensaje que debería entregarse primero al trabajador A, después de ser manipulado por el trabajador B, se convierte en el último en entregarse al trabajador A en la cola actual, lo que podría llevar al sistema a un error extraño.

Segundo, incluso si logramos que los mensajes mal dirigidos se vuelvan a insertar al principio de la cola, si no introducimos un mecanismo de bloqueo para que la operación de `recibir-revisar-devolver` del trabajador B que recibió el mensaje por error sea una operación atómica, entonces mientras el trabajador B realiza la operación de devolución, otros trabajadores podrían estar continuando con la operación de recepción de mensajes, lo que aún podría causar grandes problemas de sincronización. Introducir un mecanismo de bloqueo puede resolver el problema lógico, pero haría que en cada ciclo de sondeo solo un trabajador pueda trabajar realmente, mientras que otros trabajadores que reciben mensajes erróneos y ejecutan la operación `recibir-revisar-devolver` desperdician su tiempo de CPU, **lo que es ineficiente**.

Por lo tanto, parece que para un sistema que introduce concurrencia para trabajar de forma asincrónica, que cada trabajador comparta la misma cola de mensajes no es una buena solución.

La solución radical a este problema es crear una cola de mensajes (buzón) específica para cada grupo de trabajadores que realizan la misma tarea, o incluso asignar a cada trabajador su propia cola de mensajes, renunciando por completo a la capacidad de memoria compartida entre hilos. Este último método es el protagonista de hoy: **el modelo Actor (o patrón Actor)**.

## El modelo Actor

Primero, veamos la definición y conceptos del modelo Actor según Wikipedia:

### Conceptos

En ciencias de la computación, el modelo Actor es un modelo de computación concurrente. Un "actor" es una abstracción en programación, considerado la unidad básica de computación concurrente: cuando un actor recibe un mensaje, puede tomar decisiones, crear más actores, enviar más mensajes y decidir cómo responder a los siguientes mensajes. El modelo Actor fue propuesto en 1973 en un artículo de Carl Hewitt, Peter Bishop y Richard Steiger.

La filosofía que promueve el modelo Actor es "todo es un actor", similar a la programación orientada a objetos donde "todo es un objeto", pero la programación orientada a objetos suele ser secuencial, mientras que el modelo Actor es paralelo. Un actor es una entidad computacional que responde a los mensajes recibidos y, en paralelo:

- Envía un número limitado de mensajes a otros actores;
- Crea un número limitado de nuevos actores;
- Especifica el comportamiento al recibir el siguiente mensaje.

Las operaciones anteriores no asumen ejecución secuencial, por lo que pueden realizarse en paralelo. La desvinculación entre el remitente y los mensajes ya enviados es la ventaja fundamental del modelo Actor. Esto permite comunicación asincrónica y satisface las estructuras de control de paso de mensajes. Los destinatarios de los mensajes se distinguen por direcciones, a veces llamadas "direcciones de correo". Por lo tanto, un actor solo puede comunicarse con actores cuyas direcciones posee. Puede obtener direcciones a través de la información recibida o de las direcciones de los actores que crea. Las características del modelo Actor son: computación paralela dentro o entre actores, los actores pueden crearse dinámicamente, las direcciones de los actores se incluyen en los mensajes, la interacción solo se realiza a través de comunicación asincrónica directa de mensajes, y no se restringe el orden de llegada de los mensajes.

### Implementación

Los actores son lo suficientemente simples, nacidos para la concurrencia, y tienen una encapsulación lo suficientemente buena para aislar cambios (por ejemplo, no importa si son multihilo o multiproceso).

Veamos una implementación típica de un Actor en Python con hilos:

```python

from queue import Queue
from threading import Thread, Event


class WorkerExit(Exception):
    # Excepción para finalizar la tarea
    pass


class BaseWorker(object):
	# Actor
    def __init__(self):
        self._mailbox = Queue()
        super(BaseWorker, self).__init__()

    def send(self, msg):
        self._mailbox.put(msg)

    def recv(self):
        msg = self._mailbox.get()
        if msg is WorkerExit:
            raise WorkerExit()
        return msg

    def close(self):
        self.send(WorkerExit)

    def start(self):
        self._terminated = Event()
        t = Thread(target=self._bootstrap)

        t.daemon = True
        t.start()

    def _bootstrap(self):
        try:
            self.run()
        except WorkerExit:
            pass
        finally:
            self._terminated.set()

    def join(self):
        self._terminated.wait()

    def run(self):
        raise NotImplementedError
```

En pocas palabras, este Actor (lo llamé BaseWorker, y en proyectos reales se usa como clase base) mantiene dos estructuras de datos: un `Queue` como buzón y un `Event` como mecanismo para bloquear el hilo principal.

Aquí, la operación central como interfaz externa es solo el método `send()`. Nótese que **no restringimos el tipo de mensaje que se puede pasar**, lo que brinda una flexibilidad increíble.

Dentro del Actor, usamos un hilo para ejecutar el método `run()` combinado con el método `recv()` para realizar el trabajo específico asignado. Vale la pena mencionar que establecemos una señal centinela `WorkerExit` para detener la tarea. Nótese que `WorkerExit` funciona como una excepción que se lanza cuando se identifica, y en el manejo de excepciones podríamos hacer incluso más cosas, aunque aquí solo detenemos la ejecución del hilo cuando capturamos esta excepción. La implementación de este manejo de excepciones depende del método `_bootstrap()` que envuelve a `run()`.

Bajo la filosofía del modelo Actor, podemos extender este ejemplo simple para ir más allá.

## Resumen

La programación concurrente requiere una forma de pensar más abstracta de lo habitual, y también puede ser una buena práctica del principio de "alta cohesión, bajo acoplamiento".

En mi exploración de este campo completamente nuevo para mí, el modelo Actor ha sido una luz guía que me ha permitido entrar de lleno, por eso lo comparto aquí. :)