---
"title": "Un Demo de RBAC: Por Aiur"
"summary": "Este artículo detalla el proyecto demo de RBAC (Control de Acceso Basado en Roles) desarrollado por el autor, titulado 'Por Aiur', que simula un escenario de juego simplificado inspirado en StarCraft. El artículo explica el proceso de análisis y diseño del proyecto, incluyendo la definición de sujetos, roles, recursos y permisos, así como la configuración de las relaciones SA (Sujeto-Rol) y PA (Rol-Permiso). La parte de implementación utiliza el framework Flask de Python para construir un servicio RESTful, gestionando las relaciones RBAC a través de archivos en lugar de una base de datos, y proporciona ejemplos de código específicos y explicaciones de la lógica de negocio. Finalmente, el artículo resume el valor de la aplicación de RBAC en sistemas y los aprendizajes obtenidos por el autor durante la práctica."
"tags":
  - "Diseño y Análisis de Sistemas"
  - "RESTful"
  - "RBAC"
  - "Python"
  - "Flask"
  - "StarCraft"
  - "Demo"
  - "Control de Acceso"
"date": "2017-05-11"
---

---
title: Un Demo de RBAC: Por Aiur
date: 2017-05-11
taxonomies:
  tags:
    - Diseño y Análisis de Sistemas
    - RESTful
    - RBAC
---

Basándome en la comprensión de RBAC del artículo anterior, y debido a los requisitos de una tarea, voy a crear un demo simple como práctica de RBAC.

No tengo la intención de hacer el demo excesivamente grande. Mi objetivo es ilustrar el concepto, por lo que sigue siendo "pequeño pero completo".

Entonces, ¿cuál es el objetivo de este demo? ¿Qué puede hacer?

<!--more-->

## Análisis y Diseño

Para hacerlo interesante y reflejar adecuadamente el problema, en mi demo simularé un escenario muy simplificado y milagrosamente subjetivo de una partida de StarCraft, desde la perspectiva de un jugador Protoss.

Un buen demo necesita un buen nombre, por lo que este demo se llama: **¡Por Aiur!** (Aiur es el planeta natal de los Protoss. Cada Zealot dice esta frase apasionada al ser teletransportado al campo de batalla: "¡Lucho por Aiur!")

En **Por Aiur**, debes liderar a tu equipo para producir suficientes guerreros Zealot, destruir al Destructor Amon y salvar el universo. Si no tienes suficientes Zealots, fracasarás, las estrellas susurrarán y toda la existencia se desvanecerá.

Todo esto se refleja en un servicio RESTful escrito con el framework Flask de Python.

> En realidad, en un escenario real, cada sujeto excepto el jugador podría ser creado, por lo que podrían considerarse recursos. Para reflejar RBAC, les he añadido las siguientes restricciones:
>
> - Los pocos sujetos proporcionados por este demo son únicos y existen permanentemente, como si fueran irrepetibles, eliminando así la posibilidad de que cualquier sujeto pueda ser creado recursivamente (por ejemplo: un Sonda puede producir un Nexo, y un Nexo puede producir un Sonda).
> - En realidad, el Portal de Teletransporte necesita energía de un Pilar de Cristal para funcionar, pero aquí no se refleja. Lo explico asumiendo que nuestro Portal de Teletransporte recibe energía de la Lanza de Adun, la legendaria nave madre Protoss en órbita síncrona, considerando así los Pilares de Cristal solo como recursos que proporcionan límite de población.

Esta partida tiene los siguientes objetos:

### Sujetos (Subject)

- Jugador (tú) thrimbda
- Sonda (unidad de trabajo básica, puede recolectar recursos y construir edificios) probe
- Portal de Teletransporte (produce Zealots, una unidad de combate) gateway

#### Roles (Role)

- Archon (comandante supremo, asigna todos los recursos) archon
- Recolector de Cristales (solo las Sondas pueden asumir este rol) crystal_collector
- Centro de Teletransporte para Zealots (baliza que soporta el plegado de guerreros Protoss) portal
- Constructor de Pilares (con Pilares, podemos tener suficiente límite de población para teletransportar Zealots) pylon_transporter

### Recursos (Resource)

- Cristales sin recolectar (usados para construir Pilares y teletransportar Zealots, valor inicial desconocido)
- Cristales recolectados (usados para construir Pilares y teletransportar Zealots, valor inicial 0)
- Capacidad de Población (proporciona energía para teletransportar, es decir, nuestra "población", valor inicial 0)
- Zealots (unidades de combate, los guerreros con los que salvarás el universo, valor inicial 0)

### Permisos (Permission)

> Dado que cada operación sobre un recurso es un permiso, aquí no listamos las operaciones por separado, sino que damos directamente los permisos y sus descripciones.

- Recolectar Cristales (máximo 1000 unidades por vez)
- Observar Cristales sin recolectar (ver el total)
- Reporte de Estado (informar la cantidad actual de recursos que posees)
- Explorar la fuerza de Amon (calcular la cantidad de Zealots necesarios)
- Construir Pilar de Cristal (cada Pilar proporciona 10 unidades de capacidad de población y cuesta 100 cristales)
- Producir Zealots (cada Zealot consume 2 unidades de capacidad de población y 100 cristales)
- Atacar a Amon (¡Victoria o muerte!)

### SA

> La relación muchos-a-muchos entre Sujeto-Rol y Rol-Permiso se representa usando la estructura de datos de tupla múltiple de Python, y así es también en la implementación. Por lo tanto, esta aplicación no usa una base de datos.

```python
subject_role = (('thrimbda', 'archon'),
                ('probe', 'crystal_collector'),
                ('probe', 'pylon_transporter'),
                ('gateway', 'portal'))
```

### PA

```python
role_permission = (('archon', 'get_status'),
                   ('archon', 'for_aiur'),
                   ('archon', 'scout'),
                   ('crystal_collector', 'get_crystal'),
                   ('crystal_collector', 'crystal_status'),
                   ('pylon_transporter', 'get_status'),
                   ('pylon_transporter', 'transport_pylon'),
                   ('portal', 'transport_zealot'),
                   ('portal', 'get_status'))
```

## Implementación

[URL del Repositorio](https://github.com/Thrimbda/my-life-for-Aiur)

[Despliegue en línea](https://my-life-for-aiur.herokuapp.com/) (lento)

### Resumen

En resumen, utilicé el framework Flask de Python para escribir un servicio con estilo RESTful. La aplicación completa no involucra una parte frontal (frontend), por lo que tampoco existen problemas de seguridad como eludir el frontend.

Una característica de este demo es que no utiliza una base de datos. RBAC no obliga a usar una base de datos, y aunque usarla en RBAC es intuitivo y natural, en **Por Aiur** no usamos una base de datos, sino que representamos la relación `sujeto-rol-permiso` de RBAC usando archivos. Las bases de datos en sí mismas se desarrollaron sobre sistemas de archivos. Aquí usamos archivos porque el sistema es lo suficientemente simple, para reducir aún más la complejidad del sistema con el fin de ilustrar el concepto. La forma específica del archivo se puede ver en las descripciones de las relaciones SA y PA anteriores.

### Sobre RESTful

Mencionemos brevemente RESTful (**Re**presentational **S**tate **T**ransfer)

Como su nombre indica, Transferencia de Estado Representacional (de recursos).

En un servicio web, los servicios proporcionados son los recursos del sistema, representados en forma de URI, y la forma del servicio son las operaciones sobre los recursos (cambio de estado), representadas por verbos HTTP. Varios conceptos aquí se corresponden bien con los recursos y operaciones en RBAC, por lo que lo que debo hacer es aplicar la gestión de permisos de RBAC a las operaciones sobre recursos en REST.

### Los distintos objetos en RBAC

Se puede ver que en estos dos archivos de configuración, además de SA y PA, podemos derivar implícitamente S, R, P:

```python
# Obtener las listas S y R a partir de la tupla subject_role anterior
subjects = list(set([item[0] for item in subject_role]))
roles = list(set([item[1] for item in subject_role]))
```

Y SE (Sesión) puede corresponderse bien con la sesión en una aplicación web, como un objeto temporal para un sujeto durante un inicio de sesión:

```python
# El sujeto usa esta API para iniciar sesión en el sistema de gestión táctica de la Lanza de Adun. Aquí, session es un objeto global de Flask; sus detalles de implementación no se repetirán.
class SpearOfAdun(Resource):
    
    def post(self):
        args = self.putparser.parse_args()
        if args['subject'] is not None:
            abortInvalideSubject(args['subject'])
        if args['role'] is not None:
            abortInvalideRole(args['role'])
        checkRole(args['subject'], args['role'], subject_role)
        session['subject'] = args['subject']
        session['role'] = args['role']
        return {'message': 'login as %s using %s' % (session['subject'], session['role'])}, 201
```

Dado que el modelado Sujeto-Rol tiene como objetivo final aislar y asignar permisos, permitiendo que los recursos del sistema sean utilizados y protegidos adecuadamente.

En **Por Aiur**, trato los permisos como atributos internos de la API web, por ejemplo:

```python
# API para teletransportar Zealots
class Zealot(Resource):

    def put(self):
        permission = 'transport_zealot' # Permiso
        abortIfSubjectUnauthenticated(session) # Verificación de inicio de sesión
        checkPermission(session['role'], permission, role_permission) # Verificar si el sujeto en este rol puede solicitar este permiso
        args = self.putparser.parse_args()
        amount = nexus.transport(args['amount'])
        return {'message': 'transport %d zealot warriors, En Taro Tassadar!' % amount}, 200
```

Y en las dos APIs usadas como ejemplo anteriormente, cada clase existe como un recurso en el sistema, y los métodos HTTP proporcionados son operaciones sobre esos recursos.

**Hasta aquí, todos los tipos de objetos en RBAC están presentes.**

### Lógica de Negocio

Dado que **Por Aiur** es una API de juego de estrategia en tiempo real real y jugable en línea, es necesario explicar su lógica de negocio:

El objetivo del jugador es: **Recolectar recursos, construir una base, y luego crear un ejército que aterrorice a tus enemigos para derrotar al Oscuro Amon.**

La única condición para derrotar a Amon es tener una cantidad suficiente de Zealots, y esta cantidad es un entero aleatorio generado por el sistema entre 20 y 100. Simultáneamente, el sistema generará exactamente la cantidad de cristales sin recolectar necesarios para que derrotes a Amon basándose en este dato.

**¿Por qué exactamente suficiente?**

Dado que teletransportar Zealots requiere una cantidad suficiente de energía de cristal y cristales minerales, y los Pilares de Cristal que proporcionan energía también consumen cristales para ser producidos. Por lo tanto, si construyes demasiados Pilares, aunque la energía de cristal sea suficiente, **perderás esta batalla que decide el destino del universo por no tener suficientes cristales para teletransportar Zealots**.

Toda esta lógica es proporcionada por un objeto cuyo ciclo de vida abarca toda la campaña. Para evitar problemas, he añadido un bloqueo de hilo (thread lock) para asegurar que cada operación sea atómica.

```python
# Dado que es el núcleo de todo el juego, lo llamo el Nexo - Nexus
import random
from threading import Lock


class Nexus(object):
    _lock = Lock()
    crestalInControl = None
    crestalRemain = None
    populationCap = None
    zealot = None
    status = {}
    _amond = None

    def __init__(self):
        # Inicializar el objeto
        self._amond = random.randint(20, 100)
        self.crestalRemain = self._amond * 100 + (self._amond // 5 + 1) * 100
        self.crestalInControl = 0
        self.populationCap = 0
        self.zealot = 0

    def collect(self, amount=1000):
        # Recolectar cristales minerales
        with self._lock:
            amount = min(amount, self.crestalRemain)
            self.crestalRemain -= amount
            self.crestalInControl += amount
            return amount

    def transport(self, amount=5):
        # Teletransportar Zealots
        with self._lock:
            capacity = self.populationCap / 2
            available = self.crestalInControl / 100
            amount = min(amount, capacity, available)
            self.zealot += amount
            self.crestalInControl -= amount * 100
            self.populationCap -= amount * 2
            return amount

    def build(self, amount=1):
        # Construir Pilar de Cristal
        with self._lock:
            available = self.crestalInControl / 100
            amount = min(amount, available)
            self.populationCap += amount * 10
            self.crestalInControl -= amount * 100
            return amount

    def forAiur(self):
        # ¡Luchar por Aiur!
        with self._lock:
            if self.zealot >= self._amond:
                return True
            else:
                return False

    def getStatus(self, role):
        # Obtener estado
        if role == 'archon':
            return {
                'crestalInControl': self.crestalInControl,
                'crestalRemain': self.crestalRemain,
                'populationCap': self.populationCap,
                'zealot': self.zealot
            }
        elif role == 'pylon_transporter':
            return {
                'crestalInControl': self.crestalInControl,
                'populationCap': self.populationCap
            }
        elif role == 'portal':
            return {
                'crestalInControl': self.crestalInControl,
                'populationCap': self.populationCap,
                'zealot': self.zealot
            }
        else:
            return {}


nexus = Nexus() # Instanciar el objeto
```

## Conclusión

En realidad, cada partida de StarCraft II es un modelo DAC típico: el jugador lo domina todo, y todas las operaciones en el juego pueden verse como la transformación de estado de dos recursos básicos, cristales minerales y gas vespene (que he simplificado aquí), en los recursos que el jugador necesita (unidades de producción, unidades de combate) para consumir los recursos del enemigo y ganar la partida. Esto muestra que la idea de los servicios RESTful es muy universal.

En este pequeño juego **Por Aiur**, solidifiqué varios roles, construyendo un modelo RBAC.

En esta práctica, comprendí la aplicación de RBAC en un sistema, y además aprendí más sobre Flask, este excelente framework, entendiendo más profundamente el pensamiento RESTful, obteniendo muchos aprendizajes.