---
"title": "Análisis Práctico del Patrón Observador"
"summary": "Este artículo introduce primero los conceptos básicos del patrón Observador, incluyendo su definición, alias, motivación y participantes, y señala que este patrón se utiliza comúnmente para manejar dependencias entre objetos y sincronización de estados. A través de un ejemplo de Action y ActionListener en J2EE, el artículo muestra la aplicación práctica del patrón Observador para reducir el acoplamiento entre Model y View. En el ejemplo, JTextField actúa como objetivo concreto, y múltiples ActionListener como observadores concretos; cuando cambia el estado del campo de texto, se notifica automáticamente a los observadores para ejecutar las operaciones correspondientes. El artículo enfatiza que, en comparación con las llamadas a funciones ordinarias y las funciones de retorno de llamada, el patrón Observador puede mantener de manera más efectiva la consistencia entre objetos y mejorar la reutilización del código."
"tags":
  - "Patrones de Diseño"
  - "Patrón Observador"
  - "J2EE"
  - "Action"
  - "ActionListener"
  - "Análisis y Diseño de Sistemas"
  - "MVC"
  - "Grado de Acoplamiento"
"date": "2017-04-10"
---

---
title: Análisis Práctico del Patrón Observador
date: 2017-04-10
taxonomies:
  tags:
    - Patrones de Diseño
    - Análisis y Diseño de Sistemas
---

> Generalmente, en el análisis y diseño orientado a objetos existen tres mecanismos para el manejo de eventos: además de las llamadas a funciones ordinarias, se utilizan frecuentemente funciones de retorno de llamada, y J2EE proporciona un mecanismo de manejo de eventos basado en escuchas. Consulta la documentación, analiza el mecanismo de Action y ActionListener, y completa un ejemplo de análisis.

Primero, comprendamos el patrón Observador.

<!--more-->

## Patrón Observador (Observer Pattern)

### Observadores en el mundo real

El patrón Observador también se conoce como patrón Publicar-Suscribir. Por ejemplo, en las suscripciones RSS (el precursor de las notificaciones push de WeChat), cuando el autor de un blog (el observado) actualiza una entrada, los lectores (observadores) de los suscriptores reciben automáticamente la actualización. Este esquema de publicación-suscripción se denomina patrón Observador.

### Patrón Observador

La descripción del patrón Observador por (**G**ang **O**f **F**our):

> - Intención
>
>   Definir una relación de dependencia uno a muchos entre objetos, de modo que cuando un objeto cambia de estado, todos los objetos que dependen de él sean notificados y actualizados automáticamente.
>
> - Alias
>
>   Dependientes (Dependents), Publicar-Suscribir (Publish-Subscribe)
>
> - Motivación
>
>   Dividir un sistema en una serie de clases que cooperan entre sí tiene un efecto secundario común: es necesario mantener la consistencia entre los objetos relacionados. No queremos que las clases estén fuertemente acopladas solo para mantener la consistencia, ya que esto reduce su reutilización.
>
> ...
>
> - Participantes
>
>   - Sujeto (Subject)
>
>     El sujeto conoce a sus observadores. Puede haber cualquier número de observadores observando el mismo sujeto.
>
>     Proporciona una interfaz para registrar y eliminar objetos observadores.
>
>   - Observador (Observer)
>
>     Define una interfaz de actualización para aquellos objetos que necesitan ser notificados cuando el sujeto cambia.
>
>   - SujetoConcreto (ConcreteSubject)
>
>     Almacena el estado relevante en cada objeto ObservadorConcreto.
>
>     Cuando su estado cambia, notifica a todos sus observadores.
>
>   - ObservadorConcreto (ConcreteObserver)
>
>     Mantiene una referencia a un objeto SujetoConcreto.
>
>     Almacena el estado relevante, que debe ser consistente con el estado del sujeto.
>
>     Implementa la interfaz de actualización de Observer para mantener su propio estado consistente con el estado del sujeto.

Se puede observar que el patrón Observador se aplica comúnmente en:

- Dos objetos tienen una relación de dependencia.
- Cuando un objeto cambia, es necesario cambiar otros objetos simultáneamente.

En comparación con las llamadas a funciones ordinarias y las funciones de retorno de llamada, el uso del patrón Observador permite mantener la consistencia entre objetos a bajo costo, reduciendo significativamente **el grado de acoplamiento entre objetos, y además puede lograr un efecto de difusión, algo que los dos primeros no pueden hacer. El uso del patrón Observador mejora enormemente la reutilización del código**.

**Y Action y ActionListener en J2EE son un ejemplo vivo del patrón Observador.**

## Action y ActionListener en J2EE

Action y ActionListener pueden aplicarse bien en el paradigma MVC para reducir el grado de acoplamiento entre el modelo (model) y la vista (view).

Encontré un buen [ejemplo](http://www.ulisespulido.com/2009/03/observer-design-pattern-and-java-swing.html), cuyo código se muestra a continuación:

```java
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JTextField;

public class Frame extends JFrame {

  ActionListener observer1 = new Observer("First Observer");
  ActionListener observer2 = new Observer("Second Observer");
  ActionListener observer3 = new Observer("Third Observer");

  public Frame(){
    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    init();
  }

  private void init(){
    addChangingTextField();
    pack();
    setVisible(true);
  }

  private void addChangingTextField(){
    //Clase observable TextField. Cada vez que
    //ocurre una acción o evento, los observadores serán actualizados
    //Casi todas las clases Swing tienen este tipo de comportamiento
    JTextField dataTextField = new JTextField();

    // Registro de observadores en la clase observable.
    dataTextField.addActionListener(observer1);
    dataTextField.addActionListener(observer2);
    dataTextField.addActionListener(observer3);

    add(dataTextField);
  }

  public static void main(String [] args){
  	Frame frame = new Frame();
  }
}

class Observer implements ActionListener{

  private String name;
  private String message;

  public Observer (String s){
  	name = s;
  }

  public void actionPerformed(ActionEvent e) {
    JTextField textField = (JTextField) e.getSource();
    message = textField.getText();
    JOptionPane.showMessageDialog(null,
    name + " has been confirmed about the change, Thanks!! "
    + " The Message was: " + message);
  }
}
```

### Análisis

Las dos clases asumen los roles de Action y ActionListener respectivamente. `frame.dataTextField` en el método `addChangingTextField` vincula tres escuchas (`observer1`, `observer2`, `observer3`). Después de que se edita el campo de texto en el frame (cambio de estado), se activa el método `actionPerformed` en Observer, mostrando el texto correspondiente.

En este ejemplo, `frame.dataTextField` actúa como `SujetoConcreto`, y `observer1`, `observer2`, `observer3` como `ObservadoresConcretos`. Las interfaces que implementan, que definen los métodos de Action y ActionListener, son los `Sujeto` y `Observador` correspondientes.

Después de vincular a los observadores, el sujeto no se preocupa por el comportamiento específico de los observadores, sino que simplemente los notifica cuando cambia su propio estado, dejando que los observadores decidan qué acción tomar. Por lo tanto, este método es muy bueno, mucho mejor que activar acciones mediante llamadas explícitas a funciones o ejecución de funciones de retorno de llamada. Vale la pena aprenderlo.