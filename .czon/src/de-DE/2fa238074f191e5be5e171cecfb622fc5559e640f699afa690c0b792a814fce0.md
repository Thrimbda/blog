---
"title": "观察者模式实例分析"
"summary": "本文首先介绍了观察者模式的基本概念，包括其定义、别名、动机和参与者，并指出该模式常用于处理对象间的依赖关系和状态同步。文章通过一个J2EE中的Action和ActionListener实例，展示了观察者模式在降低Model和View耦合度方面的实际应用。实例中，JTextField作为具体目标，多个ActionListener作为具体观察者，当文本框状态改变时自动通知观察者执行相应操作。文章强调观察者模式相比普通函数调用和回调函数，能更有效地维持对象间一致性，提高代码可重用性。"
"tags":
  - "设计模式"
  - "观察者模式"
  - "J2EE"
  - "Action"
  - "ActionListener"
  - "系统分析与设计"
  - "MVC"
  - "耦合度"
"date": "2017-04-10"
---

---
title: 观察者模式实例分析
date: 2017-04-10
taxonomies:
  tags:
    - 设计模式
    - 系统分析与设计
---

> 通常，在面向对象分析与设计中存在三种事件处理机制：除了普通的函数调用外，还经常使用回调函数，而J2EE还提供了一种基于监听方式的事件处理机制。请查阅资料，对Action以及ActionListener的机制进行分析，并完成一个分析实例。

首先了解观察者模式

<!--more-->

## 观察者模式 (Observer Pattern)

### 现实世界中的观察者

观察者模式又称发布-订阅模式，例如RSS（微信推送的前身）订阅：某博客（被观察者）的博主更新文章后，订阅者的阅读器（观察者）就会自动收到更新。这种发布-订阅的机制我们称为观察者模式。

### 观察者模式

(**G**ang **O**f **F**our)对观察者模式的描述：

> - 意图
>
>   定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
>
> - 别名
>
>   依赖(Dependents)，发布-订阅(Publish-Subscribe)
>
> - 动机
>
>   将一个系统分割成一系列相互协作的类时，一个常见的副作用是需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合，因为这会降低它们的可重用性。
>
> ...
>
> - 参与者
>
>   - Subject（目标）
>
>     目标知道它的观察者。可以有任意多个观察者观察同一个目标。
>
>     提供注册和删除观察者对象的接口。
>
>   - Observer（观察者）
>
>     为那些在目标发生改变时需要获得通知的对象定义一个更新接口。
>
>   - ConcreteSubject（具体目标）
>
>     将有关状态存入各个ConcreteObserver对象。
>
>     当它的状态发生改变时，向它的各个观察者发出通知。
>
>   - ConcreteObserver（具体观察者）
>
>     维护一个指向ConcreteSubject对象的引用。
>
>     存储有关状态，这些状态应与目标的状态保持一致。
>
>     实现Observer的更新接口，以使自身状态与目标的状态保持一致。

可以发现观察者模式通常应用于：

- 两个对象具有依赖关系。
- 一个对象更改时需要同时更改其他对象。

与普通的函数调用以及回调函数相比，观察者模式能够以低成本维持对象间的一致性，**显著降低了对象间的耦合程度，同时可以实现广播效果，这是前两者无法做到的。观察者模式的使用大大提高了代码的可重用性**。

**而J2EE中的Action和ActionListener正是观察者模式的一个生动实例。**

## J2EE中的Action&ActionListener

Action&ActionListener可以很好地应用于MVC范式，以降低Model和View之间的耦合度。

找到一个很好的[例子](http://www.ulisespulido.com/2009/03/observer-design-pattern-and-java-swing.html)，代码如下所示：

```java
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JTextField;

public class Frame extends JFrame {

  ActionListener observer1 = new Observer("First Observer");
  ActionListener observer2 = new Observer("Second Observer");
  ActionListener observer3 = new Observer("Third Observer");

  public Frame(){
    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    init();
  }

  private void init(){
    addChangingTextField();
    pack();
    setVisible(true);
  }

  private void addChangingTextField(){
    //Observable class TextField. each time
    //An action or event occurs the observers will be updated
    //Almost all the Swing classes has this kind of behavior
    JTextField dataTextField = new JTextField();

    // Observer registering to the observable class.
    dataTextField.addActionListener(observer1);
    dataTextField.addActionListener(observer2);
    dataTextField.addActionListener(observer3);

    add(dataTextField);
  }

  public static void main(String [] args){
  	Frame frame = new Frame();
  }
}

class Observer implements ActionListener{

  private String name;
  private String message;

  public Observer (String s){
  	name = s;
  }

  public void actionPerformed(ActionEvent e) {
    JTextField textField = (JTextField) e.getSource();
    message = textField.getText();
    JOptionPane.showMessageDialog(null,
    name + " has been confirmed about the change, Thanks!! "
    + " The Message was: " + message);
  }
}
```

### 分析

两个类分别扮演了Action/ActionListener的角色。`frame.dataTextField`在`addChangingTextField`方法中绑定了三个监听器（`observer1`、`observer2`、`observer3`）。在Frame中，文本框被编辑后（状态改变），会触发Observer中的`actionPerformed`方法，显示相应的文本。

在这个例子中，`frame.dataTextField`作为`ConcreteSubject`，`observer1`、`observer2`、`observer3`作为`ConcreteObserver`。而它们所实现的、定义了Action/ActionListener方法的接口，则分别对应`Subject`和`Observer`。

绑定观察者后，目标并不关心观察者的具体行为，而只是在自身状态改变时通知观察者，由观察者自行决定执行什么操作。因此，这种方法非常优雅，比显式调用函数或执行回调函数来触发操作的方式高明得多，值得学习。