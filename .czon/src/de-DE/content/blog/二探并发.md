---
"title": "Ein zweiter Blick auf Parallelität (Actor)"
"summary": "Dieser Artikel analysiert zunächst, wie bei der Verwendung einer gemeinsamen Nachrichtenwarteschlange in einem parallelen System, in dem verschiedene Worker asynchron und mit spezifischen Aufgaben arbeiten sollen, Probleme auftreten: Nachrichten können nicht gezielt gesendet werden, falsch empfangene Nachrichten führen zu Ineffizienz und Reihenfolgeproblemen. Der Autor weist auf die FIFO-Eigenschaft der gemeinsamen Warteschlange und die durch Sperrmechanismen verursachten Effizienzprobleme hin und schlägt als grundlegende Lösung das Actor-Modell vor. Das Actor-Modell löst dies, indem jeder Worker eine eigene Nachrichtenwarteschlange (Mailbox) erhält, was gezielte asynchrone Kommunikation ermöglicht und die Komplexität des gemeinsamen Speichers vermeidet. Der Artikel erläutert detailliert das Konzept des Actor-Modells und zeigt ein Beispiel mit Python-Threads, wie die grundlegende Funktionalität eines Actors – Senden/Empfangen von Nachrichten und Thread-Management – durch eine BaseWorker-Klasse implementiert werden kann. Abschließend resümiert der Autor, dass parallele Programmierung ein abstrakteres Denken erfordert und das Actor-Modell eine gute Einführung bietet."
"tags":
  - "python"
  - "Parallelität"
  - "Actor-Modell"
  - "Nachrichtenwarteschlange"
  - "Asynchrone Programmierung"
"date": "2017-05-19"
---

---
title: Ein zweiter Blick auf Parallelität (Actor)
date: 2017-05-19
taxonomies:
  tags:
    - python
    - Parallelität
---

[Beim letzten Mal](http://0xc1.space/2017/05/06/初探并发/) ging es darum, Nachrichtenwarteschlangen zu nutzen, um Nachrichten zwischen Threads (oder Prozessen) zu übermitteln und so die Kommunikation zwischen ihnen zu ermöglichen.

<!--more-->

## Die gemeinsame Nachrichtenwarteschlange

Dies basiert auf der Annahme, dass **Parallelität lediglich den Durchsatz des Systems erhöhen soll**. Unter dieser Annahme erledigt jeder Worker die gleiche Arbeit, daher kann eine gemeinsame Nachrichtenwarteschlange verwendet werden – es spielt keine Rolle, wer den nächsten Befehl erhält.

### Was, wenn wir nicht gleich sind?

Was ist, wenn wir ein System implementieren müssen, in dem verschiedene Worker asynchron und mit spezifischen Aufgaben arbeiten (z. B. unser IP-Telefon)? Angenommen, wir verwenden weiterhin die oben beschriebene Methode, bei der alle Worker eine gemeinsame Nachrichtenwarteschlange teilen. Dann entsteht ein Problem: Nachrichten können nicht an einen bestimmten Worker gesendet werden.

Wie lässt sich dieses Problem lösen? Eine einfache, aber grobe Lösung besteht darin, jede Nachricht mit einem Kennzeichen zu versehen, das den Empfänger angibt:

```python
queue = Queue([('Send_to_worker_A', 'do_something1'),
               ('Send_to_worker_B', 'do_something2'),
               ('Send_to_worker_B', 'do_something3'),
               ('Send_to_worker_C', 'do_something4'),
               ('Send_to_worker_A', 'do_something5')])
```

Sieht so aus, als wäre das Problem gelöst, oder? Aber wir haben ein neues Problem eingeführt.

### Was, wenn ich versehentlich den Brief für jemand anderen öffne?

Wenn eine Nachricht für Worker A von Worker B empfangen wird, ist sie für diesen nutzlos. Der eigentlich vorgesehene Empfänger, Worker A, erhält sie nicht, und die Nachricht geht verloren. Das verschwendet nicht nur die Zeit von Worker B, sondern auch die von Worker A und könnte durch einen Sprung in der Abfolge das gesamte System in einen seltsamen Bug stürzen.

Wie lässt sich dieses Problem lösen? Intuitiv betrachtet scheint die folgende Strategie für jeden Worker das Problem zu beheben: Wenn man eine Nachricht für jemand anderen erhält, steckt man sie einfach zurück in die Warteschlange.

```python
class Worker_B:
    
    def run(self):
        while True:
            if not self.queue.empty():
                data = self.queue.get()
                if data['to_whom'] == 'worker_B':
                    do_something_with_data
                else:
                    self.queue.put(data)
```

Es sieht so aus, als hätten wir das Problem mit Flickwerk gelöst... aber tatsächlich haben wir ein neues Problem eingeführt.

### Das scheint eine Sackgasse zu sein

Erstens ist eine Nachrichtenwarteschlange eine Warteschlange, was FIFO (First In, First Out) bedeutet. Selbst wenn wir eine priorisierte Warteschlange einführen, ändert sich dieser grundlegende Punkt nicht. Dadurch wird die Nachricht, die eigentlich als erste an Worker A gehen sollte, nachdem Worker B sie "weitergereicht" hat, zur letzten in der Warteschlange für Worker A. Das könnte das System in einen seltsamen Bug stürzen.

Zweitens: Selbst wenn wir es schaffen, die falsch verteilte Nachricht wieder an den Anfang der Warteschlange zu setzen, kann es – wenn wir keinen Sperrmechanismus einführen, der den Vorgang `Empfangen-Prüfen-Zurücklegen` von Worker B zu einem atomaren Vorgang macht – passieren, dass andere Worker bereits weiter Nachrichten empfangen, während Worker B die Nachricht zurücklegt. Das kann immer noch zu großen Problemen in der zeitlichen Abfolge führen. Die Einführung eines Sperrmechanismus würde zwar die logischen Fehler beheben, aber dazu führen, dass bei jedem Abfragezyklus nur ein Worker tatsächlich arbeiten kann. Die anderen Worker, die eine falsche Nachricht erhalten und den `Empfangen-Prüfen-Zurücklegen`-Vorgang ausführen, verschwenden ihre Zeitscheibe – **ineffizient**.

Daher scheint eine gemeinsame Nachrichtenwarteschlange für alle Worker in einem System, das Parallelität für asynchrone Arbeit einführt, keine gute Lösung zu sein.

Die radikale Lösung für dieses Problem besteht darin, für jede Gruppe von Workern, die die gleiche Aufgabe ausführen, eine eigene spezielle Nachrichtenwarteschlange (Mailbox) einzurichten, oder sogar für jeden Worker eine eigene Nachrichtenwarteschlange, wodurch die Fähigkeit der Threads, Speicher zu teilen, vollständig aufgegeben wird. Die letztere Methode ist der heutige Hauptdarsteller: **das Actor-Modell (Akteur-Modell)**.

## Das Actor-Modell

Schauen wir uns zunächst die Definition und Konzepte des Actor-Modells laut Wikipedia an:

### Konzept

In der Informatik ist das Actor-Modell (englisch: Actor model) ein Modell für nebenläufige Berechnungen. Ein "Akteur" (Actor) ist ein programmatisches Abstraktionskonzept, das als grundlegende Einheit der nebenläufigen Berechnung betrachtet wird: Wenn ein Akteur eine Nachricht empfängt, kann er Entscheidungen treffen, weitere Akteure erstellen, weitere Nachrichten senden und festlegen, wie er auf die nächste Nachricht reagieren wird. Das Actor-Modell wurde 1973 in einem Artikel von Carl Hewitt, Peter Bishop und Richard Steiger vorgestellt.

Die Philosophie des Actor-Modells lautet "Alles ist ein Akteur", ähnlich wie "Alles ist ein Objekt" in der objektorientierten Programmierung, jedoch ist die objektorientierte Programmierung in der Regel sequentiell, während das Actor-Modell parallel ausgeführt wird. Ein Akteur ist eine Berechnungseinheit, die auf empfangene Nachrichten reagiert und dabei parallel:

- eine begrenzte Anzahl von Nachrichten an andere Akteure sendet;
- eine begrenzte Anzahl neuer Akteure erstellt;
- das Verhalten für den Empfang der nächsten Nachricht festlegt.

Bei den oben genannten Operationen wird keine sequentielle Ausführung angenommen, daher können sie parallel durchgeführt werden. Die Entkopplung des Senders von der gesendeten Nachricht ist der grundlegende Vorteil des Actor-Modells. Dies ermöglicht asynchrone Kommunikation und erfüllt gleichzeitig die Kontrollstrukturen der Nachrichtenübermittlung. Nachrichtenempfänger werden über Adressen unterschieden, die manchmal auch als "Mailadressen" bezeichnet werden. Daher kann ein Akteur nur mit Akteuren kommunizieren, deren Adresse er besitzt. Er kann Adressen aus empfangenen Informationen erhalten oder die Adressen der von ihm erstellten Akteure abrufen. Charakteristisch für das Actor-Modell ist, dass Berechnungen innerhalb von Akteuren oder zwischen ihnen parallel ablaufen, Akteure dynamisch erstellt werden können, Adressen in Nachrichten enthalten sind, die Interaktion nur über direkte asynchrone Nachrichtenkommunikation erfolgt und die Reihenfolge des Nachrichteneingangs nicht eingeschränkt ist.

### Implementierung

Actors sind einfach genug, für Parallelität geschaffen und bieten eine ausreichend gute Kapselung, um Änderungen zu isolieren (z. B. unabhängig davon, ob es sich um Multithreading oder Multiprocessing handelt).

Sehen wir uns eine typische Python-Thread-Implementierung eines Actors an:

```python
from queue import Queue
from threading import Thread, Event


class WorkerExit(Exception):
    # Exception zum Beenden der Aufgabe
    pass


class BaseWorker(object):
    # Actor
    def __init__(self):
        self._mailbox = Queue()
        super(BaseWorker, self).__init__()

    def send(self, msg):
        self._mailbox.put(msg)

    def recv(self):
        msg = self._mailbox.get()
        if msg is WorkerExit:
            raise WorkerExit()
        return msg

    def close(self):
        self.send(WorkerExit)

    def start(self):
        self._terminated = Event()
        t = Thread(target=self._bootstrap)

        t.daemon = True
        t.start()

    def _bootstrap(self):
        try:
            self.run()
        except WorkerExit:
            pass
        finally:
            self._terminated.set()

    def join(self):
        self._terminated.wait()

    def run(self):
        raise NotImplementedError
```

Kurz erklärt: Dieser Actor (ich habe ihn BaseWorker genannt und verwende ihn in realen Projekten als Basisklasse) verwaltet zwei Datenstrukturen: eine `Queue` als Mailbox und ein `Event` als Mechanismus zum Blockieren des Hauptthreads.

Die zentrale Operation, die hier als externe Schnittstelle dient, ist nur die Methode `send()`. Bitte beachten Sie, dass **wir den Typ der Nachricht, die gesendet werden kann, nicht einschränken**. Das bedeutet maximale Flexibilität.

Innerhalb des Actors verwenden wir einen Thread, um die Methode `run()` in Kombination mit der Methode `recv()` auszuführen und die spezifische Arbeit zu erledigen. Erwähnenswert ist, dass wir ein Sentinel-Signal `WorkerExit` zum Stoppen der Aufgabe eingeführt haben. Bitte beachten Sie, dass `WorkerExit` funktioniert, indem es, sobald erkannt, als Exception ausgelöst wird. Im Exception-Handler könnten wir hier sogar mehr tun, aber in diesem Fall beenden wir einfach den Thread, wenn diese Exception gefangen wird. Die Implementierung dieser Exception-Behandlung erfolgt über `_bootstrap()`, das `run()` umschließt.

Auf der philosophischen Grundlage des Actor-Modells können wir dieses einfache Beispiel erweitern und weiter gehen.

## Zusammenfassung

Parallele Programmierung erfordert eine abstraktere Denkweise als gewöhnlich und kann auch als gute Praxis für das Prinzip "hohe Kohäsion, lose Kopplung" dienen.

In meiner Erkundung dieses für mich völlig neuen Gebiets war das Actor-Modell tatsächlich ein Leitstern, der mich richtig eingeführt hat, daher teile ich es hier. :)