---
"title": "First Exploration of Concurrency"
"summary": "This article shares the author's experience with concurrent programming through a small assignment, implementing a simple concurrency control demo using Python's queue, signal, and time modules. The article explains the roles of the three modules: queue as a message queue, signal for capturing KeyboardInterrupt signals, and time allowing the main thread to catch interrupts. The author further discusses the importance of message queues in multithreaded programming and the design philosophy of encapsulating details and using events for collaboration to reduce coupling in system design, emphasizing the concept of 'designing for change.'"
"tags":
  - "python"
  - "concurrency"
  - "multithreading"
  - "message queue"
  - "system design"
"date": "2017-05-07"
---

---
title: First Exploration of Concurrency
date: 2017-05-07
taxonomies:
  tags:
    - python
    - concurrency
---

Great! A recent small assignment allowed me to tangibly explore meaningful concurrent programming.

<!--more-->

## Demo

Thus, I created a small demo using Python's `queue`, `signal`, and `time` modulesâ€”not truly multithreaded, but illustrative:

```python
# -*- coding: utf-8 -*-
# @Author: Michale
# @Date:   2017-05-04 15:00:41
# @Last Modified by:   Michale
# @Last Modified time: 2017-05-07 00:46:52
import signal
import queue
import time


class TestClass(object):
    queue = queue.Queue()

    def __init__(self):
        signal.signal(signal.SIGINT, self.stopIfPressKill)

    def stopIfPressKill(self, mySignal, stack):
        if mySignal == signal.SIGINT:
            print('you pressed CTRL-C')
            self.queue.put_nowait('stop')
            print(self.queue.qsize())

    def mainThread(self):
        while True:
            time.sleep(1)
            if not self.queue.empty():
                data = self.queue.get()
                print(data)
                if data == 'stop':
                    break
                else:
                    self.queue.put(data)


if __name__ == '__main__':
    yoo = TestClass()
    yoo.mainThread()

```

Explanation of the three modules' roles:

- `queue`: Serves as a message queue, which is admittedly overkill here.
- `signal`: Used to capture `KeyboardInterrupt` and place a stop signal into the message queue.
- `time`: Allows the main thread to catch the `KeyboardInterrupt`.

## Philosophy

The introduction of multithreading makes non-main threads difficult to control once started, thus necessitating methods like message queues for inter-thread communication.

However, regardless of whether multithreading is involved, system modules should encapsulate their details and collaborate through events. This significantly helps reduce system coupling and reflects a key design philosophy for robust systems: **design for change.**