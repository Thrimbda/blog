---
"title": "Zola Blog Real-time Editing and GitHub Backend Integration Solution Design"
"summary": "This document details the planning for designing a WYSIWYG editor with real-time Markdown editing and a 'no-handwritten-backend' integration solution for a Zola blog, without disrupting the existing CSS design style. The document clarifies design principles, including maintaining the current visual language, avoiding handwritten backends where possible, supporting real-time preview and auto-save, etc. Through a current state audit, it confirms the project is a Zola site with no Node/React build chain, and content sources are Markdown files. Among candidate solutions, the primary recommendation is Scheme D: Pure JS /admin + Vditor + GitHub Device Flow + PR Publishing, achieving a complete workflow with no self-built backend, using GitHub as the source of truth, caching drafts only locally, and storing images back in the repo. The document also covers security risks, scope definition, and phase overview, with final recommended implementation steps based on default assumptions to ensure feasibility and alignment with user preferences."
"tags":
  - "Zola"
  - "Markdown"
  - "WYSIWYG"
  - "GitHub"
  - "Real-time Editing"
  - "Backendless"
  - "Frontend Development"
  - "Blog Optimization"
"date": "2026-01-06"
---

# Zola Blog: WYSIWYG Markdown Real-time Editing + Supabase/GitHub Backend Solution Design

## Goal

To design and plan a WYSIWYG editor with real-time Markdown editing and a "no-handwritten-backend" integration (using Supabase or GitHub Issues/Discussions) for the current Zola blog, without disrupting the existing CSS design style.

## Design Principles (Must Follow)

- Maintain the existing suCSS + CSS variables visual language (including light/dark theme switching)
- Avoid introducing handwritten backends where possible; prioritize frontend direct connections to Supabase or GitHub API
- If React/shadcn is needed, provide justification for introducing a build chain, along with cost and rollback plans
- The editing experience must support real-time preview/rendering and auto-save (at least for drafts)
- Clearly define the synchronization path for publishing content to Zola (without breaking the existing content structure)

## Current State Summary (From Audit)

- This project is a Zola site (no Node/React build chain). All CSS/JS is served from `static/`, and CDN dependencies can be included via `templates/head.html`.
- The theme/colors are entirely driven by CSS variables in `static/css/suCSS.css`; JS toggles light/dark via `data-theme` (`static/js/script.js`).
- Content sources are `content/**` Markdown files; they include YAML front matter (`---`) and Zola shortcodes (e.g., `{{ slideshow(...) }}`).

## Points Requiring Your Review/Clarification (Please Answer/Choose)

1.  **Editing Scope**: Do you need to edit only one/a few specific files (e.g., `content/gcores-talks.md`) or want the ability to "edit any page under `content/**`"?
2.  **Real-time Editing**: Your definition of "real-time" is:
    - A) Real-time preview/rendering within the editor is sufficient (single user)
    - B) Requires background auto-save of drafts (single user)
    - C) Requires multi-user collaboration/simultaneous editing (multiple users)
3.  **Publishing Pipeline**: How should editing results ultimately affect the site?
    - A) Only save to a draft repository (not automatically placed into `content/`)
    - B) One-click publish: Automatically sync to the repo's `content/` and trigger a Zola build
    - C) Semi-automatic: Export files/generate a patch for you to manually commit
4.  **Authentication**: The admin is for your use only. Would you accept "Supabase email magic link + single-user allowlist"?
5.  **Images**: Do you need to upload images directly within the editor? If yes, would you accept storing images in Supabase Storage and referencing them via external links in Markdown?

> [REVIEW]
> 1. I want to edit any file, then submit it to the GitHub repo via some method. If a backend is needed, justify its necessity.
> 2. A and B
> 3. B
> 4. This version is for my use only, admin access is fine. Just ensure security. I could even accept having an elliptic curve key pair for authentication, like SSH.
> 5. Need image upload, and prefer images stored in the repo.
>
> [RESPONSE] Received. I'll adjust the default assumptions/solution direction based on your answers:
>
> 1) Editing Scope: Changed to "can edit any file under `content/**`" (and allow extension to `templates/**` etc., but MVP will lock to `content/**` to reduce risk). The publishing path's core goal is "writing back to the GitHub repo"; Supabase will no longer be the source of truth.
>
> 2) Real-time Editing: Choose A + B — real-time rendering/preview within the editor + auto-save (draft).
>
> 3) Publishing Pipeline: Choose B — one-click submission of editing results to GitHub (recommended via PR rather than direct push to master for easier review/rollback; can be configured as direct push if you insist).
>
> 4) Authentication: MVP is for your use only. Your mention of "elliptic curve key pair like SSH" could serve as local credential protection (e.g., using your private key to decrypt a GitHub token stored in IndexedDB, or as an unlock step). However, actual writes to GitHub still require a GitHub authorization token. To meet "avoid backend if possible," I lean towards using GitHub OAuth *device flow* (no `client_secret` dependency) completed purely on the frontend, then storing the token only locally with optional secondary encryption using your private key.
>
> 5) Images: Per your preference, images are also stored in the repo (e.g., written to `static/images/uploads/...`, referenced in Markdown as `/images/uploads/...`). Implementation-wise, uploading uses "the same GitHub token to create blob/commit via API," requiring no additional backend.
>
> My next step is to change the plan's "default recommendation A (Supabase as source of truth)" to "GitHub as source of truth + Discussions/Issues for drafts + PR publishing," and supplement the design with details and limitations regarding token storage/encryption and image writing to the repo (single file size, commit strategy for frequent autosave, etc.).
> [STATUS:resolved]

> [REVIEW] If possible, I think device flow is acceptable, so we might not need the key pair. I can trust my own device.
>
> [RESPONSE] OK. Given acceptance of device flow, we can remove the "elliptic curve key pair" from the MVP:
> - Use GitHub OAuth device flow to obtain a write-access token for the repo
> - Token is saved only on the local machine (IndexedDB/localStorage); you trust your own device
> - If you later want "secondary unlock/protection against local observers," the key pair/OS Keychain can be added as an optional v2 enhancement
> [STATUS:resolved]

## Candidate Solutions (High-Level Architecture)

### Scheme D (Current Implementation / Primary Scheme): Pure JS `/admin` + Vditor + GitHub Device Flow + PR Publishing

- **Frontend**: `static/admin/*` static pages, reusing existing `reset.css`/`suCSS.css`/`style.css` and `static/js/script.js` theme toggle (maintaining consistent design language).
- **Editor**: Vditor (default IR mode), with separate editing for body and front matter (to avoid WYSIWYG corruption).
- **Authentication**: GitHub OAuth **device flow** (no `client_secret` needed, no self-built token exchange backend required); token saved only in local IndexedDB.
- **Drafts**: Local autosave only (IndexedDB), no cross-device sync, no Git commit noise.
- **Publishing**: Create branch + PR upon publish, writing in one go:
    - `content/**.md` (merged front matter + body)
    - `static/images/uploads/**` (images registered as pending assets upon insertion, submitted together upon publishing)

Advantages: Completely no self-built backend; "source of truth" is the GitHub repo; aligns with your preferences.
Risks: Need to verify editor's "fidelity" for shortcodes/front matter (especially pages containing `{{ ... }}`); need to control GitHub API permission scope.

### Scheme A (Optional): Pure JS `/admin` + Vditor + Supabase (Drafts/Cross-Device Only)

Introduce only if future need arises for "cross-device draft sync/collaboration"; not as source of truth.

### Scheme B (Optional): Pure JS `/admin` + TOAST UI Editor

If you prefer TOAST UI's editing experience, the editor can be swapped (requires additional theme override cost).

### Scheme C (Optional): React `/admin` (Vite) + shadcn UI + Milkdown/TipTap

Suitable for: You need more complex UI/interactions (resource management, extension blocks, etc.). Cost: Introduces Node build chain; requires strict mapping to existing suCSS variables to avoid style drift.

> [REVIEW] I think Scheme D should be a good solution. It doesn't need a backend, and the state is all on GitHub. I think I can accept introducing an OAuth provider. My current comment system does this too. You can see how to implement it. If Supabase must be introduced, it should only store drafts, not act as the source of truth storage.
>
> [RESPONSE] Agree with your direction: Using GitHub (Issues/Discussions + repo) as the primary storage where "state is all on GitHub" better aligns with your preferences; if Supabase is introduced, it should be downgraded to an "optional draft/cache," not the system's source of truth.
>
> I need you to confirm two more points to avoid missteps:
>
> 1) **OAuth Form**: You said, "can accept introducing an OAuth provider (the comment system does this too)." The comment system giscus relies on a GitHub App/server-side for token exchange and signing. If we also use the traditional web OAuth flow, it involves keeping the `client_secret` confidential, typically still requiring a trusted backend/function for token exchange. To meet "no handwritten backend," I recommend using GitHub OAuth *device flow*: authorization can be completed purely on the frontend (no backend needed to safeguard `client_secret`). Do you accept device flow as a replacement for the "OAuth provider"?
>
> 2) **Where to Store Drafts**:
>     - D1) GitHub Discussions: Each page corresponds to a discussion; the draft is the discussion body; publishing generates a PR to write to `content/**`.
>     - D2) GitHub Issues: Same principle, but issues are more task-oriented.
>     - D3) Repo `drafts` branch: Autosave directly updates files (will generate many commits, requiring merge/squash strategies).
>     Which do you prefer, D1/D2/D3?
>
> After your confirmation, I will supplement the "GitHub as source of truth + draft strategy + PR publishing strategy + image submission strategy + security model (token local storage/optional private key encryption)" into actionable implementation steps.
> [STATUS:need-info]
>
> [RESPONSE] Agreed and have converged based on your latest confirmation:
> - Scheme D (GitHub as primary storage) is the main scheme, but no longer needs "OAuth provider + backend token exchange," using **device flow** instead.
> - Supabase is removed from the main path (if cross-device drafts/collaboration are needed in the future, it can be added as an optional component).
>
> Implementation implications (for your confirmation):
> - `draft/autosave`: Only writes to local cache, no Git commits; avoids "generating a commit/PR noise with every keystroke."
> - `publish`: Submits the specified `content/**` file + image changes to GitHub in one go (default recommendation is to open a PR; can also be configured to push directly to master).
>
> If you agree with this convergence direction, my next step (once you give the go-ahead for code changes) is to implement accordingly.
> [STATUS:resolved]

> [REVIEW] 1. Device flow is acceptable. 2. I think maybe just frontend caching. I don't seem to have a need for cross-device sync, so let's not complicate things.
>
> [RESPONSE] Confirmation received:
> 1) OAuth: Adopt GitHub device flow (no `client_secret` dependency, no self-built token exchange backend needed).
> 2) Drafts: Only implement frontend local caching (IndexedDB primary, localStorage as fallback/for small data), no cross-device sync.
>
> Accordingly, I will converge the overall design to:
> - **Source of Truth (published)**: GitHub repo `content/**` (written back via PR/push)
> - **Drafts (draft/autosave)**: Local cache (no need for Supabase/GitHub Discussions/Issues)
> - **Images**: Written to the repo upon publishing (e.g., `static/images/uploads/...`), referenced in Markdown with site-relative paths
> [STATUS:resolved]

## Recommended Implementation (Based on Default Assumptions)

Current implementation directly adopts Scheme D (backendless):

1. `/admin/` static page: Connect to GitHub (device flow), fetch list of `content/**.md` files.
2. Load file: Parse and separate front matter and body; edit body with Vditor.
3. Drafts: Debounced save to local IndexedDB upon input (no write to GitHub).
4. Images: Register as pending assets via "Insert image," inserting site-relative paths (`/images/uploads/...`); submit to repo's `static/images/uploads/...` upon publishing.
5. Publish: Create branch + PR (single commit containing Markdown + images), triggering the existing Zola deploy workflow upon merge.

## Security and Risk Checklist (Requires Verification/Testing)

- Editor fidelity for `{{ ... }}` (Zola shortcodes) and front matter (especially in WYSIWYG mode).
- XSS: If raw HTML is allowed in Markdown, publishing to the site introduces injection risks (requires rule constraints/filtering "before publishing").
- GitHub token scope: Minimize as much as possible (use `public_repo` for public repo).
- Admin page indexing: Requires `noindex` (or placed at an unguessable path/additional gate) to avoid search engine indexing.

## Scope

- static/css/*
- templates/*
- static/js/*
- scripts/*
- .github/*
- .legion/**

## Phase Overview

1. **Current State Audit and Constraints** - 2 tasks
2. **Editor Selection Research** - 2 tasks
3. **Backend and Data Model Design** - 2 tasks
4. **Integration Solution Detailed Design and Implementation Plan** - 2 tasks

---

*Created: 2026-01-06 | Last Updated: 2026-01-06*