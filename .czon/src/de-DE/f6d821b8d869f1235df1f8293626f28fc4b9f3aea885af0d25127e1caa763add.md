---
"title": "Ein zweiter Blick auf Nebenläufigkeit (Actor)"
"summary": "Der Artikel diskutiert zunächst, dass in der nebenläufigen Programmierung, wenn mehrere Worker asynchron arbeiten und jeweils spezifische Aufgaben erfüllen, die gemeinsame Nutzung einer Nachrichtenwarteschlange zu Problemen führt: Nachrichten können nicht gezielt gesendet werden, es kommt zu fehlerhaften Empfängen und zeitlichen Abfolgeproblemen.\
  Durch schrittweise Analyse zeigt der Autor die Ineffizienz und potenziellen Fehler einer gemeinsamen Nachrichtenwarteschlange in diesem Szenario auf. Anschließend wird das Actor-Modell als grundlegende Lösung eingeführt, das jedem Worker eine unabhängige Nachrichtenwarteschlange (Mailbox) zuweist und so vollständige Nachrichtenisolierung und asynchrone Kommunikation ermöglicht.\
  Der Artikel erläutert detailliert die Konzepte des Actor-Modells, einschließlich paralleler Ausführung, Nachrichtenübermittlung und Adressmechanismen, und stellt ein Beispielcode-Implementierung in Python-Threads vor, das zeigt, wie ein grundlegender Actor (BaseWorker) aufgebaut wird.\
  Abschließend fasst der Autor die Vorteile des Actor-Modells in der nebenläufigen Programmierung zusammen und betont dessen abstrakten Denkansatz und den praktischen Wert von „hoher Kohäsion, loser Kopplung“."
"tags":
  - "python"
  - "Nebenläufigkeit"
  - "Actor-Modell"
  - "Nachrichtenwarteschlange"
  - "Asynchrone Programmierung"
  - "Multithreading"
  - "Programmiermodell"
"date": "2017-05-19"
---

---
title: Ein zweiter Blick auf Nebenläufigkeit (Actor)
date: 2017-05-19
taxonomies:
  tags:
    - python
    - Nebenläufigkeit
---

[Im letzten Beitrag](http://0xc1.space/2017/05/06/初探并发/) ging es darum, Nachrichtenwarteschlangen zu nutzen, um Nachrichten zwischen Threads (Prozessen) zu übermitteln und so die Kommunikation zwischen Threads zu ermöglichen.

<!--more-->

## Gemeinsame Nachrichtenwarteschlange

Dies basiert auf der Annahme, dass **Nebenläufigkeit lediglich den Durchsatz des Systems erhöht**. In diesem Szenario erledigen alle Worker die gleiche Arbeit, sodass sie eine gemeinsame Nachrichtenwarteschlange nutzen können – es spielt keine Rolle, wer die nächste Anweisung erhält.

### Was, wenn wir nicht gleichartig sind?

Angenommen, wir müssen ein System implementieren, in dem verschiedene Worker asynchron arbeiten und jeweils spezifische Aufgaben erfüllen (z. B. unser IP-Telefon). Wie gehen wir vor? Wenn wir weiterhin die oben beschriebene Methode verwenden und alle Worker eine gemeinsame Nachrichtenwarteschlange nutzen, entsteht ein Problem: Nachrichten können nicht an bestimmte Worker gesendet werden.

Wie lässt sich dieses Problem lösen? Eine einfache, aber grobe Lösung besteht darin, jeder Nachricht eine Kennung hinzuzufügen, die den Empfänger angibt:

```python
queue = Queue([('Send_to_worker_A', 'do_something1'),
               ('Send_to_worker_B', 'do_something2'),
               ('Send_to_worker_B', 'do_something3'),
               ('Send_to_worker_C', 'do_something4'),
               ('Send_to_worker_A', 'do_something5')])
```

Sieht so aus, als wäre das Problem gelöst, oder? Doch wir haben ein neues Problem eingeführt.

### Was, wenn ich versehentlich die Post anderer öffne?

Wenn eine Nachricht für Worker A von Worker B empfangen wird, ist sie für diesen nutzlos, während Worker A, der sie eigentlich erhalten sollte, sie nicht bekommt – die Nachricht geht verloren. Das verschwendet nicht nur die Zeit von Worker B, sondern auch die von Worker A und kann durch Überspringen von Schritten zu seltsamen Fehlern im gesamten System führen.

Wie lässt sich dieses Problem lösen? Intuitiv betrachtet scheint es auszureichen, jedem Worker die folgende Strategie hinzuzufügen: Wenn er eine Nachricht für einen anderen erhält, legt er sie zurück in die Nachrichtenwarteschlange.

```python
class Worker_B:
    
    def run(self):
        while True:
            if not self.queue.empty():
                data = self.queue.get()
                if data['to_whom'] == 'worker_B':
                    do_something_with_data
                else:
                    self.queue.put(data)
```

Es sieht so aus, als wäre das Problem mit einigen Flickarbeiten gelöst... doch tatsächlich haben wir ein neues Problem eingeführt.

### Das scheint eine Sackgasse zu sein

Erstens ist eine Nachrichtenwarteschlange eine Warteschlange, was FIFO (First In, First Out) bedeutet. Selbst wenn wir priorisierte Nachrichtenwarteschlangen einführen, ändert sich dies im Kern nicht. Dadurch wird eine Nachricht, die eigentlich als erste an Worker A gehen sollte, nach dem Umlenken durch Worker B zur letzten in der Warteschlange für Worker A – was zu seltsamen Fehlern im System führen kann.

Zweitens: Selbst wenn wir es schaffen, fehlgeleitete Nachrichten wieder an den Anfang der Warteschlange zu setzen, kann es – ohne Sperrmechanismen, die den Vorgang `Empfangen-Prüfen-Zurücklegen` von Worker B zu einem atomaren Vorgang machen – während Worker B die Nachricht zurücklegt, passieren, dass andere Worker bereits weiter Nachrichten empfangen. Dies kann weiterhin zu erheblichen zeitlichen Abfolgeproblemen führen. Die Einführung von Sperrmechanismen mag logische Fehler beheben, führt aber dazu, dass bei jeder Abfrage nur ein Worker tatsächlich arbeiten kann, während andere, die fehlerhafte Nachrichten erhalten und den `Empfangen-Prüfen-Zurücklegen`-Vorgang ausführen, ihre Zeit vergeuden – **ineffizient**.

Daher scheint die gemeinsame Nutzung einer Nachrichtenwarteschlange durch alle Worker für Systeme, die Nebenläufigkeit für asynchrone Arbeit einführen, keine gute Lösung zu sein.

Die grundlegende Lösung für dieses Problem besteht darin, für jede Gruppe von Workern, die die gleiche Aufgabe ausführen, eine eigene Nachrichtenwarteschlange (Mailbox) einzurichten – oder sogar für jeden Worker eine eigene Nachrichtenwarteschlange, wodurch die Fähigkeit der Threads, Speicher gemeinsam zu nutzen, vollständig aufgegeben wird. Die letztere Methode ist der heutige Hauptakteur: **das Actor-Modell (Akteur-Modell)**.

## Das Actor-Modell

Zunächst werfen wir einen Blick auf die Definition und Konzepte des Actor-Modells laut Wikipedia:

### Konzepte

In der Informatik ist das Actor-Modell ein Modell für nebenläufige Berechnungen. Ein „Actor“ (Akteur) ist ein abstraktes Programmierkonzept, das als grundlegende Einheit nebenläufiger Berechnungen betrachtet wird: Wenn ein Actor eine Nachricht empfängt, kann er Entscheidungen treffen, weitere Actors erstellen, weitere Nachrichten senden und festlegen, wie er auf künftige Nachrichten reagieren wird. Das Actor-Modell wurde 1973 in einem Artikel von Carl Hewitt, Peter Bishop und Richard Steiger vorgestellt.

Die Philosophie des Actor-Modells lautet „Alles ist ein Actor“, ähnlich wie „Alles ist ein Objekt“ in der objektorientierten Programmierung, jedoch ist die objektorientierte Programmierung in der Regel sequenziell, während das Actor-Modell parallel ausgeführt wird. Ein Actor ist eine Berechnungseinheit, die auf empfangene Nachrichten reagiert und dabei parallel:

- eine begrenzte Anzahl von Nachrichten an andere Actors sendet;
- eine begrenzte Anzahl neuer Actors erstellt;
- das Verhalten für den Empfang der nächsten Nachricht festlegt.

Diese Operationen setzen keine sequenzielle Ausführung voraus und können daher parallel durchgeführt werden. Die Entkopplung des Senders von den gesendeten Nachrichten ist der grundlegende Vorteil des Actor-Modells. Dies ermöglicht asynchrone Kommunikation und erfüllt gleichzeitig die Kontrollstrukturen der Nachrichtenübermittlung. Nachrichtenempfänger werden über Adressen unterschieden, die manchmal auch als „Mailadressen“ bezeichnet werden. Daher können Actors nur mit solchen Actors kommunizieren, deren Adressen sie besitzen. Sie können Adressen aus empfangenen Informationen erhalten oder die Adressen der von ihnen erstellten Actors abrufen. Charakteristisch für das Actor-Modell ist, dass Berechnungen innerhalb oder zwischen Actors parallel erfolgen, Actors dynamisch erstellt werden können, Adressen in Nachrichten enthalten sind, die Interaktion ausschließlich über direkte asynchrone Nachrichtenkommunikation erfolgt und die Reihenfolge des Nachrichteneingangs nicht eingeschränkt wird.

### Implementierung

Actors sind einfach genug, für Nebenläufigkeit konzipiert und bieten ausreichend gute Kapselung, um Änderungen zu isolieren (z. B. unabhängig davon, ob es sich um Multithreading oder Multiprocessing handelt).

Sehen wir uns eine typische Python-Thread-Implementierung eines Actors an:

```python
from queue import Queue
from threading import Thread, Event


class WorkerExit(Exception):
    # Ausnahme zum Beenden der Aufgabe
    pass


class BaseWorker(object):
    # Actor
    def __init__(self):
        self._mailbox = Queue()
        super(BaseWorker, self).__init__()

    def send(self, msg):
        self._mailbox.put(msg)

    def recv(self):
        msg = self._mailbox.get()
        if msg is WorkerExit:
            raise WorkerExit()
        return msg

    def close(self):
        self.send(WorkerExit)

    def start(self):
        self._terminated = Event()
        t = Thread(target=self._bootstrap)

        t.daemon = True
        t.start()

    def _bootstrap(self):
        try:
            self.run()
        except WorkerExit:
            pass
        finally:
            self._terminated.set()

    def join(self):
        self._terminated.wait()

    def run(self):
        raise NotImplementedError
```

Kurz erklärt: Dieser Actor (ich habe ihn BaseWorker genannt und verwende ihn in realen Projekten als Elternklasse) verwaltet zwei Datenstrukturen: `Queue` als Mailbox und `Event` als Mechanismus zum Blockieren des Hauptthreads.

Die zentrale Operation als externe Schnittstelle ist hier nur die Methode `send()`. Beachten Sie, dass **wir den Typ der übermittelten Nachrichten nicht einschränken**, was maximale Flexibilität bedeutet.

Innerhalb des Actors verwenden wir einen Thread, um die Methode `run()` in Kombination mit `recv()` auszuführen und die spezifische Arbeit zu erledigen. Erwähnenswert ist, dass wir ein Sentinel-Signal `WorkerExit` zum Stoppen der Aufgabe festgelegt haben. Beachten Sie, dass `WorkerExit` als Ausnahme ausgelöst wird, wenn es erkannt wird, und wir in der Ausnahmebehandlung sogar mehr tun könnten – hier beenden wir lediglich den Thread, wenn diese Ausnahme auftritt. Diese Ausnahmebehandlung wird durch `_bootstrap()` ermöglicht, das `run()` umschließt.

Basierend auf der Philosophie des Actor-Modells können wir dieses einfache Beispiel erweitern und weiter gehen.

## Zusammenfassung

Nebenläufige Programmierung erfordert eine abstraktere Denkweise als gewöhnlich und kann eine gute Praxis für das Prinzip „hohe Kohäsion, lose Kopplung“ sein.

In meiner Erkundung dieses für mich neuen Bereichs war das Actor-Modell tatsächlich ein wegweisendes Licht, das mich wirklich eingeführt hat, daher teile ich es hier. :)