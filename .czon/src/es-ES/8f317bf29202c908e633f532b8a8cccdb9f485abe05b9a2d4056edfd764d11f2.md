---
"title": "Registro de trabajo de mayo de 2020"
"summary": "Este documento es el registro de trabajo de mayo de 2020, que detalla el trabajo diario en desarrollo técnico, resolución de problemas y planificación de proyectos. Los contenidos principales incluyen: reparar una fuga de memoria cuya causa raíz era un puntero salvaje no eliminado, resuelta mediante la refactorización de NaviEventProvider; manejar excepciones en cálculos geométricos causadas por puntos duplicados en PolyLine; corregir múltiples bugs relacionados con HDMAPMDK, como errores debidos a una segmentación irracional de la línea de producción; realizar la refactorización de OSM Assembler; planificar el estado actual y los requisitos de la canalización de CI; y manejar tareas urgentes como errores en la vinculación de plazas de aparcamiento. El registro también refleja reflexiones sobre la estimación de tiempo, patrones de resolución de problemas (soluciones a corto y largo plazo), así como experiencias en entrevistas y colaboración en equipo."
"tags":
  - "Registro de trabajo"
  - "Técnico"
  - "Corrección de bugs"
  - "Fuga de memoria"
  - "Refactorización"
  - "CI"
  - "Entrevistas"
  - "Gestión de proyectos"
"date": "2020-05-01"
---

### 2020-05-06
#### Du Valid
- Usar mill
- Usar nexus-osm

#### Lluvia de ideas

### 2020-05-08
#### Problema de fuga de memoria
- La causa directa de la fuga de memoria fue no eliminar un puntero salvaje después de usar `new`.
- Después de `update current position`, el kit de mapas llamó a `prepareGuidanceData`, con el objetivo de encontrar los datos de guía más cercanos a la posición actual.
- `prepareGuidanceData` llamó a `NavInfoProviderImpl::getTrafficLights` y `NavInfoProviderImpl::getCarParks`.
- Tomando `NavInfoProviderImpl::getTrafficLights` como ejemplo, se creaban punteros de datos en `NaviEventOnPath` con `new` durante la llamada.
- Sin embargo, no se realizaba `delete`.
- También se descubrió que `DestEvent` tenía este problema.

Solución: La clave está en no permitir punteros salvajes. Se decidió refactorizar `NaviEventProvider`.
- Primero, agregar dos campos `traffic_light_events_` y `car_park_events_` en `NaviInfoProvider`.
- En `NaviInfoGenerator`, actualizar estos dos campos después de que se actualice la ruta.
- Luego, en cada llamada `get`, filtrar según la posición actual del vehículo.
- Por lo tanto, es necesario refactorizar `PathReader::getAttributes`, porque la implementación anterior solo consideraba el offset relativo al vehículo actual, y ahora se necesita una interfaz de Offset relativo al Path.

### 2020-05-09
#### Reparación y pruebas de PolyLine
El problema principal de PolyLine radica en que durante su generación podían introducirse puntos duplicados, lo que causaba una serie de problemas en los cálculos geométricos relacionados con segmentos:
1. Cálculo de vectores: dos puntos duplicados producen un vector cero.
2. Cálculo de longitud: la longitud del segmento es 0, lo que fácilmente genera problemas de NaN.

Por lo tanto, al construir PolyLine, se verifican los puntos dentro de PolyLine. Si se encuentran puntos duplicados, se lanza una excepción.

Se detectaron los siguientes problemas:
- Problema en `getEnd` de Jts.
- Problema de `normalize` en `LinearLocation` de Jts.
  ```scala
  val loc1 = new LinearLocation(0, 1, 1.0)
  val loc2 = new LinearLocation(0, 2, 0.0)

  loc1 compareTo loc2
  // la salida es -1
  ```
- Al interpolar, podrían tomarse dos puntos demasiado cercanos.

### 2020-05-11
- HDMAPMDK-1122
  No se pudo reproducir el problema de falta de líneas de borde de carretera. Se decidió no invertir más tiempo en investigar la causa.
- Media hora sobre la teoría del crecimiento metabólico.
- Refactorización de Visitor para que admita líneas con el mismo punto de inicio y fin.
- Preparé una pregunta para una entrevista.

### 2020-05-12
- Entrevistas: dos candidatos no calificaron. Reflexioné sobre cómo identificar rápidamente a los candidatos, tardé 3 horas.
- Bugfix: HDMAPMDK-1211 Problema de eliminación incorrecta de border. No se solucionó correctamente en la reparación anterior.
  Tuve una idea pero no la terminé de escribir.
- Fui al gimnasio.

### 2020-05-13
Bugfix: HDMAPMDK-1211 Encontré una solución.
- La causa raíz fue una segmentación irracional de la línea de producción.

#### Análisis de la causa
Se puede observar que la segmentación se realizó antes de que finalizara el cambio de carril (la línea central del carril aún cruzaba la línea del carril), y esta segmentación podría cruzar Rp.

Dado que la información de observación de `lane border` adjunta a los puntos de forma de `lanecenter` registra fielmente las líneas de carril a ambos lados utilizando un método de `scan line` basado en la geometría, sin filtrar según la semántica. Por lo tanto, en la posición donde la línea del carril cruza el carril, la línea central del carril que intersecta con la línea del carril registrará esa línea del carril tanto en la referencia del borde izquierdo como en la derecha.

Bajo la lógica actual del código, al filtrar las referencias de borde de las líneas de carril intersectadas según la semántica, se infiere la referencia de borde a eliminar basándose en el tipo de cambio de carril.

La lógica actual falla al enfrentarse a este tipo de segmentación, lo que provoca este problema.

#### Solución
El punto clave es **encontrar la tendencia de cambio de carril de la línea de carril intersectada**. Dado que este tipo de segmentación puede cruzar Rp, el filtrado no debe realizarse por unidad de Rp.

1. Primero, organizar las líneas de carril en paths utilizando `edge lifting` (puede considerarse para una futura refactorización del grafo): `Seq[LaneCenter]`
2. Encontrar el `LaneCenter` a corregir y el `lane border` a corregir (aquí se asume que este tipo de `LaneCenter` es necesariamente causado por un cambio de carril).
3. Calcular la tendencia de cambio de carril de ese `LaneCenter` según el path de `LaneCenter`.
4. Aplicar el filtrado.

Se lo asigné a Ziliang.

Una entrevista, el candidato no pasó.

### 2020-05-14
HDMAPMDK-1132 Seguimiento de ID del punto final de la línea de carril del poste de señalización.

El problema de seguimiento para el punto final de la línea de carril del poste de señalización es bastante simple en comparación con el seguimiento de objetos lineales, ya que solo implica el mapeo de IDs, y no el mapeo de offset y longitud.

Sin embargo, hay varios puntos a considerar:
1. Procedimiento.
2. El sistema de tipado de ID es un problema persistente que necesita ser abordado.

En esencia, la raíz de este problema es que al definir IDs usamos exclusivamente Long ID, mientras que en la definición de MDM se usan Int, lo que podría causar problemas de desbordamiento.

### 2020-05-15
#### Corrección de bugs
- HDMAPMDK-1215 Completado.
- HDMAPMDK-1218 Hecho.

### 2020-05-18
Refactoricé OSM Assembler, utilizando la serialización OSM anterior. La facilidad de comprensión del código y la facilidad de escritura mejoraron.

### 2020-05-19
Solucioné un bug en OSM Assembler (en realidad, no era exactamente un bug).

Hoy tuve la reunión de planificación del sprint:
No hay muchas cosas por hacer en este sprint, pero hay mucho en qué pensar. Este es un estado saludable.

### 2020-05-20
- [ ] Escribir documentación describiendo el estado actual de CI de nexus/mdk y los requisitos.
- [x] Revisar el bug HDMAPMDK-1263
  - Efectivamente era un problema de segmentación de la línea de producción.
- [ ] Concertar reunión con Yang Chuan para discutir CI.
- [ ] HDMAPMDK-1262
  No terminado.
- [x] Problema de Custom Speed Limit.

### 2020-05-21
#### TAREAS
- [x] Saludar a Qiaobo.
- [x] HDMAPMDK-1262.
- [x] HDMAPMDK-755.

#### TRABAJOS
- Por la mañana fui al área de trabajo de Yiming para hacer debug en línea del hotfix de ayer. El resultado se debió a un problema de offset. Ayer lo escribí con demasiada prisa y no agregué ninguna prueba. Este tipo de comportamiento no debería repetirse. Pensé que ahorraba mucho tiempo, **pero al final perdí más tiempo**.
- La razón por la que 1262 no obtenía datos era que MDK no cargaba las marcas viales a nivel de carril (ni los obstáculos viales).
- Ayudé al hermano Du a compilar datos.

### 2020-05-22
¿Qué hice este día???
¿Qué hice???

### 2020-05-25
Hoy recibí una nueva tarea: HDMAPMDK-1249 - Investigar métodos para calcular la agregación de carriles utilizando información geométrica de la carretera. Esto aumentó un poco las tareas de esta semana. Hasta ahora, todavía tengo tres cosas por hacer:

1. 1249
2. Estado actual, requisitos y plan para la canalización de CI del equipo.
3. Refactorización del grafo de Nexus.

Cada una es algo que requiere una cuidadosa conceptualización y no es fácil. Lamentablemente, no puedo estimar claramente el tiempo para cada una. Solo Weiyu estima y escribe los puntos de historia en las tareas de Jira. Una cosa tengo clara: **si no empiezo a estimar y revisar, nunca estimaré con precisión**. Así que a partir de ahora voy a estimar cuidadosamente.

Además, planeo empezar con 1249 hoy, porque es un asunto de negocio y generalmente es más urgente, y a Weiyu también le importará más esto. En cuanto a la refactorización, si no me preocupo yo mismo, probablemente a nadie más le importará (porque, cruelmente, no afecta la funcionalidad, pero sí la eficiencia, y la eficiencia es lo más difícil de medir, incluso yo solo tengo análisis cualitativos).

### 2020-05-26
Hoy hubo muchos imprevistos. Primero, parking reportó dos bugs, originalmente planeados para entrega hoy. Debido a estos bugs, no se pudo entregar hoy. Wang Wei negoció con los equipos posteriores y pospuso la entrega dos días hasta pasado mañana, así que mi trabajo principal estos dos días se convirtió en resolver bugs. Esto me hizo reflexionar sobre si la planificación durante la entrega es razonable. Luego está el problema HDMAPMDK-1290.

Lo que hice hoy:
- Seguimiento de HDMAPMDK-1290: Cuando se está extremadamente cerca de la línea de parada, el offset del carril coincidente puede ser mayor que la longitud del carril.
  > Pasé todo el día investigando y tratando de resolver este problema (actualmente son las 8:56 p.m.), con una eficiencia muy baja.

  La razón esencial es que MDK calcula la longitud sumando la distancia entre cada dos puntos y luego aplicando una transformación de coordenadas. Aunque esto es más preciso, hace que el resultado sea muy incierto.

  Finalmente, usé una solución algo improvisada: si el offset calculado es mayor que la longitud, solo se toma la longitud.
- HDMAPMDK-1297 Error en la vinculación de plazas de aparcamiento.
  Aunque se acercaba la hora de salida original (9 p.m.), ¡hoy tenía que al menos analizar este problema!
  Vaya, lo solucioné. Resultó ser un problema simple.

### 2020-05-27
Hoy, si no hay imprevistos, debo terminar lo de la canalización de CI.

Pero hubo imprevistos - -

Recibí bugs reportados por Yiming:
1. Vinculación de semáforos: Un semáforo que debería estar vinculado a un área de espera se vinculó a la partición anterior al área de espera. Ya reparado (1.5h).
2. Falta de vinculación de semáforos: No se pudo reproducir.
  Actualización: Después de una ronda difícil de debug, finalmente encontré el problema. Durante la compilación, la geometría utilizada para vincular rc con offset no era la misma línea, lo que causaba que el offset excediera la longitud de la carretera, por lo que no se encontraba el semáforo (2h).

### 2020-05-28
Mañana tengo el examen práctico de conducir (科二). Hoy practiqué conducción todo el día, regresé a las 5 p.m. Me sentí bastante bien, espero aprobar mañana.

Empecé con la descripción del estado actual y el análisis de requisitos de la canalización de CI - -

### 2020-05-29
Resultado: No aprobé. Ay, es muy difícil para mí.

Por la mañana fui al examen. Por la tarde hice algunas cosas.

1. Fui donde Yiming a revisar una situación anómala, resultaron ser dos bugs.
2. Después del townhall, sincronicé sobre el enlace (binding) de Python para MDK.
3. Fui con Shanle y Weiyu a resolver un problema de los equipos posteriores. Finalmente resumimos en una solución a corto plazo y una a largo plazo.

Descubrí que al enfrentar problemas imprevistos, el método para resolverlos generalmente debería seguir este patrón:
Una solución a corto plazo y una a largo plazo. Porque el valor expuesto por un problema es limitado y tiene una temporalidad. Por lo tanto, la solución a corto plazo se centra en resolver la urgencia de manera rápida y precisa. ¿Es necesaria la solución a largo plazo? Generalmente sí, porque un caso particular de un problema refleja un punto ciego previamente no considerado en las soluciones. Analizar la causa del problema y resolverlo sistemáticamente permite que este tipo de problemas se resuelvan bien en el futuro, haciendo que la solución original sea más completa. También hay casos donde no se necesita una solución a largo plazo: cuando **después de un análisis exhaustivo** concluimos que el costo de resolver el problema sistemáticamente es mayor que el beneficio. (Incluso así, en la mayoría de los casos, subjetivamente queremos resolverlo sistemáticamente. Como ingenieros, ¿quién no quiere resolver los problemas de manera sistemática? Pero esto también deja una trampa, que puede llevar a las personas a resolver cosas importantes pero no urgentes, o cosas ni importantes ni urgentes, desperdiciando así un tiempo valioso que podría usarse para resolver otros problemas de mayor valor).

4. Por la noche, continué con lo de la canalización de CI.