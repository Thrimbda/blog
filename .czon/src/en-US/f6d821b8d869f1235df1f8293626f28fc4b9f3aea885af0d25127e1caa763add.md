---
"title": "A Second Look at Concurrency (Actor)"
"summary": "This article delves into the limitations of shared message queues in concurrent programming, pointing out that in systems requiring asynchronous work among different workers, shared queues can lead to issues such as inability to send messages to specific targets, timing disorder, and inefficiency. The author analyzes the shortcomings of gradually introduced solutions like identifiers and replay mechanisms, ultimately proposing the Actor model as a fundamental solution. The article explains in detail the concepts of the Actor model, including its core features like parallel execution, message decoupling, and address-based communication, and provides an example implementation using Python threads. The conclusion emphasizes that concurrent programming requires abstract thinking, and the Actor model serves as an effective guide for entering the field of concurrency."
"tags":
  - "python"
  - "concurrency"
  - "Actor model"
  - "message queue"
  - "asynchronous programming"
  - "thread communication"
"date": "2017-05-19"
---

---
title: A Second Look at Concurrency (Actor)
date: 2017-05-19
taxonomies:
  tags:
    - python
    - concurrency
---

[Last time](http://0xc1.space/2017/05/06/初探并发/), we discussed using message queues to pass messages between threads (or processes) to achieve inter-thread communication.

<!--more-->

## Shared Message Queue

This approach is based on the assumption that **concurrency is only about improving system throughput**. Under this assumption, every worker performs the same tasks, so they can share a single message queue—it doesn't matter who picks up the next instruction.

### What If We Aren't Siblings?

What if we need to implement a system where each worker performs different tasks asynchronously (like our IP-phone)? If we still use the above method with all workers sharing a single message queue, problems arise: messages cannot be sent to specific workers.

How do we solve this? A simple and crude solution is to add an identifier to each message, indicating the intended recipient:

```python
queue = Queue([('Send_to_worker_A', 'do_something1'),
               ('Send_to_worker_B', 'do_something2'),
               ('Send_to_worker_B', 'do_something3'),
               ('Send_to_worker_C', 'do_something4'),
               ('Send_to_worker_A', 'do_something5')])
```

It seems the problem is solved, right? But we've introduced a new issue.

### What If I Accidentally Open Someone Else's Letter?

If a message intended for worker A is received by worker B, it's useless to worker B, while worker A, who should have received it, doesn't get it. This results in message loss. It wastes worker B's time, consumes worker A's resources, and could even cause the entire system to fall into some bizarre bug due to skipped steps.

How do we solve this problem? Intuitively, adding the following strategy to each worker seems to fix it: if a worker receives someone else's message, put it back into the message queue.

```python
class Worker_B:
    
    def run(self):
        while True:
            if not self.queue.empty():
                data = self.queue.get()
                if data['to_whom'] == 'worker_B':
                    do_something_with_data
                else:
                    self.queue.put(data)
```

It seems like patching fixes the problem... but in reality, it introduces yet another issue.

### This Looks Like a Dead End

First, a message queue is a queue, meaning FIFO (First-In-First-Out). Even if we introduce a priority message queue, this fundamental characteristic doesn't change. As a result, a message originally intended to be the first delivered to worker A, after being handled by worker B, becomes the last in the queue for worker A. This could cause the system to fall into a bizarre bug.

Second, even if we manage to reinsert misdelivered messages back to the front of the queue, without introducing a locking mechanism to make worker B's `receive-check-return` operation atomic, other workers might continue receiving messages while worker B is performing the return operation. This could still lead to significant timing issues. Introducing a locking mechanism can solve logical errors, but it would allow only one worker to actually work during each polling cycle. Other workers that receive wrong messages and perform the `receive-check-return` operation would waste their time slices, **resulting in inefficiency**.

Therefore, for systems introducing concurrency for asynchronous work, having all workers share a single message queue doesn't seem like a good approach.

The fundamental solution to this problem is to create a dedicated message queue (mailbox) for each group of workers performing the same task, or even assign each worker its own message queue, completely abandoning shared memory between threads. The latter approach is the protagonist of today's discussion: **the Actor model (Participant Pattern)**.

## Actor Model

First, let's look at Wikipedia's definition and concepts of the Actor model:

### Concepts

In computer science, the Actor model is a model for concurrent computation. An "actor" is an abstract concept in programming, regarded as the fundamental unit of concurrent computation: when an actor receives a message, it can make decisions, create more actors, send more messages, and determine how to respond to subsequent messages. The Actor model was proposed in a 1973 paper by Carl Hewitt, Peter Bishop, and Richard Steiger.

The philosophy promoted by the Actor model is "everything is an actor," similar to object-oriented programming's "everything is an object." However, object-oriented programming is typically sequential, while the Actor model is parallel. An actor is a computational entity that responds to received messages and can perform the following operations in parallel:

- Send a finite number of messages to other actors;
- Create a finite number of new actors;
- Specify the behavior for the next received message.

These operations do not assume sequential execution, so they can be performed concurrently. The decoupling of the sender from the sent message is the fundamental advantage of the Actor model. This allows for asynchronous communication while satisfying the control structure of message passing. Message recipients are distinguished by addresses, sometimes called "mail addresses." Therefore, an actor can only communicate with actors whose addresses it possesses. It can obtain addresses from received messages or from the actors it creates. The characteristics of the Actor model include parallel computation within or between actors, dynamic creation of actors, addresses included in messages, interaction only through direct asynchronous message communication, and no restrictions on the order of message arrival.

### Implementation

Actors are simple enough, born for concurrency, and have sufficient encapsulation to isolate changes (e.g., not caring whether it's multithreaded or multiprocess).

Let's look at a typical Python thread implementation of an Actor:

```python
from queue import Queue
from threading import Thread, Event


class WorkerExit(Exception):
    # Exception used to terminate tasks
    pass


class BaseWorker(object):
    # Actor
    def __init__(self):
        self._mailbox = Queue()
        super(BaseWorker, self).__init__()

    def send(self, msg):
        self._mailbox.put(msg)

    def recv(self):
        msg = self._mailbox.get()
        if msg is WorkerExit:
            raise WorkerExit()
        return msg

    def close(self):
        self.send(WorkerExit)

    def start(self):
        self._terminated = Event()
        t = Thread(target=self._bootstrap)

        t.daemon = True
        t.start()

    def _bootstrap(self):
        try:
            self.run()
        except WorkerExit:
            pass
        finally:
            self._terminated.set()

    def join(self):
        self._terminated.wait()

    def run(self):
        raise NotImplementedError
```

To briefly explain, this Actor (which I named BaseWorker and use as a parent class in real projects) maintains two data structures: a `Queue` as the mailbox and an `Event` as a mechanism to block the main thread.

Here, the core operation exposed as an external interface is only the `send()` method. Note that **we do not restrict the types of messages that can be passed**, which provides immense flexibility.

Inside the Actor, we use a thread to run the `run()` method combined with the `recv()` method to perform the specified tasks. It's worth mentioning that we set a sentinel signal, `WorkerExit`, to stop tasks. Note that `WorkerExit` works by being recognized and then raised as an exception. In the exception handling, we could even do more, but here we simply stop the thread when this exception is caught. This exception handling is implemented by the `_bootstrap()` method, which wraps `run()`.

Under the philosophy of the Actor model, we can extend this simple example to go further.

## Conclusion

Concurrent programming requires a more abstract way of thinking than usual and serves as good practice for the principle of "high cohesion, low coupling."

In my exploration of this entirely new field, the Actor model has indeed been a guiding light, leading me to truly get started. Hence, I share it here. :)