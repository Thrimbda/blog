---
"title": "並行処理への初めての一歩"
"summary": "本稿では、筆者が小さな課題を通じて並行プログラミングに触れた経験を紹介します。Pythonのqueue、signal、timeモジュールを使用して、シンプルな並行制御デモを実装しました。各モジュールの役割を説明します：queueはメッセージキューとして、signalはKeyboardInterruptシグナルの捕捉に、timeはメインスレッドが割り込みを検知できるようにするために使用されます。さらに、マルチスレッドプログラミングにおけるメッセージキューの重要性、システム設計において詳細をカプセル化し、イベントを用いて協調動作させることで結合度を下げる考え方について考察し、「変化のために設計する」という理念を強調しています。"
"tags":
  - "python"
  - "並行処理"
  - "マルチスレッド"
  - "メッセージキュー"
  - "システム設計"
"date": "2017-05-07"
---

---
title: 並行処理への初めての一歩
date: 2017-05-07
taxonomies:
  tags:
    - python
    - 並行処理
---

よかったです。最近の小さな課題で、私が本当に意味のある並行プログラミングに触れる機会を得ました。

<!--more-->

## デモ

そこで、Pythonの`queue`、`signal`、そして`time`モジュールを使って、真のマルチスレッドとは言えない、説明用の小さなデモを作りました：

```python
# -*- coding: utf-8 -*-
# @Author: Michale
# @Date:   2017-05-04 15:00:41
# @Last Modified by:   Michale
# @Last Modified time: 2017-05-07 00:46:52
import signal
import queue
import time


class TestClass(object):
    queue = queue.Queue()

    def __init__(self):
        signal.signal(signal.SIGINT, self.stopIfPressKill)

    def stopIfPressKill(self, mySignal, stack):
        if mySignal == signal.SIGINT:
            print('you pressed CTRL-C')
            self.queue.put_nowait('stop')
            print(self.queue.qsize())

    def mainThread(self):
        while True:
            time.sleep(1)
            if not self.queue.empty():
                data = self.queue.get()
                print(data)
                if data == 'stop':
                    break
                else:
                    self.queue.put(data)


if __name__ == '__main__':
    yoo = TestClass()
    yoo.mainThread()

```

3つのモジュールの役割を説明します：

- `queue`：メッセージキューとして機能します。ここでは明らかに大げさな使い方です。
- `signal`：`KeyboardInterrupt`を捕捉し、停止シグナルをメッセージキューに投入するために使用します。
- `time`：メインスレッドがこの`KeyboardInterrupt`を捕捉できるようにするために使用します。

## 考え方

マルチスレッドの導入により、メインスレッド以外のスレッドは起動後に制御が難しくなるため、メッセージキューなどの方法を用いたスレッド間通信が求められるようになりました。

しかし、マルチスレッドであるかどうかに関わらず、システムの各モジュールは本来、詳細をカプセル化し、イベントを用いて協調動作させるべきです。これはシステムの結合度を下げるのに大きく役立ち、優れたシステムの設計思想でもあります：**変化のために設計する。**