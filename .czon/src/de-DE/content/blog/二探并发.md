---
"title": "Ein zweiter Blick auf Nebenläufigkeit (Actor)"
"summary": "Der Artikel diskutiert zunächst, dass in der nebenläufigen Programmierung, wenn mehrere Worker asynchron arbeiten und jeweils spezifische Aufgaben erledigen müssen, die gemeinsame Nutzung einer einzigen Nachrichtenwarteschlange zu Problemen führt: Nachrichten können nicht zielgerichtet gesendet werden, es kommt zu fehlerhaften Zustellungen und zeitlichen Abfolgeproblemen.\
  Durch schrittweise Analyse zeigt der Autor die Ineffizienz und potenziellen Fehlerquellen dieses Ansatzes auf. Anschließend wird das Actor-Modell als grundlegende Lösung eingeführt, bei dem jedem Worker eine eigene Nachrichtenwarteschlange (Mailbox) zugewiesen wird, was vollständige Nachrichtenisolierung und asynchrone Kommunikation ermöglicht. Der Artikel erläutert detailliert die Konzepte des Actor-Modells, einschließlich paralleler Ausführung, Nachrichtenübermittlung und Adressierungsmechanismen, und liefert ein Beispiel in Python mit Threads, das zeigt, wie ein grundlegender Actor (BaseWorker) aufgebaut wird. Abschließend fasst der Autor die Vorteile des Actor-Modells in der nebenläufigen Programmierung zusammen und betont seinen Wert für abstraktes Denken und die praktische Umsetzung von 'hoher Kohäsion, loser Kopplung'."
"tags":
  - "python"
  - "Nebenläufigkeit"
  - "Actor-Modell"
  - "Nachrichtenwarteschlange"
  - "Asynchrone Programmierung"
  - "Multithreading"
  - "Programmiermodell"
"date": "2017-05-19"
---

---
title: Ein zweiter Blick auf Nebenläufigkeit (Actor)
date: 2017-05-19
taxonomies:
  tags:
    - python
    - Nebenläufigkeit
---

[Beim letzten Mal](http://0xc1.space/2017/05/06/初探并发/) ging es darum, Nachrichtenwarteschlangen zu nutzen, um Nachrichten zwischen Threads (oder Prozessen) zu übermitteln und so die Kommunikation zwischen ihnen zu ermöglichen.

<!--more-->

## Die gemeinsame Nachrichtenwarteschlange

Dies basiert auf der Annahme, dass **Nebenläufigkeit lediglich den Durchsatz des Systems erhöhen soll**. Unter dieser Annahme erledigt jeder Worker die gleiche Arbeit, daher kann eine gemeinsame Nachrichtenwarteschlange genutzt werden – es spielt keine Rolle, wer den nächsten Befehl erhält.

### Was, wenn wir keine Geschwister sind?

Was ist, wenn wir ein System implementieren müssen, in dem verschiedene Worker asynchron arbeiten und jeweils spezifische Aufgaben erledigen (z.B. unser IP-Telefon)? Angenommen, wir verwenden weiterhin die oben beschriebene Methode, bei der alle Worker eine gemeinsame Nachrichtenwarteschlange nutzen. Dann entsteht ein Problem: Nachrichten können nicht an einen bestimmten Worker gesendet werden.

Wie lässt sich dieses Problem lösen? Eine einfache, aber grobe Lösung besteht darin, jeder Nachricht eine Kennung hinzuzufügen, die den Empfänger angibt:

```python
queue = Queue([('Send_to_worker_A', 'do_something1'),
               ('Send_to_worker_B', 'do_something2'),
               ('Send_to_worker_B', 'do_something3'),
               ('Send_to_worker_C', 'do_something4'),
               ('Send_to_worker_A', 'do_something5')])
```

Sieht so aus, als wäre das Problem gelöst, oder? Aber wir haben ein neues Problem eingeführt.

### Was, wenn ich versehentlich den Brief für jemand anderen öffne?

Wenn eine Nachricht für Worker A von Worker B empfangen wird, ist sie für diesen nutzlos. Der eigentlich vorgesehene Empfänger, Worker A, erhält sie nicht, und die Nachricht geht verloren. Das verschwendet nicht nur die Zeit von Worker B, sondern auch die von Worker A und kann das System aufgrund von Sprüngen in eine seltsame Fehlersituation bringen.

Wie lässt sich dieses Problem lösen? Intuitiv betrachtet scheint folgende Strategie für jeden Worker das Problem zu beheben: Wenn man eine Nachricht für jemand anderen erhält, legt man sie einfach wieder in die Warteschlange zurück.

```python
class Worker_B:
    
    def run(self):
        while True:
            if not self.queue.empty():
                data = self.queue.get()
                if data['to_whom'] == 'worker_B':
                    do_something_with_data
                else:
                    self.queue.put(data)
```

Es sieht so aus, als hätten wir das Problem mit Flickwerk gelöst... aber tatsächlich haben wir ein neues Problem eingeführt.

### Das scheint eine Sackgasse zu sein

Erstens ist eine Nachrichtenwarteschlange eine Warteschlange, was FIFO (First In, First Out) bedeutet. Selbst wenn wir eine priorisierte Warteschlange einführen, ändert sich dieser grundlegende Umstand nicht. Dadurch wird die Nachricht, die eigentlich als erste an Worker A gehen sollte, nach dem Hin- und Herschieben durch Worker B zur letzten in der Warteschlange für Worker A. Das kann das System in eine seltsame Fehlersituation bringen.

Zweitens: Selbst wenn wir es schaffen, fehlgeleitete Nachrichten wieder an den Anfang der Warteschlange zu setzen, kann es – wenn wir keinen Sperrmechanismus einführen, der den Vorgang `Empfangen-Prüfen-Zurücklegen` von Worker B zu einem atomaren Vorgang macht – passieren, dass andere Worker bereits weiter Nachrichten empfangen, während Worker B die Nachricht zurücklegt. Das kann immer noch zu erheblichen Problemen in der zeitlichen Abfolge führen. Die Einführung eines Sperrmechanismus würde zwar die logischen Fehler beheben, aber dazu führen, dass in jedem Abfragezyklus nur ein Worker tatsächlich arbeiten kann, während andere, die eine falsche Nachricht erhalten und den `Empfangen-Prüfen-Zurücklegen`-Vorgang ausführen, ihre Zeitscheibe verschwenden – **ineffizient**.

Daher scheint die gemeinsame Nutzung einer einzigen Nachrichtenwarteschlange durch alle Worker für Systeme, die Nebenläufigkeit für asynchrone Arbeit einführen, keine gute Lösung zu sein.

Die radikale Lösung für dieses Problem besteht darin, für jede Gruppe von Workern, die die gleiche Aufgabe ausführen, eine eigene dedizierte Nachrichtenwarteschlange (Mailbox) einzurichten, oder sogar für jeden Worker eine eigene. Damit wird die Fähigkeit der Threads, Speicher gemeinsam zu nutzen, vollständig aufgegeben. Die letztere Methode ist der heutige Hauptdarsteller: **das Actor-Modell (Akteur-Modell)**.

## Das Actor-Modell

Schauen wir uns zunächst die Definition und Konzepte des Actor-Modells laut Wikipedia an:

### Konzept

In der Informatik ist das Actor-Modell (englisch: Actor model) ein Modell für nebenläufige Berechnungen. Ein "Akteur" (Actor) ist ein programmatisches Abstraktionskonzept, das als grundlegende Einheit nebenläufiger Berechnung betrachtet wird: Wenn ein Akteur eine Nachricht empfängt, kann er Entscheidungen treffen, weitere Akteure erstellen, weitere Nachrichten senden und festlegen, wie er auf die nächste Nachricht reagieren wird. Das Actor-Modell wurde 1973 in einem Artikel von Carl Hewitt, Peter Bishop und Richard Steiger vorgestellt.

Die dem Actor-Modell zugrunde liegende Philosophie ist "Alles ist ein Akteur", ähnlich dem "Alles ist ein Objekt" der objektorientierten Programmierung, jedoch ist die objektorientierte Programmierung meist sequenziell, während das Actor-Modell parallel ausgeführt wird. Ein Akteur ist eine Berechnungseinheit, die auf empfangene Nachrichten reagiert und dabei parallel:

- eine begrenzte Anzahl von Nachrichten an andere Akteure sendet;
- eine begrenzte Anzahl neuer Akteure erstellt;
- das Verhalten für den Empfang der nächsten Nachricht festlegt.

Diese Operationen enthalten keine Annahmen über eine sequenzielle Ausführung und können daher parallel durchgeführt werden. Die Entkopplung des Senders von der gesendeten Nachricht ist der grundlegende Vorteil des Actor-Modells. Dies ermöglicht asynchrone Kommunikation und erfüllt gleichzeitig die Kontrollstrukturen der Nachrichtenübermittlung. Nachrichtenempfänger werden über Adressen unterschieden, manchmal auch "Mailadressen" genannt. Daher kann ein Akteur nur mit Akteuren kommunizieren, deren Adresse er besitzt. Er kann Adressen aus empfangenen Informationen erhalten oder die Adressen der von ihm erstellten Akteure abrufen. Charakteristisch für das Actor-Modell ist, dass Berechnungen innerhalb von oder zwischen Akteuren parallel ablaufen, Akteure dynamisch erstellt werden können, Adressen in Nachrichten enthalten sind, die Interaktion ausschließlich über direkte asynchrone Nachrichtenkommunikation erfolgt und die Reihenfolge des Nachrichteneingangs nicht eingeschränkt ist.

### Implementierung

Akteure sind einfach genug, für Nebenläufigkeit geschaffen und bieten eine ausreichend gute Kapselung, um Änderungen zu isolieren (z.B. ist es egal, ob es sich um Multithreading oder Multiprocessing handelt).

Sehen wir uns eine typische Python-Thread-Implementierung eines Akteurs an:

```python
from queue import Queue
from threading import Thread, Event


class WorkerExit(Exception):
    # Exception zum Beenden der Aufgabe
    pass


class BaseWorker(object):
    # Actor
    def __init__(self):
        self._mailbox = Queue()
        super(BaseWorker, self).__init__()

    def send(self, msg):
        self._mailbox.put(msg)

    def recv(self):
        msg = self._mailbox.get()
        if msg is WorkerExit:
            raise WorkerExit()
        return msg

    def close(self):
        self.send(WorkerExit)

    def start(self):
        self._terminated = Event()
        t = Thread(target=self._bootstrap)

        t.daemon = True
        t.start()

    def _bootstrap(self):
        try:
            self.run()
        except WorkerExit:
            pass
        finally:
            self._terminated.set()

    def join(self):
        self._terminated.wait()

    def run(self):
        raise NotImplementedError
```

Kurz erklärt: Dieser Akteur (ich habe ihn BaseWorker genannt und verwende ihn in realen Projekten als Basisklasse) verwaltet zwei Datenstrukturen: eine `Queue` als Mailbox und ein `Event` als Mechanismus zum Blockieren des Hauptthreads.

Die zentrale Operation, die hier als externe Schnittstelle dient, ist die Methode `send()`. Beachten Sie, dass **wir den Typ der übermittelten Nachricht nicht einschränken** – das bedeutet maximale Flexibilität.

Innerhalb des Akteurs verwenden wir einen Thread, um die Methode `run()` in Kombination mit `recv()` auszuführen und die spezifische Arbeit zu erledigen. Erwähnenswert ist, dass wir ein Sentinel-Signal `WorkerExit` zum Stoppen der Aufgabe definiert haben. Beachten Sie, dass `WorkerExit` funktioniert, indem es, sobald erkannt, als Exception ausgelöst wird. Im Exception-Handler könnten wir sogar mehr tun, aber hier beenden wir einfach den Thread, wenn diese Exception gefangen wird. Diese Exception-Behandlung wird durch die Methode `_bootstrap()` ermöglicht, die `run()` umschließt.

Basierend auf der Philosophie des Actor-Modells können wir dieses einfache Beispiel erweitern und weiter gehen.

## Zusammenfassung

Nebenläufige Programmierung erfordert eine abstraktere Denkweise als gewöhnlich und kann eine gute Praxis für das Prinzip "hohe Kohäsion, lose Kopplung" sein.

In meiner Erkundung dieses für mich neuen Gebiets war das Actor-Modell tatsächlich ein wegweisendes Licht, das mich richtig eingeführt hat, daher teile ich es hier. :)