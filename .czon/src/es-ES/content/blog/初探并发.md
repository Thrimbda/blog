---
"title": "Primera Inmersión en Concurrencia"
"summary": "Este artículo describe la experiencia del autor al adentrarse en la programación concurrente a través de una pequeña tarea, utilizando los módulos `queue`, `signal` y `time` de Python para crear un demo de control concurrente con fines ilustrativos. El artículo explica el papel de estos tres módulos en el demo: `queue` actúa como cola de mensajes para pasar señales, `signal` se usa para capturar la interrupción `KeyboardInterrupt`, y `time` permite que el hilo principal responda a la interrupción de manera oportuna. El autor profundiza en la importancia de las colas de mensajes en la programación multihilo, señalando que facilitan la comunicación entre hilos y reducen el acoplamiento del sistema, y enfatiza que un buen diseño de sistema debe estar pensado para el cambio, logrando la colaboración entre módulos mediante la encapsulación de detalles y un enfoque basado en eventos."
"tags":
  - "python"
  - "concurrencia"
  - "multihilo"
  - "cola de mensajes"
  - "diseño de sistemas"
"date": "2017-05-07"
---

---
title: Primera Inmersión en Concurrencia
date: 2017-05-07
taxonomies:
  tags:
    - python
    - concurrencia
---

Muy bien, una pequeña tarea reciente me permitió adentrarme y experimentar con una programación concurrente realmente significativa.

<!--more-->

## Demo

Así que, utilizando los módulos `queue`, `signal` y `time` de Python, creé un pequeño demo ilustrativo que, en realidad, no es verdaderamente multihilo:

```python
# -*- coding: utf-8 -*-
# @Author: Michale
# @Date:   2017-05-04 15:00:41
# @Last Modified by:   Michale
# @Last Modified time: 2017-05-07 00:46:52
import signal
import queue
import time


class TestClass(object):
    queue = queue.Queue()

    def __init__(self):
        signal.signal(signal.SIGINT, self.stopIfPressKill)

    def stopIfPressKill(self, mySignal, stack):
        if mySignal == signal.SIGINT:
            print('you pressed CTRL-C')
            self.queue.put_nowait('stop')
            print(self.queue.qsize())

    def mainThread(self):
        while True:
            time.sleep(1)
            if not self.queue.empty():
                data = self.queue.get()
                print(data)
                if data == 'stop':
                    break
                else:
                    self.queue.put(data)


if __name__ == '__main__':
    yoo = TestClass()
    yoo.mainThread()

```

Explicando el papel de los tres módulos:

-   `queue`: Actúa como una cola de mensajes, aunque aquí su uso es un poco excesivo para la tarea.
-   `signal`: Se utiliza para capturar `KeyboardInterrupt` y luego colocar la señal de parada en la cola de mensajes.
-   `time`: Permite que el hilo principal pueda capturar este `KeyboardInterrupt`.

## Concepto

La introducción de la programación multihilo hace que sea difícil controlar los hilos no principales una vez que se inician, lo que obliga a utilizar métodos como las colas de mensajes para lograr la comunicación entre hilos.

Pero, en realidad, independientemente de si se trata de múltiples hilos o no, los distintos módulos de un sistema deberían encapsular sus detalles internos y utilizar eventos para colaborar entre sí. Esto es de gran ayuda para reducir el acoplamiento del sistema y representa el principio de diseño de un buen sistema: **Diseñado para el cambio.**