---
"title": "2020年5月 作業ログ"
"summary": "本文は2020年5月の作業ログであり、技術開発、問題解決、プロジェクト計画に関する日々の業務を詳細に記録しています。主な内容は以下の通りです：メモリリーク問題の修正（原因は未削除のダングリングポインタにあり、NaviEventProviderのリファクタリングにより解決）、PolyLineの重複点による幾何計算異常への対応、HDMAPMDK関連の複数のバグ修正（例：産線分割の不合理によるエラー）、OSM Assemblerのリファクタリング、CIパイプラインの現状と要件の計画、および駐車スペースの誤ったバインディングなどの突発的なタスクへの対応。また、時間見積もり、問題解決パターン（短期および長期ソリューション）に関する考察、ならびに面接やチームコラボレーションの経験についても記述しています。"
"tags":
  - "作業ログ"
  - "技術"
  - "バグ修正"
  - "メモリリーク"
  - "リファクタリング"
  - "CI"
  - "面接"
  - "プロジェクト管理"
"date": "2020-05-01"
---

### 2020-05-06
#### Du Valid
- millを使用
- nexus-osmを使用

#### ブレインストーミング

### 2020-05-08
#### メモリリーク問題
- メモリリーク問題の直接原因は、ダングリングポインタをnewした後にdeleteしなかったことです。
- update current positionの後、map kitがprepareGuidanceDataを呼び出し、現在位置から最も近いガイダンスデータを見つけることを目的としています。
- prepareGuidanceDataはNavInfoProviderImpl::getTrafficLights & NavInfoProviderImpl::getCarParksを呼び出します。
- NavInfoProviderImpl::getTrafficLightsを例にとると、呼び出し時にNaviEventOnPath内のデータポインタをnewしています。
- しかし、deleteされていません。
- DestEventにも同様の問題があることを発見しました。

解決策：核心はダングリングポインタを存在させないことであり、NaviEventProviderのリファクタリングを行うことを決定しました。
- まず、NaviInfoProviderに二つのフィールドtraffic_light_events_ & car_park_events_を追加します。
- NaviInfoGeneratorで、route updatedの後にこれら二つのフィールドを更新します。
- その後、各get時に現在の車両位置に基づいてフィルタリングを行います。
- そのため、`PathReader::getAttributes`をリファクタリングする必要があります。理由は、以前の実装では現在の車両に対するオフセットのみを考慮していましたが、現在はPathに対するオフセットインターフェースが必要だからです。

### 2020-05-09
#### PolyLineの修正およびテスト
PolyLineの問題は主に、PolyLine生成時に重複点が与えられる可能性があり、それによりセグメントに関連する一連の幾何計算に問題が生じることです：
1. ベクトル計算：二つの重複点からゼロベクトルが計算される。
2. 長さ計算：セグメント長が0になり、NaN問題が発生しやすい。

そこで、PolyLine構築時にPolyLine内の点を検査し、重複点が発見された場合は例外をスローするようにしました。

以下の問題を検出しました：
- JtsのgetEndに問題が発生。
- JtsのLinearLocationにはnormalizeの問題が存在する。
  ```scala
  val loc1 = new LinearLocation(0, 1, 1.0)
  val loc2 = new LinearLocation(0, 2, 0.0)

  loc1 compareTo loc2
  // 出力は -1
  ```
- Interpolate時に、二つの点が近すぎる場合がある。

### 2020-05-11
- HDMAPMDK-1122
  道路縁石線の欠落問題は再現せず、原因調査にこれ以上時間を費やさないことを決定。
- 代謝成長論を30分間学習。
- Visitorをリファクタリングし、同一始点・終点のラインをサポートするようにした。
- 面接課題を一つ準備。

### 2020-05-12
- 面接：二人の候補者ともに不合格。候補者を迅速に見極める方法について考察（3時間を要した）。
- バグ修正: HDMAPMDK-1211 誤ったボーダーの削除問題。前回の修正では成功しなかった。
  解決策のアイデアはあるが、書き終えていない。
- ジムに行った。

### 2020-05-13
バグ修正: HDMAPMDK-1211 解決策を思いつく。
- 根本原因は産線分割の不合理にあった。

#### 原因分析
車線変更が終了する前（車線中心線が車線境界線を横断している最中）に分割が行われており、かつこの分割はRpをまたぐ可能性があることが分かります。

lanecenterの形状点に付随するlane borderの観測情報は、幾何形状に忠実に、スキャンライン方式を用いて両側の車線境界線を記録しており、意味情報に基づくフィルタリングは行われていません。そのため、車線境界線が車線を横断する位置では、車線境界線と交差する車線中心線が、その車線境界線を左右両方のlane border refに同時に記録してしまいます。

既存のコードロジックでは、交差する車線境界線のborder refを意味情報に基づいてフィルタリングする際に、車線変更タイプに基づいて削除すべきborder refを推論します。

しかし、現在のロジックはこの種の分割に遭遇すると機能せず、この問題を引き起こします。

#### 解決策
核心は、**交差する車線境界線の車線変更傾向を見つける**ことです。この種の分割がrpをまたぐ可能性を考慮し、フィルタリングはrp単位で行うべきではありません。

1. まず、edge liftingを使用して車線境界線をpath（将来のgraphリファクタリングを考慮して）: Seq[LaneCenter]として構成する。
2. 修正対象のlane Center、および修正対象のlane borderを見つける（ここでは、この種のlane Centerは必ず車線変更によるものと仮定する）。
3. laneCenter pathに基づいて、そのLaneCenterの車線変更傾向を計算する。
4. フィルタリングを行う。

子良に任せた。

面接一人、不合格。

### 2020-05-14
HDMAPMDK-1132 ポール標識の車線境界線端点のIDトレーシング

ポール標識の車線境界線端点が直面するトレーシング問題は、線形オブジェクトのトレーシングと比較して非常に単純で、オフセットや長さのマッピングはなく、IDのマッピングのみが存在します。

しかし、考慮すべき問題も少なくありません：
1. 手順（Procedure）
2. IDタイピングシステムは頑固な問題であり、対処法を考える必要がある。

本質的にこの問題の根源は、IDを定義する際にすべてLong Idを使用しているのに対し、MDMの定義ではIntを使用しており、オーバーフロー問題を引き起こす可能性が高いことにあります。

### 2020-05-15
#### バグ修正
- HDMAPMDK-1215 完了
- HDMAPMDK-1218 完了

### 2020-05-18
OSM Assemblerをリファクタリングし、以前のOSM serializeを使用した。コードの理解のしやすさと記述の容易さがともに向上した。

### 2020-05-19
OSM Assemblerのバグを一つ解決（実際にはバグとは言えないかもしれない）。

今日はスプリントプランニング会議を開催：
今スプリントで行うことは多くないが、考えるべきことは多い。これは健全な状態である。

### 2020-05-20
- [ ] 現在のnexus/mdk CIの状態と要件を説明するドキュメントを作成。
- [x] HDMAPMDK-1263 バグを注視。
  - 確かに産線分割の問題であった。
- [ ] 楊川とCIについて話し合う会議を設定。
- [ ] HDMAPMDK-1262
  完了せず。
- [x] Custom Speed Limitの問題。

### 2020-05-21
#### やることリスト
- [x] 喬波に挨拶。
- [x] HDMAPMDK-1262
- [x] HDMAPMDK-755

#### 作業内容
- 朝、鎰銘の作業区で昨日のホットフィックスのオンラインデバッグを行った。結果はオフセットが原因だった。昨日書いた時はあまりに急ぎすぎており、まったくテストを追加していなかった。このような行為は二度と起こすべきではない。多くの時間を節約したつもりが、**結果的にはより多くの時間を浪費してしまった**。
- 1262でデータが取得できない原因は、MDKがlane levelのroad mark（およびroad obstacle）をロードしていないため。
- 杜さんのためにデータをコンパイルした。

### 2020-05-22
この日、私は何をした？？？？
私は何をしたんだろう？？？？

### 2020-05-25
今日、新しいタスクを受領：HDMAPMDK-1249-道路幾何情報を使用してlane aggregationを計算する方法の調査。これにより今週のタスクが少し増え、現時点でやるべきことが三つあります：

1. 1249
2. チーム内CIパイプラインの現状、要件、および方針
3. Nexus graphのリファクタリング

どれも慎重に構想を練る必要があり、簡単なことではありませんが、残念ながら各々について明確に時間を見積もることはできません。すべて威宇が推定し、jiraタスクのストーリーポイントに記入しています。一つはっきりしていることがあります：**私自身が見積もりと振り返りを始めなければ、永遠に正確に見積もることはできない**。ですから、今回からは注意深く見積もることにします。

また、今日から1249に取り掛かる計画です。業務上のことなので、一般的により緊急性が高く、威宇もより気にかけるでしょう。リファクタリングに関しては、私自身が真剣に取り組まなければ、おそらく誰も気に留めないでしょう（機能に影響せず、効率に影響するからです。そして効率は最も測定が難しく、私自身も定性的な分析しか持っていません）。

### 2020-05-26
今日は突発的なことが多く、まずparkingで二つのバグが報告され、本日納品予定でしたが、これらのバグのために納品できなくなりました。王維が下流と相談し、納期を明後日まで二日間延期しました。そのため、ここ二日間の主な作業はまたバグ解決に変わりました。納品時のスケジューリングが適切だったかどうか考えさせられます。次に、HDMAPMDK-1290の問題がありました。

今日完了したこと：
- HDMAPMDK-1290のフォローアップ：stop lineに極めて接近した場合、matchしたlane offsetがlane lengthより長くなる。
  > この問題を調査し、解決策を考えるのに丸一日を費やしました（現在時刻 20:56）。非常に非効率でした。

  本質的な原因は、MDKが長さを計算する際、二点間の長さを計算するたびにcoordinate transformを行うため、より正確ではあるものの、結果に極めて強い不確定性が生じることです。

  最終的に、一種のハック的な方法を使用：計算されたoffsetが長さより長い場合は、長さのみを採用する。
- HDMAPMDK-1297 駐車スペースの誤ったバインディング
  定時退社時間（21時）が近づいていましたが、私は今日中に少なくともこの問題を分析し終えなければなりません！
  ああ、解決しました。結果は単純な問題でした。

### 2020-05-27
今日は予定通り、CIパイプラインの作業を完了させる予定でした。

結果は予想外でした - -

鎰銘からフィードバックされたバグ：
1. 信号機のバインディング：待機エリアにバインドされるべき信号機が、待機エリア前のpartitionにバインドされていた。修正済み（1.5時間）。
2. 信号機のバインディング漏れ：再現できず。
  更新：困難なデバッグを経て、ようやく問題の所在を発見。コンパイル時にrcとoffsetをバインドする際に使用したgeometryが同一の線ではなかったため、offsetがroadの長さを超え、traffic lightが見つからなかった（2時間）。

### 2020-05-28
明日は学科試験第二段階（科二）の試験です。今日は一日中教習所で練習し、午後5時に戻りました。調子は良かったです。明日は合格できることを願います。

CIパイプラインの現状説明と要件分析を開始しました - -

### 2020-05-29
結果は不合格でした。ああ、本当に難しい。

朝は試験に行き、午後にいくつかの作業を行いました。

1. 鎰銘のところで異常な状況を一つ確認しに行き、結果は二つのバグでした。
2. 午後のタウンホールの後、MDK python bindingについて情報を共有しました。
3. 単楽、威宇と一緒に階下に行き、下流の問題を解決し、最終的に短期ソリューションと長期ソリューションを一つずつまとめました。

突発的な問題に遭遇した場合、一般的に問題解決の方法はこのパターンになることに気づきました：
短期ソリューションと長期ソリューション。なぜなら、問題が露呈する価値は一定であり、かつ時限性があるからです。したがって、短期ソリューションは迅速かつ正確に当面の急務を解決することに焦点を当てます。では、長期ソリューションは必要でしょうか？一般的には必要です。なぜなら、一つの問題の特例は、以前考慮されていなかった解決策の盲点を反映しており、問題の原因を分析し、体系的に解決することで、この種の問題が今後も適切に解決されるようにし、元の解決策をより完全なものにするからです。長期ソリューションが不要な場合もあります。それは、この問題を**徹底的に分析した後**、この問題を体系的に解決するコストが利益を上回ると判断した場合です。（たとえそうであっても、ほとんどの場合、主観的には体系的に解決したいと思うものです。エンジニアとして、誰が体系的に問題を解決したくないでしょうか？しかし、これには罠も残されており、重要だが緊急ではないこと、あるいは重要でも緊急でもないことに時間を費やし、他のより価値のある問題を解決するために使える貴重な時間を浪費する可能性があります。）

4. 夜、戻ってからCIパイプラインの作業を続けました。