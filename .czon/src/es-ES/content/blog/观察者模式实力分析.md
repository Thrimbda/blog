---
"title": "Análisis de la Fuerza del Patrón Observador"
"summary": "Este artículo presenta primero los conceptos básicos del patrón observador (también conocido como patrón publicación-suscripción), su definición según GoF y sus aplicaciones en el mundo real (como las suscripciones RSS). Explica en detalle los participantes del patrón observador (Subject, Observer, ConcreteSubject, ConcreteObserver) y los escenarios de aplicación (por ejemplo, cuando existe una relación de dependencia entre objetos, o cuando un cambio en un objeto requiere cambios simultáneos en otros). Luego, tomando como ejemplo Action y ActionListener en J2EE, el artículo muestra, a través de un ejemplo concreto de código Java Swing, cómo se aplica el patrón observador en el paradigma MVC para reducir el acoplamiento entre el modelo y la vista. Señala que, en comparación con las llamadas a funciones ordinarias y las funciones de retorno de llamada (callbacks), el patrón observador puede mantener la consistencia entre objetos a bajo costo, lograr un efecto de difusión (broadcast) y mejorar la reutilización del código."
"tags":
  - "Patrones de Diseño"
  - "Patrón Observador"
  - "J2EE"
  - "ActionListener"
  - "Análisis y Diseño de Sistemas"
  - "MVC"
  - "Java"
"date": "2017-04-10"
---

---
title: Análisis de la Fuerza del Patrón Observador
date: 2017-04-10
taxonomies:
  tags:
    - Patrones de Diseño
    - Análisis y Diseño de Sistemas
---

> En general, en el análisis y diseño orientado a objetos existen tres mecanismos para el manejo de eventos: además de las llamadas a funciones ordinarias, a menudo se utilizan funciones de retorno de llamada (callbacks), y J2EE también proporciona un mecanismo de manejo de eventos basado en escuchas (listeners). Consulta la documentación, analiza el mecanismo de Action y ActionListener, y completa un ejemplo de análisis.

Primero, comprendamos el patrón observador.

<!--more-->

## Patrón Observador (Observer Pattern)

### El Observador en el Mundo Real

El patrón observador también se conoce como patrón publicación-suscripción. Por ejemplo, en las suscripciones RSS (el padre de las notificaciones push de WeChat), cuando el autor de un blog (el sujeto observado) actualiza una entrada, el lector (el observador) de los suscriptores recibe automáticamente la actualización. Este esquema de publicación-suscripción lo llamamos patrón observador.

### El Patrón Observador

La descripción del patrón observador por el **G**rupo de **C**uatro (**G**ang **O**f **F**our):

> - Intención
>
>   Definir una relación de dependencia uno-a-muchos entre objetos, de modo que cuando un objeto cambie de estado, todos los objetos que dependen de él sean notificados y se actualicen automáticamente.
>
> - Alias
>
>   Dependientes (Dependents), Publicación-Suscripción (Publish-Subscribe)
>
> - Motivación
>
>   Un efecto secundario común de dividir un sistema en una serie de clases que cooperan entre sí es la necesidad de mantener la consistencia entre los objetos relacionados. No queremos que las clases estén fuertemente acopladas para mantener la consistencia, ya que esto reduce su reutilización.
>
> ...
>
> - Participantes
>
>   - Sujeto (Subject)
>
>     El sujeto conoce a sus observadores. Puede haber cualquier número de observadores observando el mismo sujeto.
>
>     Proporciona una interfaz para registrar y eliminar objetos observadores.
>
>   - Observador (Observer)
>
>     Define una interfaz de actualización para los objetos que deben ser notificados cuando el sujeto cambia.
>
>   - SujetoConcreto (ConcreteSubject)
>
>     Almacena el estado de interés para cada objeto ObservadorConcreto.
>
>     Cuando su estado cambia, notifica a todos sus observadores.
>
>   - ObservadorConcreto (ConcreteObserver)
>
>     Mantiene una referencia a un objeto SujetoConcreto.
>
>     Almacena un estado que debe ser consistente con el estado del sujeto.
>
>     Implementa la interfaz de actualización de Observer para mantener su estado consistente con el estado del sujeto.

Se puede observar que el patrón observador se aplica comúnmente en:

- Dos objetos tienen una relación de dependencia.
- Cuando un objeto cambia, es necesario cambiar otros objetos simultáneamente.

En comparación con las llamadas a funciones ordinarias y las funciones de retorno de llamada (callbacks), el uso del patrón observador permite mantener la consistencia entre objetos a bajo costo, **reduce significativamente el grado de acoplamiento entre objetos y, al mismo tiempo, puede lograr un efecto de difusión (broadcast), algo que los dos primeros no pueden hacer. El uso del patrón observador **mejora enormemente la reutilización del código**.

**Y Action y ActionListener en J2EE son un ejemplo vivo del patrón observador.**

## Action y ActionListener en J2EE

Action y ActionListener se pueden aplicar muy bien en el paradigma MVC para reducir el acoplamiento entre el modelo (model) y la vista (view).

Encontré un buen [ejemplo](http://www.ulisespulido.com/2009/03/observer-design-pattern-and-java-swing.html), cuyo código se muestra a continuación:

```java
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JTextField;

public class Frame extends JFrame {

  ActionListener observer1 = new Observer("First Observer");
  ActionListener observer2 = new Observer("Second Observer");
  ActionListener observer3 = new Observer("Third Observer");

  public Frame(){
    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    init();
  }

  private void init(){
    addChangingTextField();
    pack();
    setVisible(true);
  }

  private void addChangingTextField(){
    //Clase observable TextField. Cada vez que
    //ocurre una acción o evento, los observadores serán actualizados
    //Casi todas las clases Swing tienen este tipo de comportamiento
    JTextField dataTextField = new JTextField();

    // Registro del observador en la clase observable.
    dataTextField.addActionListener(observer1);
    dataTextField.addActionListener(observer2);
    dataTextField.addActionListener(observer3);

    add(dataTextField);
  }

  public static void main(String [] args){
  	Frame frame = new Frame();
  }
}

class Observer implements ActionListener{

  private String name;
  private String message;

  public Observer (String s){
  	name = s;
  }

  public void actionPerformed(ActionEvent e) {
    JTextField textField = (JTextField) e.getSource();
    message = textField.getText();
    JOptionPane.showMessageDialog(null,
    name + " ha sido notificado sobre el cambio, ¡Gracias!! "
    + " El mensaje fue: " + message);
  }
}
```

### Análisis

Las dos clases asumen los roles de Action/ActionListener respectivamente. `frame.dataTextField` en el método `addChangingTextField` vincula tres escuchas (`observer1`, `observer2`, `observer3`). Después de que se edita el campo de texto en el frame (cambio de estado), se dispara el método `actionPerformed` en Observer, mostrando el texto correspondiente.

En este ejemplo, `frame.dataTextField` actúa como `SujetoConcreto` (ConcreteSubject), y `observer1`, `observer2`, `observer3` actúan como `ObservadoresConcretos` (ConcreteObservers). Las interfaces que implementan, que definen los métodos Action/ActionListener, son los correspondientes `Sujeto` (Subject) y `Observador` (Observer).

Después de vincular a los observadores, el sujeto no se preocupa por el comportamiento específico de los observadores, sino que simplemente los notifica cuando su propio estado cambia, dejando que los observadores decidan qué acción tomar. Por lo tanto, este método es muy bueno, supera con creces a la forma de invocar funciones explícitamente o ejecutar funciones de retorno de llamada para desencadenar acciones, y vale la pena aprenderlo.