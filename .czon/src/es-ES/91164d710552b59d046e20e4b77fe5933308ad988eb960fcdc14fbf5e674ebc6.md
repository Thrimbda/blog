---
"title": "Configuración manual de Prometheus en un clúster de un solo nodo de K8s"
"summary": "Esta guía detallada explica cómo configurar manualmente el sistema de monitorización Prometheus en un clúster de Kubernetes de un solo nodo. Comienza describiendo el entorno de configuración, incluyendo K8s versión 1.19.3 y Prometheus versión 2.22.0, y especifica que no se utilizarán métodos de despliegue rápidos como Helm-Chart o Prometheus Operator, sino que se implementará mediante archivos de configuración YAML escritos manualmente. El contenido se divide en dos partes: prueba de concepto y monitorización del clúster. En la fase de prueba de concepto, el autor demuestra cómo ejecutar Prometheus y Node Exporter en hardware físico y modificar los archivos de configuración para monitorizar métricas propias y del nodo. En la fase de monitorización del clúster, se explican en detalle los elementos de configuración clave de Prometheus, como global, scrape_config, tls_config, etc., y se despliegan paso a paso los recursos de K8s necesarios, incluyendo Namespace, DaemonSet, ConfigMap, ServiceAccount, ClusterRole, Deployment y Service. El artículo también proporciona ejemplos de configuración específicos para diferentes objetivos de monitorización (como Prometheus mismo, Node Exporter, Kubelet, Cadvisor y ApiServer) y explica la función de relabel_config. Finalmente, el autor resume los pasos clave y las consideraciones para monitorizar un clúster de K8s mediante la implementación manual de Prometheus, ofreciendo una referencia práctica para principiantes."
"tags":
  - "Observabilidad"
  - "Prometheus"
  - "Kubernetes"
  - "Monitorización"
  - "Tecnología"
  - "Despliegue manual"
  - "Configuración"
"date": "2020-11-05"
---

> El público objetivo de este artículo son aquellos que acaban de comenzar a familiarizarse con los sistemas de monitorización, así como aquellos con poco conocimiento sobre Prometheus (tal como el autor al momento de escribir este artículo).
>
>
>
> Entorno utilizado para configurar Prometheus en este artículo:
>
> - Versión de K8s: 1.19.3
>- Versión de Prometheus: 2.22.0
> - Sistema operativo: Archlinux en 2020.11
>- Hosts configurados, el dominio de Devbox es devbox
>
> ⚠️ Nota: Los parámetros de línea de comandos enumerados en este artículo deben ajustarse ligeramente según el entorno actual (por ejemplo, la versión del paquete binario de Prometheus, etc.).
>
>
>
> Aquí se enumeran algunos elementos de lectura previa recomendados:
>
> 1. [Observabilidad: Conceptos y mejores prácticas](https://github.com/lichuan0620/k8s-sre-learning-notes/blob/master/observability/OBSV-101.md) Introduce varios conceptos básicos de observabilidad.
>2. [Conocimiento inicial de Prometheus](https://github.com/lichuan0620/k8s-sre-learning-notes/blob/master/prometheus/PROM-101.md) Presenta el proyecto Prometheus.
> 3. [Introducción del sitio web oficial de Prometheus](https://prometheus.io/docs/introduction/overview/)

## Objetivo

Dado que se trata de configurar Prometheus manualmente en K8s, establecemos aquí dos convenciones:

1. Deliberadamente no utilizaremos métodos de despliegue rápidos como Helm-Chart o Prometheus Operator, que se enumeran aquí como referencia:

   1. [Helm chart](https://github.com/prometheus-community/helm-charts) mantenido por la comunidad de Prometheus.
   2. [Prometheus Operator](https://github.com/prometheus-operator/prometheus-operator)
   3. [Kube-Prometheus](https://github.com/prometheus-operator/kube-prometheus)
3. Configurar Prometheus en K8s, es decir, que K8s sea responsable de gestionar el servicio de Prometheus. A diferencia del Prometheus Operator mencionado anteriormente, aquí escribiremos manualmente los archivos de configuración YAML relacionados.
3. Enumerar los siguientes objetivos de monitorización:
   1. Prometheus
   2. Node exporter
   3. Kubelet
   4. Cadvisor
   5. ApiServer

¡Comencemos!

<!--more-->

## Prueba de concepto: Ejecutar Prometheus en hardware físico

Primero, la intuición inicial es realizar una prueba de concepto en hardware físico, ejecutarlo primero y luego experimentar con configuraciones más avanzadas. Finalmente, una vez que comprendamos los elementos de configuración de Prometheus, desplegarlo en K8s debería ser pan comido.

> Intenté ser perezoso y buscar tutoriales en blogs, pero descubrí que no estaban claros y la mayoría estaban desactualizados, lo que me hizo perder medio día y finalmente tuve que leer la documentación oficial detenidamente.

### Instalar Prometheus

Según la [documentación](https://prometheus.io/docs/prometheus/2.22/getting_started/), descargue directamente el paquete binario precompilado correspondiente [aquí](https://prometheus.io/download/):

```bash
curl -LO "https://github.com/prometheus/prometheus/releases/download/v2.22.0/prometheus-2.22.0.linux-amd64.tar.gz"
tar -zxvf prometheus-2.22.0.linux-amd64.tar.gz
cd prometheus-2.22.0.linux-amd64
./prometheus --version
# La salida esperada debería ser similar a esta:
# prometheus, version 2.22.0 (branch: HEAD, revision: 0a7fdd3b76960808c3a91d92267c3d815c1bc354)
#  build user:    root@6321101b2c50
#  build date:    20201015-12:29:59
#  go version:    go1.15.3
#  platform:     linux/amd64
```

Al revisar el directorio, se encuentra un archivo de configuración predeterminado llamado prometheus.yml:

```yaml
# my global config
global:
 scrape_interval:   15s # Set the scrape interval to every 15 seconds. Default is every 1 minute.
 evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute.
 # scrape_timeout is set to the global default (10s).
# Alertmanager configuration
alerting:
 alertmanagers:
 - static_configs:
  - targets:
   # - alertmanager:9093
# Load rules once and periodically evaluate them according to the global 'evaluation_interval'.
rule_files:
 # - "first_rules.yml"
 # - "second_rules.yml"
# A scrape configuration containing exactly one endpoint to scrape:
# Here it's Prometheus itself.
scrape_configs:
 # The job name is added as a label `job=<job_name>` to any timeseries scraped from this config.
 - job_name: 'prometheus'
  # metrics_path defaults to '/metrics'
  # scheme defaults to 'http'.
  static_configs:
  - targets: ['localhost:9090']
```

Ahora ejecutamos el Prometheus recién descargado para que se monitorice a sí mismo, obteniendo un pequeño ciclo de retroalimentación de satisfacción:

```bash
./prometheus --config.file=prometheus.yml
```

Se puede ver que Prometheus ya se ha iniciado. Acceda a http://devbox:9090 para ver su interfaz de usuario. En este punto, explore aleatoriamente para tener una idea general de las funciones que ofrece Prometheus, permitiéndonos conocer su comportamiento cuando funciona correctamente.

### Ejecutar Node exporter

Ahora ejecutamos un Node Exporter en hardware físico para observar varias métricas de la máquina local.

```bash
curl -LO "https://github.com/prometheus/node_exporter/releases/download/v1.0.1/node_exporter-1.0.1.linux-amd64.tar.gz"
tar -zxvf node_exporter-1.0.1.linux-amd64.tar.gz
cd node_exporter-1.0.1.linux-amd64
./node_exporter
```

A continuación, modifique la configuración para que Prometheus recopile métricas desde allí:

```yaml
# my global config
global:
 scrape_interval:   15s # Set the scrape interval to every 15 seconds. Default is every 1 minute.
 evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute.
 # scrape_timeout is set to the global default (10s).
# A scrape configuration containing exactly one endpoint to scrape:
# Here it's Prometheus itself.
scrape_configs:
 # The job name is added as a label `job=<job_name>` to any timeseries scraped from this config.
 - job_name: 'prometheus'
  # metrics_path defaults to '/metrics'
  # scheme defaults to 'http'.
  static_configs:
  - targets: ['localhost:9090']
 - job_name: 'node-exporter'
  static_configs:
  - targets: ['localhost:9100']
```

Abra la interfaz web de Prometheus y observe que se ha agregado un nuevo target llamado `node-exporter`. Revise la carga de trabajo (ejecutando un [programa](https://github.com/Thrimbda/fiber) que calcula la secuencia de Fibonacci para siempre, ocupando todos los núcleos):

![img](https://0xc1.space/images/2020/11/05/node-load.png)

En este punto, la fase de prueba de concepto se ha completado con éxito.

> Nota: Como parte de la prueba de concepto, no se recomienda utilizar Prometheus desplegado en hardware físico para monitorizar directamente un clúster de K8s, ya que el acceso a los componentes de K8s desde fuera del clúster requiere configurar certificados y tener el [ClusterRole](https://kubernetes.io/zh/docs/reference/access-authn-authz/rbac/) con los permisos de acceso correspondientes (aquí se omiten los diversos problemas que el autor encontró al intentar usar Prometheus desplegado en hardware físico para monitorizar un clúster de K8s y sus componentes).

## Monitorizar un clúster de K8s con Prometheus

A continuación, vamos a monitorizar nuestro clúster de K8s a través de Prometheus.

### Elementos de configuración de Prometheus

En la introducción a Prometheus, se puede entender que Prometheus se basa principalmente en la obtención de datos mediante Pull, por lo que necesita descubrimiento de servicios, es decir, que Prometheus sepa de dónde extraer los datos para que los usuarios puedan consultarlos.

Entonces, primero hay que resolver un problema: **el descubrimiento de servicios para el clúster de K8s** — el secreto debe estar oculto en la configuración.

La [documentación](https://prometheus.io/docs/prometheus/2.22/configuration/configuration/) proporciona una descripción detallada de la configuración de Prometheus.

A continuación, se describen brevemente los siguientes elementos de configuración (no necesariamente son ortogonales entre sí):

- [`<global>`](https://prometheus.io/docs/prometheus/2.22/configuration/configuration/#configuration-file): Su configuración afecta a cualquier otro elemento de configuración y sirve como valor predeterminado para los elementos en otras configuraciones.
- [`<scrape_config>`](https://prometheus.io/docs/prometheus/2.22/configuration/configuration/#scrape_config): Define una tarea de monitorización, describiendo de dónde y cómo debe Prometheus monitorizar este objetivo, entre otra información.
- [`<tls_config>`](https://prometheus.io/docs/prometheus/2.22/configuration/configuration/#tls_config): Describe la configuración TLS.
- [`<*_sd_config>`](https://prometheus.io/docs/prometheus/2.22/configuration/configuration/#kubernetes_sd_config): Prometheus proporciona configuración para el descubrimiento de servicios de una serie de objetivos de monitorización predefinidos a través de esta serie de elementos de configuración (sd significa service discovery).
- [`<static_config>`](https://prometheus.io/docs/prometheus/2.22/configuration/configuration/#static_config): Para objetivos de monitorización no predefinidos por Prometheus (como cualquier servicio desplegado manualmente en hardware físico), se puede utilizar este elemento de configuración para el descubrimiento de servicios. Lo usamos en la prueba de concepto anterior.
- [`<relabel_config>`](https://prometheus.io/docs/prometheus/2.22/configuration/configuration/#relabel_config): Antes de comenzar a extraer las métricas del objetivo de monitorización, se puede utilizar este elemento de configuración para modificar algunas etiquetas. Prometheus proporciona algunas reglas de etiquetas predefinidas. El relabeling se puede realizar en varios pasos. Después del relabeling, las etiquetas que comienzan con __ se eliminarán.

Parece que el elemento de configuración central en Prometheus es `<scrape_config>`. Cada uno define una tarea de monitorización, similar al concepto de namespace, que principalmente proporciona una agrupación de objetivos de monitorización. Dentro de él, definimos `<*_sd_config>` o `<static_config>` para indicar a Prometheus de qué endpoints específicos extraer datos y cómo filtrar estos endpoints.

¡Profundicemos en la comprensión de estos elementos de configuración a través de la práctica!

### Desplegar Prometheus

El trabajo central del despliegue radica en pensar claramente qué recursos se necesitan para desplegar Prometheus en el clúster. El autor revela directamente la respuesta aquí:

1. Un Namespace dedicado.
2. Un DaemonSet para gestionar node-exporter.
3. Un Service para Node-exporter.
4. Gestionar la configuración de Prometheus con ConfigMap.
5. Un ServiceAccount dedicado para Prometheus.
6. Un ClusterRole con permisos suficientes.
7. Un ClusterRoleBinding que vincule el ServiceAccount y el ClusterRole.
8. Un Deployment para Prometheus.
9. Un Service para Prometheus.

En un clúster de K8s con RBAC aplicado, necesitamos definir un rol con permisos suficientes para Prometheus, que pueda leer el estado del clúster y varias métricas, de ahí los elementos 5-7.

Aquí se proporciona un [conjunto de declaraciones de recursos](https://github.com/Thrimbda/prometheus-set-up) acumulado por el autor durante su propio proceso de configuración. Además de los recursos mencionados anteriormente, incluye kube-state-metrics. Siguiendo el orden de las operaciones, se puede obtener un Prometheus desplegado.

#### Node-exporter

Para Node-exporter, dado que es una monitorización de la máquina en sí, el requisito es uno por cada Node. Dado que también queremos disfrutar de la gestión del ciclo de vida de K8s, DaemonSet es la mejor opción.

Dado que se ejecuta en un contenedor, sin configuración no puede recopilar métricas reales del Node. Por lo tanto, es necesario montar ubicaciones especiales del host en el contenedor para que Node-exporter pueda recopilar métricas.

```yaml
args:
- '--path.procfs=/host/proc'
- '--path.sysfs=/host/sys'
- '--path.rootfs=/host/root'
volumes:
- hostPath:
  path: /proc
 name: proc
- hostPath:
  path: /sys
 name: sys
- hostPath:
  path: /
 name: roo
```

Luego, exponga un endpoint al que Prometheus pueda acceder a largo plazo a través de un Service.

#### Prometheus

Prometheus se despliega utilizando un Deployment. Antes de desplegar Prometheus, es necesario configurar permisos suficientes para que pueda acceder a los endpoints necesarios para recopilar métricas. En un clúster de K8s con RBAC configurado, esto se logra a través de ClusterRole/ServiceAccount/ClusterRoleBinding. Una vez completada la configuración, Prometheus utiliza el ServiceAccount para realizar la autenticación correspondiente y así acceder a los endpoints necesarios.

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
 name: prometheus
 labels:
  app.kubernetes.io/name: prometheus
rules:
 - apiGroups: [""]
  resources:
  - nodes
  - nodes/metrics
  - services
  - endpoints
  - pods
  verbs: ["get", "list", "watch"]
 - nonResourceURLs:
  - "/metrics"
  - "/metrics/cadviror"
  verbs: ["get"]
---
apiVersion: v1
kind: ServiceAccount
metadata:
 name: default
 namespace: monitoring-system
 labels:
  app.kubernetes.io/name: prometheus
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
 name: promtheus
 labels:
  app.kubernetes.io/name: prometheus
roleRef:
 apiGroup: rbac.authorization.k8s.io
 kind: ClusterRole
 name: prometheus
subjects:
- kind: ServiceAccount
 name: default
 namespace: monitoring-system
```

Hasta ahora, ya tenemos todas las condiciones previas para lograr los objetivos de monitorización. Entonces, ¿cómo impulsamos el poderoso motor de Prometheus para aprovechar al máximo el entorno que hemos preparado y lograr la monitorización?

Combinando la introducción a la configuración de Prometheus del apartado anterior, definimos cuatro objetivos de monitorización con cuatro `<scrape_config>`:

Para node-exporter:

```yaml
- job_name: 'node-exporter'
 kubernetes_sd_configs:
 - role: endpoints
 relabel_configs:
 - source_labels: [__meta_kubernetes_service_name]
  regex: node-exporter
  action: keep
 - source_labels: [__meta_kubernetes_end