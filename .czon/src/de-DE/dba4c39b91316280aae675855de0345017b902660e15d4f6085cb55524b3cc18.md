---
"title": "Erste Schritte in die Nebenläufigkeit"
"summary": "Dieser Artikel beschreibt die Erfahrungen des Autors mit der Nebenläufigkeitsprogrammierung durch eine kleine Aufgabe, bei der ein einfaches Nebenläufigkeitssteuerungs-Demo mit Pythons queue-, signal- und time-Modulen implementiert wurde. Der Artikel erklärt die Funktionen der drei Module: queue als Nachrichtenwarteschlange, signal zum Abfangen von KeyboardInterrupt-Signalen und time, damit der Hauptthread die Unterbrechung erkennen kann. Der Autor geht weiter auf die Bedeutung von Nachrichtenwarteschlangen in der Multithread-Programmierung ein sowie auf den Gedanken, dass Systemdesign Details kapseln und mit Ereignissen zusammenarbeiten sollte, um die Kopplung zu verringern, und betont das Konzept des 'Designs für Veränderung'."
"tags":
  - "python"
  - "Nebenläufigkeit"
  - "Multithreading"
  - "Nachrichtenwarteschlange"
  - "Systemdesign"
"date": "2017-05-07"
---

---
title: Erste Schritte in die Nebenläufigkeit
date: 2017-05-07
taxonomies:
  tags:
    - python
    - Nebenläufigkeit
---

Gut, eine kleine Aufgabe hat mich kürzlich dazu gebracht, erstmals sinnvolle Nebenläufigkeitsprogrammierung zu erleben.

<!--more-->

## Demo

Daher habe ich mit Pythons `queue`-, `signal`- und `time`-Modulen ein kleines Demo erstellt, das nicht wirklich multithreaded ist, sondern nur zur Veranschaulichung dient:

```python
# -*- coding: utf-8 -*-
# @Author: Michale
# @Date:   2017-05-04 15:00:41
# @Last Modified by:   Michale
# @Last Modified time: 2017-05-07 00:46:52
import signal
import queue
import time


class TestClass(object):
    queue = queue.Queue()

    def __init__(self):
        signal.signal(signal.SIGINT, self.stopIfPressKill)

    def stopIfPressKill(self, mySignal, stack):
        if mySignal == signal.SIGINT:
            print('you pressed CTRL-C')
            self.queue.put_nowait('stop')
            print(self.queue.qsize())

    def mainThread(self):
        while True:
            time.sleep(1)
            if not self.queue.empty():
                data = self.queue.get()
                print(data)
                if data == 'stop':
                    break
                else:
                    self.queue.put(data)


if __name__ == '__main__':
    yoo = TestClass()
    yoo.mainThread()

```

Erklärung der Funktionen der drei Module:

- `queue`: Dient als Nachrichtenwarteschlange, was hier offensichtlich etwas übertrieben ist.
- `signal`: Wird verwendet, um `KeyboardInterrupt` abzufangen und danach das Stoppsignal in die Nachrichtenwarteschlange zu legen.
- `time`: Ermöglicht es dem Hauptthread, diesen `KeyboardInterrupt` zu erkennen.

## Gedanken

Die Einführung von Multithreading macht es schwierig, nicht-Hauptthreads nach ihrem Start zu kontrollieren, was Menschen dazu zwingt, Methoden wie Nachrichtenwarteschlangen für die Thread-Kommunikation zu verwenden.

Aber eigentlich sollten Systemmodule, unabhängig davon, ob es sich um Multithreading handelt, Details kapseln und mit Ereignissen zusammenarbeiten, um die Systemkopplung zu verringern. Dies ist auch ein gutes Designprinzip für Systeme: **Für Veränderungen entwerfen.**