---
"title": "Zola-Blog: Entwurf für Echtzeitbearbeitung und GitHub-Backend-Integration"
"summary": "Dieses Dokument skizziert detailliert den Entwurf eines WYSIWYG-Editors zur Echtzeitbearbeitung von Markdown für einen Zola-Blog, kombiniert mit einer 'Backend-losen' Integrationslösung, ohne das bestehende CSS-Design zu beeinträchtigen. Es definiert Designprinzipien wie die Beibehaltung der visuellen Sprache, die Vermeidung von selbstgeschriebenen Backends, die Unterstützung von Echtzeitvorschau und Autosave. Eine Bestandsaufnahme bestätigt, dass es sich um eine Zola-Site ohne Node/React-Build-Chain handelt, deren Inhalte aus Markdown-Dateien stammen. Unter den Kandidaten wird Hauptvariante D favorisiert: Reines JS /admin + Vditor + GitHub Device Flow + PR-Veröffentlichung. Sie ermöglicht einen vollständigen Workflow ohne eigenes Backend, mit GitHub als Single Source of Truth, lokal zwischengespeicherten Entwürfen und Bildern, die ins Repo zurückgeschrieben werden. Das Dokument behandelt auch Sicherheitsrisiken, den Umfang und eine Phasenübersicht. Die empfohlenen Umsetzungsschritte basieren auf den Standardannahmen, um Machbarkeit und Benutzerpräferenzen zu gewährleisten."
"tags":
  - "Zola"
  - "Markdown"
  - "WYSIWYG"
  - "GitHub"
  - "Echtzeitbearbeitung"
  - "Backendlos"
  - "Frontend-Entwicklung"
  - "Blog-Optimierung"
"date": "2026-01-06"
---

# Zola-Blog: WYSIWYG Markdown Echtzeitbearbeitung + Supabase/GitHub Backend-Entwurf

## Ziel

Für den bestehenden Zola-Blog soll ein WYSIWYG-Editor zur Echtzeitbearbeitung von Markdown entworfen und geplant werden, integriert mit einem "Backend-losen" Ansatz (Supabase oder GitHub Issue/Discussion), ohne das bestehende CSS-Design zu zerstören.

## Designprinzipien (müssen eingehalten werden)

- Beibehaltung der bestehenden suCSS + CSS Variables visuellen Sprache (inkl. Light/Dark Theme-Umschaltung)
- Möglichst keine Einführung eines selbstgeschriebenen Backends; Vorrang für Frontend-Direktverbindung zu Supabase oder GitHub API
- Falls React/shadcn benötigt wird, müssen Grund, Kosten und Rollback-Plan für die Einführung der Build-Chain angegeben werden
- Das Bearbeitungserlebnis muss Echtzeitvorschau/-rendering und Autosave (mindestens für Entwürfe) unterstützen
- Klarer Synchronisationspfad für die Veröffentlichung von Inhalten zu Zola (ohne Zerstörung der bestehenden content-Struktur)

## Aktueller Stand (aus der Bestandsaufnahme)

- Dieses Projekt ist eine Zola-Site (ohne Node/React-Build-Chain), gesamtes CSS/JS liegt unter `static/`, und CDN-Abhängigkeiten können in `templates/head.html` eingebunden werden.
- Theme/Farben werden vollständig durch CSS Variables in `static/css/suCSS.css` gesteuert; JS schaltet light/dark via `data-theme` (`static/js/script.js`).
- Inhaltsquelle sind `content/**` Markdown-Dateien; enthalten YAML Front Matter (`---`) und Zola Shortcodes (wie `{{ slideshow(...) }}`).

## Zu überprüfende Unklarheiten (bitte beantworten/auswählen)

1.  **Bearbeitungsumfang**: Soll nur eine/einige wenige Dateien bearbeitet werden (z.B. `content/gcores-talks.md`) oder "beliebige `content/**` Seiten"?
2.  **Echtzeitbearbeitung**: Was bedeutet "Echtzeit" für Sie:
    - A) Echtzeitvorschau/-rendering innerhalb des Editors genügt (Einzelperson)
    - B) Hintergrund-Autosave für Entwürfe erforderlich (Einzelperson)
    - C) Mehrbenutzer-Kollaboration/Bearbeitung im selben Dokument erforderlich (Mehrere Benutzer)
3.  **Veröffentlichungspfad**: Wie sollen Bearbeitungsergebnisse die Site letztendlich beeinflussen?
    - A) Nur als Entwurfsbibliothek speichern (nicht automatisch in `content/` übernehmen)
    - B) Ein-Klick-Veröffentlichung: Automatische Synchronisation ins Repo `content/` und Auslösen des Zola-Builds
    - C) Halbautomatisch: Datei exportieren/Patch generieren, manuelles Commit durch Sie
4.  **Authentifizierung**: Admin wird nur von Ihnen selbst genutzt. Ist "Supabase Email Magic Link + Allowlist Einzelbenutzer" akzeptabel?
5.  **Bilder**: Sollen Bilder direkt im Editor hochgeladen werden können? Falls ja, ist es akzeptabel, dass Bilder in Supabase Storage gespeichert und im Markdown als externe Links referenziert werden?

> [REVIEW]
> 1.  Ich möchte beliebige Dateien bearbeiten und dann über eine Methode ins GitHub-Repo committen. Falls ein Backend nötig ist, muss dessen Notwendigkeit begründet werden.
> 2.  A und B
> 3.  B
> 4.  Diese Version ist nur für mich selbst. Ein einfacher Admin-Bereich genügt, solange er sicher ist. Ich könnte sogar ein elliptisches Kurven-Schlüsselpaar akzeptieren, mit dem ich mich authentifiziere, ähnlich wie SSH.
> 5.  Bild-Upload wird benötigt, und Bilder sollen im Repo gespeichert werden.
>
> [RESPONSE] Verstanden. Ich passe die Standardannahmen/Präferenzen basierend auf Ihren Antworten an:
>
> 1) Bearbeitungsumfang: Geändert zu "Beliebige `content/**` Dateien bearbeitbar" (und erweiterbar auf `templates/**` etc., aber MVP zunächst auf `content/**` beschränken, um Risiken zu reduzieren). Veröffentlichungspfad hat "Zurückschreiben ins GitHub-Repo" als Kernziel; Supabase wird nicht mehr als Single Source of Truth verwendet.
>
> 2) Echtzeitbearbeitung: Auswahl A + B – Echtzeitrendering/Vorschau im Editor + Autosave (Entwurf).
>
> 3) Veröffentlichungspfad: Auswahl B – Ein-Klick-Commit der Bearbeitungsergebnisse zu GitHub (empfohlen via PR statt direktem Push auf master, zur einfacheren Review/Rücknahme; falls gewünscht, kann auch Direktpush als Option implementiert werden).
>
> 4) Authentifizierung: MVP nur für Sie selbst. Ihre Erwähnung von "elliptischem Kurven-Schlüsselpaar wie SSH" könnte als lokale Anmeldeinformationen-Schutz dienen (z.B.: Ihr privater Schlüssel entschlüsselt ein in IndexedDB gespeichertes GitHub-Token oder dient als Entsperrschritt). Für tatsächliche Schreibzugriffe auf GitHub wird jedoch ein GitHub-Autorisierungs-Token benötigt; um "möglichst kein Backend" zu erfüllen, tendiere ich zu GitHub OAuth *Device Flow* (keine Abhängigkeit von `client_secret`), komplett im Frontend, wobei das Token nur lokal gespeichert und optional mit Ihrem privaten Schlüssel verschlüsselt wird.
>
> 5) Bilder: Gemäß Ihrer Präferenz werden Bilder ebenfalls im Repo gespeichert (z.B. in `static/images/uploads/...`, referenziert in Markdown als `/images/uploads/...`); Die Upload-Implementierung nutzt dasselbe GitHub-Token via API, um Blobs/Commits zu erstellen, kein zusätzliches Backend nötig.
>
> Im nächsten Schritt werde ich den Plan ändern: Die "Standardempfehlung A (Supabase als Wahrheitsquelle)" wird zu "GitHub als Wahrheitsquelle + Discussions/Issues für Entwürfe + PR-Veröffentlichung". Das Design wird um Details und Einschränkungen zu Token-Speicherung/Verschlüsselung und Bildschreiben ins Repo ergänzt (Einzeldateigröße, Commit-Strategie bei häufigem Autosave, etc.).
> [STATUS:resolved]

> [REVIEW] Device Flow wäre für mich akzeptabel, dann bräuchten wir kein Schlüsselpaar. Ich vertraue meinem eigenen Gerät.
>
> [RESPONSE] OK. Unter der Annahme, dass Device Flow akzeptiert wird, können wir das "elliptische Kurven-Schlüsselpaar" aus dem MVP entfernen:
> - GitHub OAuth Device Flow zum Erhalt eines Access Tokens mit Schreibrechten für das Repo
> - Token wird nur lokal gespeichert (IndexedDB/localStorage), Sie vertrauen Ihrem eigenen Gerät
> - Falls später "Zweite Entsperrung/Schutz vor lokalen Mitlesern" gewünscht ist, kann das Schlüsselpaar/OS Keychain als optionale v2-Erweiterung hinzugefügt werden.
> [STATUS:resolved]

## Kandidaten (High-Level-Architektur)

### Variante D (Aktuelle Implementierung / Hauptvariante): Reines JS `/admin` + Vditor + GitHub Device Flow + PR-Veröffentlichung

- **Frontend**: Statische Seite `static/admin/*`, Wiederverwendung von bestehendem `reset.css`/`suCSS.css`/`style.css` und `static/js/script.js` für Theme-Umschaltung (konsistente Designsprache).
- **Editor**: Vditor (Standard IR), Bearbeitung von Haupttext + separater Front Matter-Editor (um Zerstörung durch WYSIWYG zu vermeiden).
- **Authentifizierung**: GitHub OAuth **Device Flow** (kein `client_secret` nötig, kein eigenes Token-Exchange-Backend erforderlich); Token wird nur lokal in IndexedDB gespeichert.
- **Entwürfe**: Nur lokaler Autosave (IndexedDB), keine geräteübergreifende Synchronisation, kein Git-Commit-Lärm.
- **Veröffentlichung**: Bei Veröffentlichung: Branch erstellen + PR, einmaliger Schreibvorgang für:
    - `content/**.md` (kombiniert Front Matter + Body)
    - `static/images/uploads/**` (beim Einfügen von Bildern als pending assets registriert, bei Veröffentlichung mit committet)

Vorteile: Vollständig ohne eigenes Backend; "Single Source of Truth" ist das GitHub-Repo; Entspricht Ihren Präferenzen.
Risiken: Editor muss "Treue" zu Shortcodes/Front Matter gewährleisten (besonders Seiten mit `{{ ... }}`); GitHub API-Berechtigungsumfang (scope) muss kontrolliert werden.

### Variante A (Optional): Reines JS `/admin` + Vditor + Supabase (nur Entwürfe/geräteübergreifend)

Nur einzuführen, falls zukünftig "geräteübergreifende Entwurfs-Synchronisation/Kollaboration" benötigt wird; nicht als Single Source of Truth.

### Variante B (Optional): Reines JS `/admin` + TOAST UI Editor

Falls Sie die Bearbeitungserfahrung von TOAST UI bevorzugen, kann der Editor ersetzt werden (erfordert zusätzlichen Aufwand für Theme-Überschreibungen).

### Variante C (Optional): React `/admin` (Vite) + shadcn UI + Milkdown/TipTap

Geeignet für: Komplexere UI/Interaktionen (Ressourcenverwaltung, Erweiterungsblöcke, etc.). Kosten: Einführung einer Node-Build-Chain; strikte Abbildung auf bestehende suCSS Variables erforderlich, um Stilabweichungen zu vermeiden.

> [REVIEW] Ich denke, D ist die beste Variante. Kein Backend nötig, der Zustand liegt auf GitHub. Ich kann die Einführung eines OAuth-Providers akzeptieren, mein aktuelles Kommentarsystem macht das ja auch. Schauen Sie, wie das geht. Falls Supabase unbedingt eingeführt werden muss, sollte es nur Entwürfe speichern, nicht als Single Source of Truth.
>
> [RESPONSE] Stimme Ihrer Richtung zu: GitHub (Issues/Discussions + Repo) als Hauptspeicher für "Zustand liegt auf GitHub" entspricht besser Ihren Präferenzen; Falls Supabase eingeführt wird, sollte es auf "optionaler Entwurfs-/Cache-Speicher" herabgestuft werden, nicht als System-Wahrheitsquelle.
>
> Ich benötige noch Ihre Bestätigung zu 2 Punkten, um Fehler zu vermeiden:
>
> 1)  **OAuth-Form**: Sie sagen "kann die Einführung eines OAuth-Providers akzeptieren (Kommentarsystem macht das auch)". Das Kommentarsystem giscus schreibt via GitHub App/Serverseitigem Token-Exchange und Signierung; Wenn wir auch den traditionellen Web-OAuth-Flow nutzen, betrifft das die Geheimhaltung von `client_secret`, was typischerweise ein vertrauenswürdiges Backend/Funktion für den Token-Tausch erfordert. Um "kein selbstgeschriebenes Backend" zu erfüllen, schlage ich stattdessen GitHub OAuth *Device Flow* vor: Vollständige Autorisierung im reinen Frontend möglich (kein Backend zur Aufbewahrung von `client_secret` nötig). Akzeptieren Sie Device Flow als Ersatz für den "OAuth-Provider"?
>
> 2)  **Entwurfsspeicherort**:
>     - D1) GitHub Discussions: Jede Seite entspricht einer Discussion, Entwurf ist der Discussion-Body; Bei Veröffentlichung wird ein PR zum Schreiben nach `content/**` generiert.
>     - D2) GitHub Issues: Gleiches Prinzip, aber Issues sind eher auf Aufgabenfluss ausgerichtet.
>     - D3) Repo `drafts` Branch: Autosave aktualisiert Dateien direkt (erzeugt viele Commits, erfordert Merge/Komprimierungsstrategie).
>     Welche Präferenz haben Sie: D1, D2 oder D3?
>
>     Nach Ihrer Bestätigung werde ich "GitHub als Wahrheitsquelle + Entwurfsstrategie + PR-Veröffentlichungsstrategie + Bild-Commit-Strategie + Sicherheitsmodell (lokale Token-Speicherung/optionale private Schlüssel-Verschlüsselung)" zu umsetzbaren Schritten ergänzen.
>     [STATUS:need-info]
>
> [RESPONSE] Zustimmung und basierend auf Ihrer letzten Bestätigung abgeschlossen:
> - Variante D (GitHub als Hauptspeicher) als Hauptvariante, aber ohne "OAuth-Provider + Backend Token Exchange", stattdessen **Device Flow**.
> - Supabase wird aus dem Hauptpfad entfernt (falls zukünftig geräteübergreifende Entwürfe/Kollaboration benötigt werden, als optionales Modul nachrüstbar).
>
> Umsetzungsbedeutung (zur Bestätigung):
> - `draft/autosave`: Nur lokaler Cache, kein Git-Commit; Vermeidung von "Commit/PR-Lärm bei jedem Tastendruck".
> - `publish`: Einmaliges Commit der spezifizierten `content/**` Datei + Bildänderungen zu GitHub (standardmäßig als PR empfohlen; kann auch als Direktpush auf master konfiguriert werden).
>
> Falls Sie diese konsolidierte Richtung akzeptieren, werde ich im nächsten Schritt (sobald Sie Code-Änderungen freigeben) entsprechend implementieren.
> [STATUS:resolved]

> [REVIEW] 1. Device Flow ist akzeptabel. 2. Ich denke, entweder Frontend-Cache. Ich habe scheinbar keinen Bedarf für geräteübergreifende Synchronisation, also machen wir es nicht unnötig kompliziert.
>
> [RESPONSE] Bestätigung erhalten:
> 1) OAuth: Nutzung von GitHub Device Flow (keine `client_secret`-Abhängigkeit, kein eigenes Token-Exchange-Backend nötig).
> 2) Entwürfe: Nur lokaler Frontend-Cache (IndexedDB primär, localStorage als Fallback/kleine Daten), keine geräteübergreifende Synchronisation.
>
> Dementsprechend konsolidiere ich das Gesamtdesign zu:
> - **Single Source of Truth (veröffentlicht)**: GitHub Repo `content/**` (via PR/push zurückgeschrieben)
> - **Entwürfe (draft/autosave)**: Lokaler Cache (kein Supabase/GitHub Discussions/Issues nötig)
> - **Bilder**: Bei Veröffentlichung mit ins Repo geschrieben (z.B. `static/images/uploads/...`), Markdown referenziert lokale Pfade
> [STATUS:resolved]

## Empfohlene Umsetzung (basierend auf Standardannahmen)

Aktuelle Implementierung setzt direkt Variante D um (Backend-los):

1.  Statische Seite `/admin/`: Verbindung zu GitHub (Device Flow), Abruf der `content/**.md`-Liste.
2.  Datei laden: Parsen und Trennung von Front Matter und Haupttext; Haupttext mit Vditor bearbeiten.
3.  Entwürfe: Bei Eingabe debounced in lokales IndexedDB speichern (nicht nach