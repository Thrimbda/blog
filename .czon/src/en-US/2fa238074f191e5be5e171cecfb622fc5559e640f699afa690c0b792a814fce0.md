---
"title": "In-depth Analysis of the Observer Pattern"
"summary": "This article first introduces the basic concepts of the Observer Pattern (also known as the Publish-Subscribe Pattern), its GoF definition, and its real-world applications (such as RSS subscriptions). It explains in detail the participants of the Observer Pattern (Subject, Observer, ConcreteSubject, ConcreteObserver) and applicable scenarios (dependency relationships between objects, one object's change requiring simultaneous changes to other objects). Subsequently, using Action and ActionListener in J2EE as an example, the article demonstrates through a specific Java Swing code example how the Observer Pattern can be applied in the MVC paradigm to reduce coupling between the model and view. The article points out that, compared to ordinary function calls and callback functions, the Observer Pattern can maintain consistency between objects at low cost, achieve broadcast effects, and significantly improve code reusability."
"tags":
  - "Design Patterns"
  - "System Analysis and Design"
  - "Observer Pattern"
  - "J2EE"
  - "ActionListener"
  - "MVC"
  - "Java"
  - "Coupling"
"date": "2017-04-10"
---

---
title: In-depth Analysis of the Observer Pattern
date: 2017-04-10
taxonomies:
  tags:
    - Design Patterns
    - System Analysis and Design
---

> Generally, in object-oriented analysis and design, there are three mechanisms for event handling: besides ordinary function calls, callback functions are often used, and J2EE also provides an event handling mechanism based on listeners. Please research and analyze the mechanisms of Action and ActionListener, and complete an analysis example.

First, understand the Observer Pattern.

<!--more-->

## Observer Pattern

### Observers in the Real World

The Observer Pattern is also known as the Publish-Subscribe Pattern. For example, RSS (the predecessor of WeChat push) subscriptions: when a blogger (the observed) updates a blog post, the subscribers' readers (observers) automatically receive the update. This publish-subscribe approach is called the Observer Pattern.

### Observer Pattern

The Gang of Four (GoF) describes the Observer Pattern as follows:

> - **Intent**
>
>   Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.
>
> - **Aliases**
>
>   Dependents, Publish-Subscribe
>
> - **Motivation**
>
>   A common side effect of partitioning a system into a collection of cooperating classes is the need to maintain consistency between related objects. We don't want to tightly couple classes to maintain consistency, as this reduces their reusability.
>
>   ...
>
> - **Participants**
>
>   - **Subject**
>
>     The subject knows its observers. Any number of observers may observe a subject.
>
>     Provides an interface for attaching and detaching observer objects.
>
>   - **Observer**
>
>     Defines an updating interface for objects that should be notified of changes in a subject.
>
>   - **ConcreteSubject**
>
>     Stores state of interest to ConcreteObserver objects.
>
>     Sends a notification to its observers when its state changes.
>
>   - **ConcreteObserver**
>
>     Maintains a reference to a ConcreteSubject object.
>
>     Stores state that should stay consistent with the subject's state.
>
>     Implements the Observer updating interface to keep its state consistent with the subject's.

It can be observed that the Observer Pattern is often applied in scenarios where:

- Two objects have a dependency relationship.
- When one object changes, other objects need to be updated simultaneously.

Compared to ordinary function calls and callback functions, the Observer Pattern can maintain consistency between objects at low cost, significantly **reducing the degree of coupling between objects while achieving a broadcast effect, which the former two cannot. The use of the Observer Pattern greatly **improves code reusability**.

**Action and ActionListener in J2EE are a vivid example of the Observer Pattern.**

## Action & ActionListener in J2EE

Action & ActionListener can be effectively applied in the MVC paradigm to reduce coupling between the model and view.

A great [example](http://www.ulisespulido.com/2009/03/observer-design-pattern-and-java-swing.html) is found, with the code shown below:

```java
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JTextField;

public class Frame extends JFrame {

  ActionListener observer1 = new Observer("First Observer");
  ActionListener observer2 = new Observer("Second Observer");
  ActionListener observer3 = new Observer("Third Observer");

  public Frame(){
    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    init();
  }

  private void init(){
    addChangingTextField();
    pack();
    setVisible(true);
  }

  private void addChangingTextField(){
    //Observable class TextField. each time
    //An action or event occurs the observers will be updated
    //Almost all the Swing classes has this kind of behavior
    JTextField dataTextField = new JTextField();

    // Observer registering to the observable class.
    dataTextField.addActionListener(observer1);
    dataTextField.addActionListener(observer2);
    dataTextField.addActionListener(observer3);

    add(dataTextField);
  }

  public static void main(String [] args){
  	Frame frame = new Frame();
  }
}

class Observer implements ActionListener{

  private String name;
  private String message;

  public Observer (String s){
  	name = s;
  }

  public void actionPerformed(ActionEvent e) {
    JTextField textField = (JTextField) e.getSource();
    message = textField.getText();
    JOptionPane.showMessageDialog(null,
    name + " has been confirmed about the change, Thanks!! "
    + " The Message was: " + message);
  }
}
```

### Analysis

The two classes respectively play the roles of Action and ActionListener. `frame.dataTextField` binds three listeners (`observer1`, `observer2`, `observer3`) in the `addChangingTextField` method. After the text field in the frame is edited (state change), the `actionPerformed` method in Observer is triggered to display the corresponding text.

In this example, `frame.dataTextField` acts as the `ConcreteSubject`, while `observer1`, `observer2`, and `observer3` act as `ConcreteObserver`. The interfaces they implement, which define the Action and ActionListener methods, correspond to `Subject` and `Observer`, respectively.

After binding observers, the subject does not concern itself with the specific behavior of the observers. It only notifies the observers when its own state changes, leaving it to the observers to decide what actions to take. Therefore, this method is quite elegantâ€”far superior to explicitly calling functions or executing callback functions to trigger actions. It's definitely worth learning.