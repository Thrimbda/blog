---
"title": "オブザーバーパターン実力分析"
"summary": "本稿ではまず、オブザーバーパターン（別名：パブリッシュ-サブスクライブパターン）の基本概念、GoFによる定義、および実世界での応用例（RSS購読など）を紹介します。続いて、オブザーバーパターンの参加者（Subject、Observer、ConcreteSubject、ConcreteObserver）と適用場面（オブジェクト間に依存関係が存在する場合、あるオブジェクトの変更に伴って他のオブジェクトも同時に変更する必要がある場合など）を詳細に説明します。その後、J2EEにおけるActionとActionListenerを例に、具体的なJava Swingコードの実例を通じて、オブザーバーパターンがMVCパラダイムにおいてモデルとビューの結合度を低下させるためにどのように適用されるかを示します。本稿では、通常の関数呼び出しやコールバック関数と比較して、オブザーバーパターンがオブジェクト間の一貫性を低コストで維持し、ブロードキャスト効果を実現し、コードの再利用性を向上させることができる点を指摘しています。"
"tags":
  - "デザインパターン"
  - "オブザーバーパターン"
  - "J2EE"
  - "ActionListener"
  - "システム分析と設計"
  - "MVC"
  - "Java"
"date": "2017-04-10"
---

---
title: オブザーバーパターン実力分析
date: 2017-04-10
taxonomies:
  tags:
    - デザインパターン
    - システム分析と設計
---

> 一般的に、オブジェクト指向分析・設計には、通常の関数呼び出しの他に、コールバック関数がよく用いられる3種類のイベント処理メカニズムが存在します。また、J2EEではリスナーベースのイベント処理メカニズムも提供されています。資料を調査し、ActionおよびActionListenerのメカニズムを分析し、分析例を完成させてください。

まず、オブザーバーパターンについて理解します。

<!--more-->

## オブザーバーパターン (Observer Pattern)

### 実世界におけるオブザーバー

オブザーバーパターンは、パブリッシュ-サブスクライブパターンとも呼ばれます。例えば、RSS（WeChatプッシュの元祖）購読では、あるブログ（被観測者）の投稿者が記事を更新すると、購読者のリーダー（観測者）は自動的に更新を受け取ることができます。このような公開-購読の仕組みを、オブザーバーパターンと呼びます。

### オブザーバーパターン

**G**ang **O**f **F**our (GoF) によるオブザーバーパターンの記述：

> - 意図
>
>   オブジェクト間の一対多の依存関係を定義し、あるオブジェクトの状態が変化した際に、それに依存する全てのオブジェクトが通知され、自動的に更新されるようにします。
>
> - 別名
>
>   依存者(Dependents)、パブリッシュ-サブスクライブ(Publish-Subscribe)
>
> - 動機
>
>   システムを一連の相互に協調するクラスに分割する際、関連するオブジェクト間の一貫性を維持する必要が生じるという一般的な副作用があります。一貫性を維持するためにクラス間を密結合にすることは望ましくありません。なぜなら、それはそれらの再利用性を低下させるからです。
>
> ...
>
> - 参加者
>
>   - Subject（サブジェクト、目標）
>
>     サブジェクトは自身のオブザーバーを知っています。任意の数のオブザーバーが同一のサブジェクトを観測することができます。
>
>     オブザーバーオブジェクトの登録および削除のインターフェースを提供します。
>
>   - Observer（オブザーバー、観測者）
>
>     サブジェクトの変化時に通知を受け取る必要があるオブジェクトに対して、更新インターフェースを定義します。
>
>   - ConcreteSubject（具象サブジェクト、具体目標）
>
>     関連する状態を各ConcreteObserverオブジェクトに保存します。
>
>     自身の状態が変化した際、自身の各オブザーバーに通知します。
>
>   - ConcreteObserver（具象オブザーバー、具体観測者）
>
>     ConcreteSubjectオブジェクトへの参照を保持します。
>
>     関連する状態を保存し、その状態はサブジェクトの状態と一致している必要があります。
>
>     Observerの更新インターフェースを実装し、自身の状態をサブジェクトの状態と一致させます。

オブザーバーパターンは、以下のような場面でよく適用されることがわかります：

- 2つのオブジェクトが依存関係にある場合。
- あるオブジェクトを変更する際に、同時に他のオブジェクトも変更する必要がある場合。

通常の関数呼び出しやコールバック関数と比較して、オブザーバーパターンの使用は、オブジェクト間の一貫性を低コストで維持し、**オブジェクト間の結合度を大幅に低下させることができます。同時に、ブロードキャスト効果を達成することができ、これは前者2つでは実現できません。オブザーバーパターンの使用は、コードの再利用性を大幅に向上させます。**

**そして、J2EEにおけるActionとActionListenerは、まさにオブザーバーパターンの生きた例です。**

## J2EEにおけるAction&ActionListener

Action&ActionListenerは、MVCパラダイムにおいてモデルとビューの結合度を低下させるためにうまく適用できます。

非常に良い[例](http://www.ulisespulido.com/2009/03/observer-design-pattern-and-java-swing.html)を見つけました。コードは以下の通りです：

```java
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JTextField;

public class Frame extends JFrame {

  ActionListener observer1 = new Observer("First Observer");
  ActionListener observer2 = new Observer("Second Observer");
  ActionListener observer3 = new Observer("Third Observer");

  public Frame(){
    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    init();
  }

  private void init(){
    addChangingTextField();
    pack();
    setVisible(true);
  }

  private void addChangingTextField(){
    // 観測可能なクラス TextField。
    // アクションまたはイベントが発生するたびに、オブザーバーは更新されます。
    // Swingクラスのほとんどはこの種の振る舞いを持っています。
    JTextField dataTextField = new JTextField();

    // 観測可能なクラスへのオブザーバーの登録。
    dataTextField.addActionListener(observer1);
    dataTextField.addActionListener(observer2);
    dataTextField.addActionListener(observer3);

    add(dataTextField);
  }

  public static void main(String [] args){
  	Frame frame = new Frame();
  }
}

class Observer implements ActionListener{

  private String name;
  private String message;

  public Observer (String s){
  	name = s;
  }

  public void actionPerformed(ActionEvent e) {
    JTextField textField = (JTextField) e.getSource();
    message = textField.getText();
    JOptionPane.showMessageDialog(null,
    name + " has been confirmed about the change, Thanks!! "
    + " The Message was: " + message);
  }
}
```

### 分析

2つのクラスはそれぞれAction/ActionListenerの役割を担っています。`frame.dataTextField`は`addChangingTextField`メソッド内で3つのリスナー（`observer1`, `observer2`, `observer3`）にバインドされています。フレーム内のテキストフィールドが編集されると（状態が変化）、Observerクラスの`actionPerformed`メソッドがトリガーされ、対応するテキストが表示されます。

この例では、`frame.dataTextField`が`ConcreteSubject`として、`observer1`, `observer2`, `observer3`が`ConcreteObserver`として機能しています。そして、それらが実装しているAction/ActionListenerメソッドを定義したインターフェースが、それぞれ`Subject`と`Observer`に対応します。

オブザーバーをバインドした後、サブジェクトはオブザーバーの具体的な動作を気にせず、自身の状態が変化した際にオブザーバーに通知するだけです。オブザーバー自身がどのような動作を行うかを決定します。したがって、この方法は非常に優れており、関数を明示的に呼び出したり、コールバック関数を実行して動作をトリガーする方法よりもはるかに優れており、学ぶ価値があります。