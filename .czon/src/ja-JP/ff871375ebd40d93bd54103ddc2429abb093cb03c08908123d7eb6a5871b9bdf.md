---
"title": "RBACデモ：エイアーのために"
"summary": "本稿では、著者が開発したRBAC（ロールベースアクセス制御）デモプロジェクト「エイアーのために」について詳しく紹介します。このプロジェクトは『StarCraft』を背景に、簡略化されたゲームシナリオを模倣しています。記事では、主体、ロール、リソース、権限の定義、およびSA（主体-ロール）とPA（ロール-権限）関係の設定を含む、プロジェクトの分析と設計プロセスを説明します。実装部分では、PythonのFlaskフレームワークを使用してRESTfulサービスを構築し、データベースではなくファイルでRBAC関係を管理し、具体的なコード例とビジネスロジックの説明を提供しています。最後に、RBACがシステムにもたらす価値と、著者が実践から得た学びをまとめています。"
"tags":
  - "システム設計と分析"
  - "RESTful"
  - "RBAC"
  - "Python"
  - "Flask"
  - "StarCraft"
  - "デモ"
  - "アクセス制御"
"date": "2017-05-11"
---

---
title: RBACデモ：エイアーのために
date: 2017-05-11
taxonomies:
  tags:
    - システム設計と分析
    - RESTful
    - RBAC
---

前回の記事でRBACについて理解したこと、また課題の要件から、私はRBACの実践として簡単なデモを作成することにしました。

このデモを巨大なものにする意図はなく、問題を説明することを目的としているため、「小さいながらも、必要な要素はすべて揃っている」状態を目指しました。

では、このデモの目的は何でしょうか？ 何ができるのでしょうか？

<!--more-->

## 分析と設計

面白さを持たせ、問題を十分に反映させるために、このデモでは大幅に簡略化された、各ユニットが奇跡的に主体性を持った『StarCraft』の戦況において、プロトスプレイヤーが直面するシナリオを模倣します。

良いデモには良い名前が必要です。そこで、このデモの名前は **「エイアーのために！」** とします（エイアーはプロトスの母星であり、各ゼアロットが戦場に転送される際に「エイアーのために戦え！」という熱い言葉を発します）。

**「エイアーのために」** では、あなたは味方の部隊を率いて十分な数のゼアロット戦士を生産し、破壊者エイモンを倒し、宇宙全体を救わなければなりません。もしゼアロットが足りなければ、あなたは敗北し、星々は囁き、万物は消滅します。

これらすべては、PythonのFlaskフレームワークで書かれたRESTfulサービスの中に実装されています。

> 実際のシナリオでは、プレイヤー以外のすべての主体は作成可能であり、したがってリソースと見なすことができます。しかし、RBACを体現するために、以下の制約を追加しました：
>
> - このデモで提供されるいくつかの主体は唯一無二で常に存在するものとし、あたかもそれらが唯一無二であるかのように扱います。これにより、どの主体も再帰的に作成される可能性を排除します（例：プローブはネクサスを生産でき、ネクサスはプローブを生産できます）。
> - 実際にはゲートウェイはパイロンのエネルギー供給が必要で動作しますが、ここではその点は表現していません。これは、私たちのゲートウェイが同期軌道上にあるプロトスの伝説的な母艦「アラクの槍」からのエネルギー供給を受けているためと解釈し、パイロンは人口上限を提供するリソースとしてのみ見なします。

この戦況には以下のオブジェクトが存在します：

### 主体 (Subject)

- プレイヤー （あなた） thrimbda
- プローブ （基本作業ユニット、資源を採掘したり、建造物を建設できます） probe
- ゲートウェイ （ゼアロットを生産する、戦闘ユニットです） gateway

#### ロール (Role)

- 執政官 （最高司令官、すべてのリソースを配分します） archon
- クリスタル採掘者 （プローブのみがこの役割を担えます） crystal_collector
- ゼアロット転送の拠点 （プロトス戦士を転送するためのビーコンを提供します） portal
- パイロン建設者 （パイロンがあれば、ゼアロットを転送するための十分な人口上限を得られます） pylon_transporter

### リソース (Resource)

- 未採掘のクリスタル鉱石 （パイロンの建設およびゼアロットの転送に使用、初期値は不明）
- 採掘済みのクリスタル鉱石 （パイロンの建設およびゼアロットの転送に使用、初期値0）
- 生産能力 （転送に必要なエネルギー、いわゆる人口を提供、初期値0）
- ゼアロット （戦闘ユニット、宇宙を救うために使用する戦士たち、初期値0）

### 権限 (Permission)

> リソースに対する各操作はそれぞれ権限となるため、ここでは操作を個別に列挙せず、権限とその説明を直接示します。

- クリスタル鉱石を採掘する（1回あたり最大1000単位）
- 未採掘のクリスタル鉱石を観察する（総量を確認）
- 状態報告 （現在所有しているリソースの数量を報告）
- エイモンの戦力を偵察する（必要なゼアロットの数を計算）
- パイロンを建設する（各パイロンは10の生産能力単位と100のクリスタル鉱石を提供）
- ゼアロットを生産する（各ゼアロットは2の生産能力単位と100のクリスタル鉱石を消費）
- エイモンを攻撃する（勝利か、さもなくば死か！）

### SA (主体-ロール関係)

> 主体-ロールおよびロール-権限の多対多関係は、Pythonのタプルデータ構造で表現します。実装でも同様であり、したがって本アプリケーションではデータベースを使用しません。

```python
subject_role = (('thrimbda', 'archon'),
                ('probe', 'crystal_collector'),
                ('probe', 'pylon_transporter'),
                ('gateway', 'portal'))
```

### PA (ロール-権限関係)

```python
role_permission = (('archon', 'get_status'),
                   ('archon', 'for_aiur'),
                   ('archon', 'scout'),
                   ('crystal_collector', 'get_crystal'),
                   ('crystal_collector', 'crystal_status'),
                   ('pylon_transporter', 'get_status'),
                   ('pylon_transporter', 'transport_pylon'),
                   ('portal', 'transport_zealot'),
                   ('portal', 'get_status'))
```

## 実装

[リポジトリURL](https://github.com/Thrimbda/my-life-for-Aiur)

[オンラインデプロイ](https://my-life-for-aiur.herokuapp.com/)（速度が遅い場合があります）

### 概要

全体として、PythonのFlaskフレームワークを使用してRESTfulスタイルのサービスを記述しました。このアプリケーションはフロントエンド部分を含まないため、フロントエンドをバイパスするなどのセキュリティ問題も存在しません。

まず、このデモの特徴はデータベースを使用していない点です。RBACはデータベースの使用を強制するものではなく、RBACでデータベースを使用することは直感的で自然なことです。しかし、**「エイアーのために」** ではデータベースを使用せず、ファイル形式でRBACの `主体-ロール-権限` 関係を表現します。データベース自体がファイルシステムの上に発展してきたものであり、ここでファイルを採用する理由は、システムが十分に単純で、問題を説明するためにシステムの複雑さをさらに低減するためです。具体的なファイル形式は、前述のSA、PA関係の説明を参照してください。

### RESTfulについて

ここで簡単にRESTful (**Re**presentational **S**tate **T**ransfer) について触れておきます。

名前の通り、（リソースの）表現層状態転送です。

Webサービスにおいて、提供されるサービスはシステムのリソースであり、URIの形式で表現されます。そしてサービスの形式はリソースに対する操作（状態転送）であり、HTTP動詞の形式で表現されます。これらの概念は、RBACのリソース、操作とよく対応するため、私が行うべきことは、RBACの権限管理をRESTにおけるリソース操作に適用することです。

### RBACにおける各オブジェクト

上記2つの設定ファイルでは、SAとPA以外に、S、R、Pを暗黙的に求めることができます：

```python
# 上記のタプル subject_role からS、Rリストを求める
subjects = list(set([item[0] for item in subject_role]))
roles = list(set([item[1] for item in subject_role]))
```

また、SEはWebアプリケーションにおけるセッションとよく対応し、主体が1回のログイン中に持つ一時的なオブジェクトとして機能します：

```python
# 主体がアラクの槍戦術管理システムのAPIにログインするために使用します。ここではセッションはFlaskのグローバルオブジェクトとして、その実装の詳細は省略します。
class SpearOfAdun(Resource):
    
    def post(self):
        args = self.putparser.parse_args()
        if args['subject'] is not None:
            abortInvalideSubject(args['subject'])
        if args['role'] is not None:
            abortInvalideRole(args['role'])
        checkRole(args['subject'], args['role'], subject_role)
        session['subject'] = args['subject']
        session['role'] = args['role']
        return {'message': 'login as %s using %s' % (session['subject'], session['role'])}, 201
```

主体-ロールのモデリングは、最終的には権限を分離して割り当て、システム内のリソースが適切に使用され保護されるようにするためです。

**「エイアーのために」** では、権限をWeb APIの内部属性として扱っています。例：

```python
# ゼアロットを転送するためのAPI
class Zealot(Resource):

    def put(self):
        permission = 'transport_zealot' # 権限
        abortIfSubjectUnauthenticated(session) # ログイン認証
        checkPermission(session['role'], permission, role_permission) # このロールにおける主体がこの権限をリクエストできるか確認
        args = self.putparser.parse_args()
        amount = nexus.transport(args['amount'])
        return {'message': 'transport %d zealot warriors, En Taro Tassadar!' % amount}, 200
```

上記で例示した2つのAPIでは、各クラスがシステム内の1つのリソースとして存在し、提供されるHTTPメソッドはリソースに対する操作となります。

**これで、RBACにおける各種オブジェクトがすべて揃いました。**

### ビジネスロジック

**「エイアーのために」** は実際にプレイ可能なオンラインリアルタイムストラテジーゲームのAPIであるため、そのビジネスロジックについて説明する必要があります：

プレイヤーの目標は：**資源を集め、基地を建設し、そして敵を震え上がらせる部隊を作り出し、暗黒の存在エイモンを倒すことです。**

エイモンを倒す唯一の条件は、十分な数のゼアロット (zealot) を所有することであり、この数はシステムがランダムに生成する20から100の整数です。同時に、システムはこのデータに基づいて、エイモンを倒すのにちょうど十分な未採掘クリスタル鉱石を生成します。

**なぜちょうど十分なのか？**

ゼアロットを転送するには十分な数のクリスタルエネルギーとクリスタル鉱石が必要であり、エネルギーを供給するパイロンの生産にもクリスタル鉱石が消費されます。したがって、もしパイロンを建てすぎると、クリスタルエネルギーは足りていても、**ゼアロットを転送するための十分なクリスタル鉱石がなくなり、宇宙の運命をかけたこの戦いに敗北することになります。**

このロジック全体は、戦闘全体のライフサイクルを持つ1つのオブジェクトによって提供されます。問題を防ぐために、各操作がアトミックであることを保証するスレッドロックを追加しました。

```python
# これがゲーム全体の核であるため、私はこれをネクサス (Nexus) と呼びます。
import random
from threading import Lock


class Nexus(object):
    _lock = Lock()
    crestalInControl = None
    crestalRemain = None
    populationCap = None
    zealot = None
    status = {}
    _amond = None

    def __init__(self):
        # オブジェクトの初期化
        self._amond = random.randint(20, 100)
        self.crestalRemain = self._amond * 100 + (self._amond // 5 + 1) * 100
        self.crestalInControl = 0
        self.populationCap = 0
        self.zealot = 0

    def collect(self, amount=1000):
        # クリスタル鉱石を採掘
        with self._lock:
            amount = min(amount, self.crestalRemain)
            self.crestalRemain -= amount
            self.crestalInControl += amount
            return amount

    def transport(self, amount=5):
        # ゼアロットを転送
        with self._lock:
            capacity = self.populationCap / 2
            available = self.crestalInControl / 100
            amount = min(amount, capacity, available)
            self.zealot += amount
            self.crestalInControl -= amount * 100
            self.populationCap -= amount * 2
            return amount

    def build(self, amount=1):
        # パイロンを建設
        with self._lock:
            available = self.crestalInControl / 100
            amount = min(amount, available)
            self.populationCap += amount * 10
            self.crestalInControl -= amount * 100
            return amount

    def forAiur(self):
        # エイアーのために戦え！
        with self._lock:
            if self.zealot >= self._amond:
                return True
            else:
                return False

    def getStatus(self, role):
        # 状態を取得
        if role == 'archon':
            return {
                'crestalInControl': self.crestalInControl,
                'crestalRemain': self.crestalRemain,
                'populationCap': self.populationCap,
                'zealot': self.zealot
            }
        elif role == 'pylon_transporter':
            return {
                'crestalInControl': self.crestalInControl,
                'populationCap': self.populationCap
            }
        elif role == 'portal':
            return {
                'crestalInControl': self.crestalInControl,
                'populationCap': self.populationCap,
                'zealot': self.zealot
            }
        else:
            return {}


nexus = Nexus() # オブジェクトのインスタンス化
```

## 結び

実際、『StarCraft II』というゲームは、各戦局において典型的なDACモデルです：プレイヤーがすべてを支配し、ゲーム内のすべての操作は、クリスタル鉱石と高エネルギー瓦斯（ここでは簡略化されています）という2つの基本リソースを状態転換し、プレイヤーが必要とするリソース（生産ユニット、戦闘ユニット）に変え、敵のリソースを消費して戦局を勝利に導くものと見なすことができます。これは、RESTfulサービスの思想が非常に普遍的であることを示しています。

**「エイアーのために」** という小さなゲームでは、いくつかのロールを固定化し、RBACモデルを構築しました。

この実践を通じて、RBACがシステム内でどのように応用されるかを理解し、さらにこの素晴らしいフレームワークであるFlaskについて学び、RESTful思想についてより深く理解することができ、多くの収穫がありました。