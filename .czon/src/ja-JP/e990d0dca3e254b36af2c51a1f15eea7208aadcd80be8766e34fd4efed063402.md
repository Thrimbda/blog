---
"title": "ソースコードリーディング：Harbor-Operator 設計分析"
"summary": "本稿では、Harbor-Operator のソースコード設計を詳細に解析します。特に、依存グラフ（Dependency Graph）によるリソース間の依存関係解決、単一コントローラー（Controller）による複数CRDの調和（Reconcile）ロジック実現、そしてResourceManagerによるコードの設定化と再利用率向上について焦点を当てます。また、Harbor-Operator が Golang と Kubernetes プラットフォーム上でどのように実践されているかを分析し、'the right thing' 設計理念の模範として、シンプルさ、一貫性、完全性のバランスをどのように取っているかを示します。これにより、Operator開発における貴重な設計上の参考例を提供します。"
"tags":
  - "Harbor-Operator"
  - "ソースコード分析"
  - "Kubernetes"
  - "Operator パターン"
  - "依存グラフ"
  - "コントローラー設計"
  - "Golang"
  - "ソフトウェアアーキテクチャ"
"date": "2022-01-30"
---

<!--more-->

<a id="orgdafefdb"></a>

## 開始前の準備

<a id="org081213e"></a>

### なぜ Harbor-Operator なのか

<a id="org55a74c9"></a>

#### Worse is Better?

優れたソフトウェアとは何でしょうか？

1980年代後半の有名な記事「The Rise of Worse is Better」の中で、著者は優れたソフトウェア設計は **シンプルさ、正確さ、一貫性、完全性** という4つの特性を考慮すべきだと述べています。

記事では、2つのソフトウェア設計理念について言及されており、仮に **the right thing** と **worse is better**（この命名は必ずしも否定的な意味ではないことに注意）と呼びます。これら2つの設計理念は、上記の特性を中心に展開されていますが、その優先順位が異なります。

---

<a id="orgbebeeee"></a>

##### The right thing

- **シンプルさ** - 設計はシンプルで理解しやすいものでなければなりません。インターフェースのシンプルさは、実装のシンプルさよりも重要です。
- **正確さ** - 設計は正確でなければならず、この点については一切の妥協があってはなりません。
- **一貫性** - 一貫性は正確さと同じくらい重要です。そのため、シンプルさと完全性は多少犠牲にしても構いません。
- **完全性** - 設計は様々な状況を考慮できなければならず、シンプルさを保つために完全性を過度に犠牲にしてはいけません。

<a id="org948c614"></a>

##### Worse is better

- **シンプルさ** - 設計はシンプルで理解しやすいものでなければなりません。実装のシンプルさはインターフェースのシンプルさよりも重要であり、シンプルさが最も重要な特性です。
- **正確さ** - 設計は正確でなければなりません。もちろん、シンプルさを保つことは正確さよりも少し重要です。
- **一貫性** - 設計はあまりにも一貫性を欠いてはいけません。シンプルさを保つために一貫性を犠牲にすることができます。シンプルさを保証する限り、完全性のために一貫性を犠牲にすることもできます。
- **完全性** - 設計は様々な状況を考慮できなければなりません。設計をシンプルに保つために、完全性をいつでも犠牲にすることができます。

---

その後、著者は両者の多くの例を挙げ、なぜ当時のソフトウェア業界で worse-is-better が席巻しているかを論証しています。

これら2つの理念に優劣はありません。今日でも私たちの身の回りに存在し、実際の状況はしばしば両者の間を行き来します。私たちは優れた、美的価値のある設計を行いたいと望みますが、コストや人的要因も考慮しなければなりません。最終的には、現実世界の問題を解決するために、品質が基準を満たし、動作するソフトウェアを納品する必要があり、ソフトウェアの作成・保守コストが問題自体の価値を絶対に上回ってはなりません。

<a id="org514ce0b"></a>

#### Golang - the language

Golang は、ほぼ間違いなく worse is better 理念の模範と言えます：

- Google が長年にわたって C++ で蓄積した実践的経験が凝縮されています。
- 非常にシンプルで、複雑な機能は一切ありません。そのため、問題を解決するための基本的な構成要素（building block）はほぼ1種類しかなく、これは以下のことを意味します：
  - 言語自体についてほとんど学ぶ必要なく、容易に習得できます。
  - コードが非常に読みやすいです。
- コンパイルが高速で、コンパイル速度のためにジェネリクスさえも犠牲にしました。
- goroutine を使って並行タスクを非常に簡単に実行できます。
- 例外スタックという言語機能をほぼ捨て、エラーチェックと処理を強制します。
- 一度コンパイルすれば、どこでも実行できます。

<a id="org2432232"></a>

#### Kubernetes - the platform

Kubernetes は皆さんよくご存知なので、釈迦に説法は避けます。一言で言えば：概念的に非常にシンプルな API 設計を提供し、サイバネティクス（制御理論）に基づく調和（Reconcile）メカニズムを補完することで、コンテナ化されたソフトウェアを自動的にデプロイ、スケール、運用できるようにします。

k8s は、この API 仕様と調和メカニズムを公開することで、開発者がその機能を拡張できるようにしています。開発者は **Operator パターン** を実装できます：ソフトウェアの設定、デプロイ（Day-1）および運用、バックアップ、フェイルオーバー（Day-2）に関する知識を、ソフトウェアを操作するためのソフトウェアとして記述し、これらの複雑でエラーが発生しやすい操作を自動化することで、信頼性を高め、コストを削減します。

---

では、Harbor Operator を選んだ理由は、それが非常に優れた設計を持っており、優れたプラットフォーム上で、シンプルな言語特性を用い、過度な技巧に頼ることなく、SOLID 設計原則に適合するいくつかの重要な設計を通じて、実用的で美的価値のあるソフトウェアシステムを実現しており、**the right thing** 理念の実践者と見なすことができるからです。

著者のコードにはほとんどコメントがありませんが、異常に読みやすいです。これは、システム全体の設計にも依っています。

<a id="org6815286"></a>

## 目標

問題を抽象化して単純化することは、必然的に柔軟性の犠牲を伴います。一方、Harbor Operator は柔軟性を完全に捨て去ることで、最大限の思考負荷軽減をもたらし、Operator の開発がソフトウェア設定を宣言するようなものになることを追求しています。

client-go を使って手動で operator を書くことは、Golang にジェネリクスが欠けていることもあり、まさに自虐行為です。プロジェクト全体に大量のボイラープレートコードが溢れかえることになります。client-go を使って本当に手書きするとしても、誰も本当にゼロから書き始めないと信じています。

そこで **kubebuilder** が登場しました。Kubernetes Client の作成、Kubernetes API Server へのリクエストの監視、およびリクエストのキューイングなどの操作を、共通ライブラリである **controller runtime** と共通ツールである **controller tools** に抽象化し、開発者が API オブジェクト変更リクエストのビジネスロジック開発に集中できるように、スキャフォールディングコードを生成できます。

Kubebuilder は依然としてビジネスロジックの多様性に一筋の活路を残していますが、Harbor Operator はその上でさらに極致を追求し、柔軟性を完全に犠牲にして概念の一貫性とシンプルさを追求しています。そして、それが直面するビジネスは、まさにこのアプローチに非常に適していました。

したがって、今回のソースコードリーディングにおける主な目標は、Harbor Operator から以下を学ぶことです：

- Day-1 操作をどのように行うか
- operator コードの冗長性をさらにどのように削減し、同一の Controller コードで11の異なる階層の CRD の Controller を実現するか
- DAG をどのように利用してリソース間の依存関係を解決するか（著者はこのために特許も出願しているようです）

一方、以下については重点的に研究しません：

- Harbor Operator における Day-2 操作（実際、現在のバージョンではこの機能はまだ不安定です）
- Harbor 自体のソースコードと機能

<a id="org345a335"></a>

## ソースコードリーディング

<a id="org1198d5f"></a>

### 静的構造

<a id="orgb32de77"></a>

#### ディレクトリ構造

ここではディレクトリのみをリストアップします。

```
    root
    ├── apis
    │   ├── goharbor.io
    │   │   └── v1alpha3
    │   └── meta
    │       └── v1alpha1
    ├── controllers
    │   ├── controller_string.go
    │   ├── controllers.go
    │   └── goharbor
    │       ├── chartmuseum
    │       ├── controller_test.go
    │       ├── core
    │       ├── exporter
    │       ├── harbor
    │       ├── harborcluster
    │       ├── internal
    │       ├── jobservice
    │       ├── notaryserver
    │       ├── notarysigner
    │       ├── portal
    │       ├── registry
    │       ├── registryctl
    │       └── trivy
    ├── pkg
    │   ├── builder
    │   ├── cluster
    │   │   ├── controllers
    │   │   │   ├── cache
    │   │   │   ├── common
    │   │   │   ├── database
    │   │   │   │   └── api
    │   │   │   ├── harbor
    │   │   │   └── storage
    │   │   ├── gos
    │   │   ├── k8s
    │   │   └── lcm
    │   ├── config
    │   │   ├── harbor
    │   │   └── template
    │   ├── controller
    │   │   ├── errors
    │   │   ├── internal
    │   │   │   └── graph
    │   │   └── mutation
    │   ├── event-filter
    │   ├── exit
    │   ├── factories
    │   │   ├── application
    │   │   ├── logger
    │   │   └── owner
    │   ├── graph
    │   ├── harbor
    │   ├── image
    │   ├── manager
    │   ├── resources
    │   │   ├── checksum
    │   │   └── statuscheck
    │   ├── scheme
    │   ├── setup
    │   ├── status
    │   ├── template
    │   ├── tracing
    │   ├── utils
    │   │   └── strings
    │   └── version
    ...
```

<a id="orgfc0f08e"></a>

#### 主要インターフェース

![img](https://0xc1.space/images/2022/01/30/harbor-operator-class.svg)

<a id="org290c6c2"></a>

#### システムアーキテクチャ

v1.0.1 時点で、Harbor Operator は現在主に Harbor システムの Day-1 操作を担当しています。
![img](https://0xc1.space/images/2022/01/30/harbor-operator-arch.png)

<a id="org41c8944"></a>

### 大局を捉える：HarborCluster

まず、あまり重要ではない部分を除外しましょう：HarborCluster という CRD とその Controller の実装です。

なぜ特殊だと言えるのでしょうか？まず、システムアーキテクチャ内での位置を観察します：最上位に位置し、Harbor システム自体とそれが依存するすべてのステートフルサービスを管理しています。これは、プロジェクトの歴史と、システムアーキテクチャ内での特殊な地位の両方から説明する必要があります。

システムアーキテクチャの観点から見ると、この HarborCluster CRD は定義上、Harbor CRD と非常に似通っており、コードに大量の冗長性があり、非常に見栄えが悪いです。これは、システム全体の中で最も上（外）層の CRD として、ユーザーに直接向き合っているためです。ユーザーに Harbor デプロイメントのすべての必要な設定項目を宣言できるようにしなければなりません。さらに、Harbor 自体はステートレスサービスであるため、完全なデプロイメントでは、HarborCluster CRD が Harbor システムが依存するすべてのステートフルサービス（Postgres、Minio、Redis を含む）を管理する必要があります。

一方、Harbor システム自体に必要な情報はすでに Harbor CRD で定義されています。したがって、HarborCluster CRD の冗長部分は、この情報を Harbor CRD に完全かつ正確に渡すことです。さらに、HarborCluster CRD は、自身の責務範囲外にあるステートフルサービスの CRD も管理する必要があるため、Harbor および Harbor のすべてのサブコンポーネントの Controller ロジックを完全に使用することはできません。

歴史的な観点から見ると、Harbor Operator は当初 OVH Cloud のプライベートプロジェクトであり、後に goharbor コミュニティに寄贈されました。したがって、git の履歴を組み合わせて観察すると、HarborCluster の CRD 定義とその Controller の実装が、システム内の他の Controller とこれほど大きな不一致を持つ理由は、それがコミュニティによって後から貢献されたものであり、Harbor Operator 設計の当初は、それが担う機能が考慮されていなかったためです。

また、HarborCluster Controller 自体の実装は、私たちが普段目にする、Controller-runtime を使用して実装された大多数の Controller と大きな違いはありません。したがって、詳細な研究は行いません。

---

HarborCluster Controller

![img](https://0xc1.space/images/2022/01/30/harbor-cluster-controller.png)

---

Harbor Core Controller

![img](https://0xc1.space/images/2022/01/30/harbor-core-controller.png)

---

<a id="orgd9c3526"></a>

### リソース間の依存関係を解決する： Dependency Graph

依存グラフは、プロジェクト全体の中で比較的独立したモジュールですが、実際には Harbor Operator のすべての controller の実行エンジンとしての役割を担っています。本質的には、Kubernetes 内の各種リソース間に相互依存関係が存在し、一部のリソースのデプロイと調和は他のリソースのデプロイと調和に依存しているという観察に基づいています。例えば、Deployment は Configmap に依存するかもしれません。最終的にこれらの依存関係は依存グラフを構成します。実際、このグラフは DAG（有向非巡回グラフ）であるべきです。ここで必要なインターフェース定義は以下の通りです：

```go
    package graph

    type Resource interface{}

    type RunFunc func(context.Context, Resource) error

    type Manager interface {
            Run(ctx context.Context) error
            AddResource(ctx context.Context, resource Resource, blockers []Resource, run RunFunc) error
    }

    type resourceManager struct {
       resources map[Resource][]Resource
       functions map[Resource]RunFunc

       lock sync.Mutex
    }
```

- ここで、`Resource` は抽象的なリソースを定義しています。このモジュールはリソースが具体的に何を表すかに関心がなく、言語の表現力の制限下で最大限の柔軟性を保持するために、トップ型である `interface{}` を使用しています。
- `RunFunc` は、特定の `Resource` に対してどのように操作を行うかを担当します。ここで `RunFunc` は型安全性の問題に直面します：`interface{}` はコンパイラがその型について何も知らないことを意味し、手がかりがありません。しかし、`RunFunc` はこの「何でもあり得る」型を使って何かをしなければなりません。したがって、型アサーション（強制型変換）を行う必要