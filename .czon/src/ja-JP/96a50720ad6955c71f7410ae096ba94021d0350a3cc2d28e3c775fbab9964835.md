---
"title": "Zola ブログ：WYSIWYG 編集と GitHub バックエンド統合の設計案"
"summary": "この文書は、既存の Zola ブログに WYSIWYG リアルタイム Markdown 編集機能を追加するための詳細な計画を説明します。中核の目標は、既存のデザインスタイルを維持し、バックエンドの手書き実装を導入しないことです。現状分析と設計原則に基づき、純粋なフロントエンド実装、GitHub OAuth device flow による認証、下書きのローカル保存、そして PR 作成によるコンテンツの GitHub リポジトリへの公開というアーキテクチャを推奨します。この案は、編集時のリアルタイムプレビューと自動保存を保証し、既存の構造を破壊することなく、コンテンツ同期のパスを明確にします。また、他の候補案、セキュリティリスク、および実装段階についても議論します。"
"tags":
  - "Zola"
  - "WYSIWYG"
  - "Markdown"
  - "GitHub"
  - "フロントエンド"
  - "リアルタイム編集"
  - "バックエンドレス"
  - "ブログ"
"date": "2026-01-06"
---

# Zola ブログ：WYSIWYG Markdown リアルタイム編集 + Supabase/GitHub バックエンド設計案

## 目標

現在の Zola ブログに対して、既存の CSS デザインスタイルを破壊することなく、Markdown をリアルタイム編集可能な WYSIWYG エディタと、「手書きバックエンド不要」(Supabase または GitHub Issue/Discussion) の統合案を設計・計画します。

## 設計原則（必須遵守事項）

- 既存の suCSS + CSS 変数によるビジュアル言語（ライト/ダークテーマ切替を含む）を維持する
- 手書きバックエンドの導入を極力避ける。フロントエンドから直接 Supabase または GitHub API に接続することを優先する
- React/shadcn を導入する場合は、ビルドチェーン導入の理由、コスト、ロールバック案を示す必要がある
- 編集体験は、リアルタイムプレビュー/レンダリングと自動保存（少なくとも下書き）をサポートする必要がある
- コンテンツを Zola に公開する同期パスを明確にする（既存の content 構造を破壊しない）

## 現状概要（監査より）

- 本プロジェクトは Zola サイト（Node/React ビルドチェーンなし）であり、全サイトの CSS/JS は `static/` を経由し、`templates/head.html` で CDN 依存関係を導入可能です。
- テーマ/色は完全に `static/css/suCSS.css` の CSS 変数によって制御されています。JS は `data-theme` を通じてライト/ダークを切替えます（`static/js/script.js`）。
- コンテンツソースは `content/**` の Markdown ファイルです。YAML front matter（`---`）と Zola shortcodes（例：`{{ slideshow(...) }}`）を含みます。

## レビューが必要な不確定点（回答/選択してください）

1.  **編集範囲**：特定の1つまたは少数のファイル（例：`content/gcores-talks.md`）のみを編集できればよいか、それとも「任意の `content/**` ページを編集可能」にしたいか？
2.  **リアルタイム編集**：「リアルタイム」とは何を指しますか：
    - A) エディタ内でのリアルタイムプレビュー/レンダリングのみ（単一ユーザー）
    - B) バックグラウンドでの下書き自動保存が必要（単一ユーザー）
    - C) 複数ユーザーでの共同編集/同時編集が必要（マルチユーザー）
3.  **公開連携**：編集結果は最終的にサイトにどのように反映させたいですか？
    - A) 下書きライブラリとして保存のみ（自動的に `content/` に入らない）
    - B) ワンクリック公開：自動的にリポジトリの `content/` に同期し、Zola ビルドをトリガー
    - C) 半自動：ファイルをエクスポート/パッチを生成し、手動でコミット
4.  **認証**：admin は自分だけが使用する場合、「Supabase email magic link + 許可リスト（単一ユーザー）」を受け入れますか？
5.  **画像**：エディタ内で直接画像をアップロードする必要がありますか？ 必要であれば、画像を Supabase Storage に保存し、Markdown 内で外部リンクとして参照する方法を受け入れますか？

> [REVIEW]
> 1.  任意のファイルを編集し、何らかの方法で github リポジトリにコミットしたい。バックエンドが必要な場合は、その必要性を論証すること。
> 2.  A と B
> 3.  B
> 4.  このバージョンは自分だけが使うので、admin 機能があれば十分。セキュリティが保証されていれば、楕円曲線鍵ペアを持ち、ssh のようにその鍵ペアで認証することも受け入れられる。
> 5.  画像のアップロードが必要で、画像はリポジトリに保存したい。
>
> [RESPONSE] 了解しました。あなたの回答に基づき、デフォルトの前提/方針を以下のように調整します：
>
> 1)  編集範囲：「任意の `content/**` ファイルを編集可能」に変更（将来的には `templates/**` 等にも拡張可能だが、MVP ではリスク低減のため `content/**` に限定）。公開パスは「GitHub リポジトリへの書き戻し」を中核目標とし、Supabase を真実のソースとはしない。
> 2)  リアルタイム編集：A + B を選択 —— エディタ内リアルタイムレンダリング/プレビュー + 自動保存（下書き）。
> 3)  公開連携：B を選択 —— 編集結果をワンクリックで GitHub にコミット（レビュー/ロールバックのため、master への直接 push ではなく PR 経由を推奨。直推を希望する場合はオプション化も可能）。
> 4)  認証：MVP は自分だけが使用。あなたが言及した「ssh のような楕円曲線鍵ペア」の方向性は、ローカル認証情報の保護（例：あなたの秘密鍵で IndexedDB に保存された GitHub token を復号化、またはロック解除ステップとして）に利用できます。しかし、GitHub への実際の書き込みには GitHub 認証トークンが必要です。「極力バックエンド不要」を満たすため、純粋なフロントエンドで認証を完了できる GitHub OAuth *device flow*（`client_secret` に依存しない）を使用し、取得したトークンはローカルのみに保存し、あなたの秘密鍵で二次暗号化可能とする方向を提案します。
> 5)  画像：あなたの希望通り、画像もリポジトリに保存（例：`static/images/uploads/...` に書き込み、Markdown 内では `/images/uploads/...` を参照）。アップロード実装は「同じ GitHub トークンを使用して API 経由で blob/commit を作成」するため、追加のバックエンドは不要。
>
> 次のステップとして、plan 内の「デフォルト推奨 A(Supabase 真実ソース)」を「GitHub 真実ソース + Discussions/Issues 下書き保存 + PR 公開」に変更し、設計にトークン保存/暗号化と画像リポジトリ書き込みの詳細と制限（単一ファイルサイズ、頻繁な自動保存時のコミット戦略など）を追加します。
> [STATUS:resolved]

> [REVIEW] 可能であれば device flow は受け入れられるので、鍵ペアは不要。自分のデバイスは信頼できる。
>
> [RESPONSE] OK、device flow を受け入れる前提で、「楕円曲線鍵ペア」を MVP から削除できます：
> - GitHub OAuth device flow を使用してリポジトリ書き込み用のアクセストークンを取得
> - トークンはローカル（IndexedDB/localStorage）にのみ保存。自分のデバイスを信頼すれば十分
> - 将来的に「二次ロック解除/ローカルの覗き見防止」が必要な場合は、鍵ペア/OS Keychain を v2 のオプション機能として追加
> [STATUS:resolved]

## 候補案（高レベルアーキテクチャ）

### 案 D（現在の実装 / 主案）：純粋 JS `/admin` + Vditor + GitHub Device Flow + PR 公開

-   **フロントエンド**：`static/admin/*` 静的ページ。既存の `reset.css`/`suCSS.css`/`style.css` と `static/js/script.js` のテーマ切替を再利用（デザイン言語の一貫性を維持）。
-   **エディタ**：Vditor（デフォルト IR モード）。本文編集と front matter は個別に編集（WYSIWYG による破壊を回避）。
-   **認証**：GitHub OAuth **device flow**（`client_secret` 不要、トークン交換用の自前バックエンド不要）。トークンは IndexedDB にローカル保存のみ。
-   **下書き**：ローカル自動保存のみ（IndexedDB）。デバイス間同期なし、Git commit ノイズを発生させない。
-   **公開**：公開時にブランチ作成 + PR、一度の書き込みで以下をコミット：
    -   `content/**.md`（front matter と本文を結合）
    -   `static/images/uploads/**`（画像挿入時に pending assets として登録し、公開時にまとめてコミット）

長所：完全に自前バックエンド不要。「真実のソース」は GitHub リポジトリ。あなたの希望と一致。
リスク：エディタが shortcodes/front matter（特に `{{ ... }}` を含むページ）を「忠実に」扱えるか検証が必要。GitHub API の権限範囲（scope）を制御する必要がある。

### 案 A（オプション）：純粋 JS `/admin` + Vditor + Supabase（下書き/デバイス間同期のみ）

将来「デバイス間での下書き同期/共同編集」が必要になった場合にのみ導入。真実のソースとはしない。

### 案 B（オプション）：純粋 JS `/admin` + TOAST UI Editor

TOAST UI の編集体験を好む場合、エディタを置き換え可能（追加のテーマ上書きコストが必要）。

### 案 C（オプション）：React `/admin`（Vite）+ shadcn UI + Milkdown/TipTap

適しているケース：より複雑な UI/インタラクション（リソース管理、拡張ブロックなど）が必要な場合。代償：Node ビルドチェーンの導入。既存の suCSS 変数への厳密なマッピングが必要で、スタイルの乖離を避ける必要がある。

> [REVIEW] D 案が良いと思う。バックエンドが不要で、状態は全て GitHub 上にある。OAuth プロバイダの導入は受け入れられる。現在のコメントシステムも同様の方法で行っている。どう実装するか確認してほしい。Supabase を導入する必要がある場合は、真実のソースとしてではなく、下書き保存のみに使用すべき。
>
> [RESPONSE] あなたの方向性に同意します：GitHub（Issues/Discussions + リポジトリ）を「状態は全て GitHub 上」の主ストレージとする方があなたの希望に合致します。Supabase を導入する場合は、「オプションの下書き/キャッシュ」に格下げし、システムの真実のソースとすべきではありません。
>
> 誤った方向に進まないよう、2点確認が必要です：
>
> 1)  **OAuth 形態**：あなたが「OAuth プロバイダの導入は受け入れられる（コメントシステムも同様）」と述べています。コメントシステム giscus の書き込みは、GitHub App/サーバー側によるトークン交換と署名に依存しています。我々も従来の web OAuth flow を使用する場合、`client_secret` の秘匿に関わるため、通常は信頼できるバックエンド/関数がトークン交換に必要です。「手書きバックエンド不要」を満たすため、GitHub OAuth *device flow* を強く推奨します：純粋なフロントエンドで認証を完了できます（`client_secret` をバックエンドで管理する必要がない）。あなたは device flow を「OAuth プロバイダ」の代替として受け入れますか？
> 2)  **下書きの保存先**：
>     - D1) GitHub Discussions：各ページに対応する discussion を作成。下書きは discussion の本文。
>     - D2) GitHub Issues：同様だが、issues はタスクフローに偏っている。
>     - D3) リポジトリの `drafts` ブランチ：自動保存で直接ファイルを更新（多くのコミットが発生するため、マージ/圧縮戦略が必要）。
>     あなたは D1/D2/D3 のどれを好みますか？
>
> あなたの確認後、「GitHub 真実ソース + 下書き戦略 + 公開 PR 戦略 + 画像コミット戦略 + セキュリティモデル（トークンローカル保存/オプションの秘密鍵暗号化）」を実現可能な具体的な手順として完成させます。
> [STATUS:need-info]
>
> [RESPONSE] 同意し、あなたの最新の確認に基づき収束を完了しました：
> - 案 D（GitHub を主ストレージ）を主案としますが、「OAuth プロバイダ + バックエンドトークン交換」は不要となり、**device flow** を使用します。
> - Supabase は主パスから削除（将来的にデバイス間下書き/共同編集が必要になった場合、オプションコンポーネントとして追加可能）。
>
> 実装の意味合い（確認のため）：
> - `draft/autosave`：ローカルキャッシュへの書き込みのみ。Git commit を発生させない。「一文字打つごとに commit/PR ノイズが発生する」ことを避ける。
> - `publish`：指定された `content/**` ファイル + 画像変更を一度にまとめて GitHub にコミット（デフォルトでは PR 作成を推奨。master への直推も設定可能）。
>
> この収束方向に同意される場合、次のステップ（コード変更の許可後）でこれに基づいて実装します。
> [STATUS:resolved]

> [REVIEW] 1. device flow は受け入れられる。 2. フロントエンドのキャッシュで良いと思う。デバイス間同期の必要性は特にないので、複雑にしないでほしい。
>
> [RESPONSE] 確認を受け取りました：
> 1) OAuth：GitHub device flow を採用（`client_secret` に依存せず、自前のトークン交換バックエンド不要）。
> 2) 下書き：フロントエンドのローカルキャッシュのみ（IndexedDB を主とし、localStorage をフォールバック/小データ用）。デバイス間同期は行わない。
>
> これに基づき、全体設計を以下のように収束させます：
> -   **真実のソース（公開済み）**：GitHub リポジトリ `content/**`（PR/push 経由で書き戻し）
> -   **下書き（下書き/自動保存）**：ローカルキャッシュ（Supabase/GitHub Discussions/Issues は不要）
> -   **画像**：公開時にリポジトリにまとめて書き込み（例：`static/images/uploads/...`）。Markdown 内ではサイト内パスを参照
> [STATUS:resolved]

## 推奨実装（デフォルト前提に基づく）

現在の実装は案 D（バックエンドレス）を直接実装します：

1.  `/admin/` 静的ページ：GitHub に接続（device flow）、`content/**.md` のリストを取得。
2.  ファイル読み込み：解析し、front matter と本文を分離。本文は Vditor で編集。
3.  下書き：入力時に debounce して IndexedDB にローカル保存（GitHub には書き込まない）。
4.  画像：「画像挿入」で pending asset として登録し、サイト内パス（`/images/uploads/...`）を挿入。公開時にリポジトリの `static/images/uploads/...` にまとめてコミット。
5.  公開：ブランチ作成 + PR（Markdown + 画像を含む1回のコミット）。マージ後、既存の Zola デプロイワークフローをトリガー。

## セキュリティとリスク一覧（検証/テストが必要）

-   エディタが `{{ ... }}`（Zola shortcodes）と front matter を忠実に扱えるか（特に WYSIWYG モード）。
-   XSS：Markdown 内で raw HTML を許可する場合、サイトに公開するとインジェクションリスクが生じる（「公開前」にルール制約/フィルタリングが必要）。
-   GitHub トークン scope：可能な限り最小限に（public リポジトリの場合は `public_repo`）。
-   admin ページのインデックス：`noindex` が必要（または推測不可能なパス/追加のゲートを設置）。検索エンジンに収集されないようにする。

## 範囲

-   static/css/*
-   templates/*
-   static/js/*
-   scripts/*
-   .github/*
-   .legion/**

## 段階概要

1.  **現状監査と制約** - 2 タスク
2.  **エディタ選定調査** - 2 タスク
3.  **バックエンドとデータモデル設計** - 2 タスク
4.  **統合案詳細設計と実装計画** - 2 タスク

---

*作成日: 2026-01-06 | 最終更新: 2026-01-06*