---
"title": "Internship Log (II): Backend API Server Development Summary"
"summary": "This article is the author's summary log of developing a backend API server as the project team lead during an internship. It details the design philosophy of the project 'Seed' (a goal management system primarily featuring a WeChat Mini Program), including clarifying the product positioning, system features (such as user system, goal management, WeChat compatibility), and RESTful API architecture. For implementation, the author chose the Spring ecosystem as the technology stack and shares practices of test-driven development during the process. The article also reflects on shortcomings as a project manager regarding schedule control, personnel allocation, and technical training, and discusses the balance software engineers need between system architecture capabilities and algorithm implementation skills. Finally, the author believes the internship effectively compensates for deficiencies in classroom education, helping to avoid the contradiction between grades and practical ability."
"tags":
  - "Internship"
  - "Backend Development"
  - "Project Management"
  - "Spring Framework"
  - "WeChat Mini Program"
  - "RESTful API"
  - "Software Design"
  - "Learning Summary"
"date": "2017-03-12"
---

---
title: Internship Log (II)
date: 2017-03-12 16:09:19
taxonomies:
  tags:
    - Daily
    - Internship
    - Reflections
---

The internship is nearing its end, and the coding work for the basic version of the backend API server is essentially complete. Here's a summary.

As the project team lead, my only knowledge about software project management came from reading *The Mythical Man-Month* once during winter break. Through this practical experience, I realized I'm still quite green. Nevertheless, I believe I've learned a few things.

<!--more-->

## Design

Compared to two years ago when I would immediately open VS to write C language assignments without a second thought, I've clearly changed somewhat today.

~~First off, I haven't opened VS in a long time.~~

In any case, over these two years, I've gone through various intensive coding phases: the naive and pure practice while learning Python, the trials of writing the upper computer software for the robotics team, the experience of writing crawlers for the academic affairs office website (both teacher and student sides), and developing the file management tool during the Orange Juice project. Initially, of course, I just charged ahead, but I guess after suffering enough from inconsistencies, I learned the importance of upfront design. Once you step into the realm of design, it becomes a matter of degree—so this experience of overseeing the entire project has been a very beneficial exercise.

**First, clarify what to do.** This question is crucial for a team genuinely wanting to build a product: **defining your own product** is a strategic-level task. However, it's a pity we didn't have any particularly interesting ideas this time. With responsibility on my shoulders, my expectation for this internship was to seriously create a reliable, simple project.

In short, it's a **traditional web application primarily featuring a WeChat Mini Program**—specifically, a goal management system.

So many people have built this kind of thing, so modeling the tasks we'd face could draw from many mature solutions: tools like Worktile (project-oriented), WonderList (personal life management), My Study Life (student-oriented), and even Apple's Reminders and other tools I've heard of but haven't used. Synthesizing the features of these tools, we distilled a classic, WeChat-flavored goal management system—this became our project, `Seed`.

### Features It Should Have

So what should `Seed` be able to do?

+ Have a simple user system for easy synchronization and increased user retention.
+ Users can freely create and manage goals, similar to Worktile's "projects."
+ Users can be invited into others' goals.
+ Goals are categorized into daily check-in types (recurring) and project攻坚 types (one-time, possibly with milestones).
+ The primary frontend is a WeChat Mini Program.
+ Also compatible with other potential clients.

From this, `Seed` should be a small, streamlined, and practical service, which aligns perfectly with the original intent of WeChat Mini Programs.

Here, it's essential to emphasize the characteristic of being **"small and streamlined."** Why small and simple? First, limited manpower and time. Second, to avoid the mistake often made in "second projects" as mentioned in *The Mythical Man-Month*: blind arrogance,疯狂地 adding endless redundancy to a project. This is a thankless and foolish endeavor, especially since—we're not dealing with advertising revenue. A simple example: Mac OS版迅雷 vs. Win版迅雷; clearly, everyone prefers the streamlined and usable Mac version.

It must also have good compatibility with WeChat Mini Programs. To provide a smooth user experience, it should support both email as a login credential and WeChat openId for login.

### System Structure

As mentioned, we're building a web application primarily featuring a WeChat Mini Program, meaning `Seed` has the capability ~~and ambition~~ to be compatible with other frontends. Therefore, a RESTful-style API became the best choice: complete decoupling of frontend and backend, clear structure, and easy consumption.

Thus, `Seed` should consist of a WeChat Mini Program and other potential forms as frontends, consuming "resources" provided by the backend via the HTTP protocol.

The backend provides secure and reliable services through APIs.

In the process, I also learned a bit and encountered the concept of HATEOAS (Hypermedia As The Engine Of Application State). Though not yet mature, it represents a possible future.

## Implementation

Since I only participated in the coding work for the API server, I'll only discuss the backend implementation here.

I like to categorize design as the strategic level (the "Way"), and the remaining work as the tactical level (the "Technique"). Therefore, choosing what technology to use and how to specifically implement a system falls here.

### Technology

Due to internship requirements and a desire to use the Java language appropriately, I chose the `Spring Framework` as the backend framework, along with the entire Spring ecosystem:

+ Spring Boot as the application container
+ Spring Framework for implementing business logic
+ Spring Data as the DAO
+ Spring Session for session management
+ Spring Test for testing

Additionally, tools like Git, Travis CI, and Heroku were used to improve the development experience.

### Development Process

As mentioned before, the experience of writing Spring Controllers is very similar to that of Python's Flask web framework. Perhaps Flask drew some inspiration from Spring? I think resource-oriented controller classes are much more compact compared to the traditional Java Web approach of writing a Servlet for each resource.

Spring advocates test-driven development. Actually doing this isn't easy, as testing isn't always a popular task. Assigning a dedicated person to write test code would involve a high learning cost and some interpersonal issues. So during development, I decided to have each person responsible for testing their own code. I would then review the code.

## Summary

The noteworthy parts about `Seed` itself have been covered. Now, let's talk about other things.

### Summary of Myself

I learned a lot during the internship, but there are still issues.

As a project manager, I was pretty terrible. There were significant shortcomings in controlling the schedule, allocating personnel, and handling other details.

For example:

- Lack of knowledge about frontend technologies likely means only the API server will be functional in the final project.
- Only half of the project team members were truly engaged.
- Training for those who participated seemed空洞 and lacked patience.

Clearly, I still need further training. However, serving as both project manager and developer led me to ponder another issue.

### Discussion on Two Capabilities of a Software Engineer

**The ability to architect and oversee the entire system** and **the ability to choose, tailor, and implement algorithms for single functions.**

The classroom education in our university's software school seems to focus only on the latter. This isn't strange, as mastery of algorithms is easily measurable. One could say differences in ability are显著, like solving math problems—people's creativity is very easy to evaluate under strict preconditions and constraints. But the ability to reasonably set these so-called "strict preconditions and constraints," though important, is difficult to measure.

As for why it's self-contradictory, here's a simple, understandable, though perhaps not entirely appropriate, example: Everyone knows it's幼稚 and unrealistic for parents to strictly forbid their children from early relationships for fear of affecting studies, yet希望 their children to immediately start a family after graduation. Implicitly expecting students to become all-round talents after graduation **solely** based on good academic performance is also a slightly扭曲 notion. The difference between these two situations is that the latter's contradiction isn't as尖锐 as the former's.

I believe such internships indeed compensate for the shortcomings of classroom education and offer an opportunity to avoid the contradiction between **grades** as a cultivation手段 and **ability** as the cultivation goal—the things these two symbols represent.