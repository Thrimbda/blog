---
"title": "Ein RBAC-Demo: Für Aiur"
"summary": "Dieser Artikel stellt ein RBAC-Praxis-Demo namens 'Für Aiur' vor, das mit dem Python-Flask-Framework einen RESTful-Dienst aufbaut und die Ressourcenverwaltung sowie Rollenberechtigungssteuerung im Spiel StarCraft simuliert. Der Artikel analysiert detailliert das Design von Subjekten, Rollen, Ressourcen und Berechtigungen im Demo und zeigt anhand von Codebeispielen, wie die SA- (Subjekt-Rolle) und PA- (Rolle-Berechtigung) Beziehungen im RBAC-Modell implementiert werden. Darüber hinaus wird erläutert, wie RBAC mit der RESTful-Architektur kombiniert wird, sowie die Geschäftslogik und Implementierungsdetails des Demos. Abschließend fasst der Autor die gewonnenen Erkenntnisse über RBAC, das Flask-Framework und RESTful-Konzepte durch diese Praxis zusammen."
"tags":
  - "RBAC"
  - "RESTful"
  - "Flask"
  - "Systemdesign"
  - "Python"
  - "Berechtigungsverwaltung"
  - "StarCraft"
  - "Demo"
"date": "2017-05-11"
---

---
title: Ein RBAC-Demo: Für Aiur
date: 2017-05-11
taxonomies:
  tags:
    - Systemdesign und -analyse
    - RESTful
    - RBAC
---

Basierend auf dem Verständnis von RBAC aus dem vorherigen Artikel und aufgrund von Aufgabenanforderungen werde ich ein einfaches Demo als RBAC-Praxis erstellen.

Ich habe nicht vor, das Demo übermäßig komplex zu gestalten. Mein Ziel ist es, das Problem zu veranschaulichen, daher gilt auch hier: "Klein, aber fein."

Was ist also das Ziel dieses Demos und was kann es tun?

<!--more-->

## Analyse und Design

Um es interessant zu gestalten und das Problem angemessen darzustellen, simuliere ich in meinem Demo eine stark vereinfachte Szene, in der jede Einheit auf wundersame Weise subjektive Initiative besitzt, wie sie ein Protoss-Spieler in einer StarCraft-Partie erleben könnte.

Ein gutes Demo braucht einen guten Namen, daher heißt dieses Demo: **Für Aiur!** (Aiur ist der Heimatplanet der Protoss. Jeder Zealot sagt beim Betreten des Schlachtfelds diesen begeisterten Satz: "Für Aiur!")

In **Für Aiur** führst du dein Team an, um genügend Zealot-Krieger zu produzieren, den Zerstörer Amon zu vernichten und das gesamte Universum zu retten. Wenn du nicht genug Zealots hast, wirst du scheitern, die Sterne flüstern und alles wird vernichtet.

All dies wird in einem RESTful-Dienst umgesetzt, der mit dem Python-Flask-Framework geschrieben wurde.

> Im realen Szenario könnte jedes Subjekt außer dem Spieler erstellt werden und würde daher als Ressource betrachtet werden. Um RBAC zu demonstrieren, habe ich jedoch die folgenden Einschränkungen hinzugefügt:
>
> - Die im Demo bereitgestellten Subjekte sind einzigartig und existieren immer, als wären sie unverwechselbar. Daher ist auch die Möglichkeit ausgeschlossen, dass Subjekte rekursiv erstellt werden können (z. B. kann eine Probe einen Nexus bauen, und der Nexus kann Proben produzieren).
> - Eigentlich benötigen Warpgates Energie von Pylonen, um zu funktionieren, aber das wird hier nicht dargestellt. Ich erkläre es damit, dass unsere Warpgates Energie von der protossischen Flagship Spear of Adun im synchronen Orbit erhalten, sodass Pylonen nur als Ressource für die Bevölkerungsgrenze betrachtet werden.

Diese Partie enthält die folgenden Objekte:

### Subjekte (Subject)

- Spieler (du) thrimbda
- Probe (grundlegende Arbeitseinheit, kann Ressourcen sammeln und Gebäude bauen) probe
- Warpgate (produziert Zealots, eine Kampfeinheit) gateway

#### Rollen (Role)

- Archon (Oberbefehlshaber, verwaltet alle Ressourcen) archon
- Kristallsammler (nur Proben können diese Rolle übernehmen) crystal_collector
- Warpgate als Knotenpunkt für Zealot-Warping (ein Leuchtfeuer, das das Warping von Protoss-Kriegern unterstützt) portal
- Pylon-Erbauer (mit Pylonen können wir genügend Bevölkerungsgrenzen für das Warping von Zealots bereitstellen) pylon_transporter

### Ressourcen (Resource)

- Ungesammelte Kristalle (zum Bau von Pylonen und Warping von Zealots, Anfangswert unbekannt)
- Gesammelte Kristalle (zum Bau von Pylonen und Warping von Zealots, Anfangswert 0)
- Kapazität (stellt Energie für das Warping bereit, also die sogenannte Bevölkerung, Anfangswert 0)
- Zealots (Kampfeinheiten, deine Krieger zur Rettung des Universums, Anfangswert 0)

### Berechtigungen (Permission)

> Da jede Operation auf eine Ressource eine Berechtigung darstellt, listen wir hier nicht separat die Operationen auf, sondern geben direkt die Berechtigungen und ihre Beschreibungen an.

- Kristalle sammeln (maximal 1000 Einheiten pro Sammelvorgang)
- Ungesammelte Kristalle beobachten (Gesamtmenge anzeigen)
- Statusbericht (aktuelle Ressourcenmenge melden)
- Amons Stärke auskundschaften (benötigte Anzahl an Zealots berechnen)
- Pylon bauen (jeder Pylon bietet 10 Kapazitätseinheiten und kostet 100 Kristalle)
- Zealot produzieren (jeder Zealot verbraucht 2 Kapazitätseinheiten und kostet 100 Kristalle)
- Amon angreifen (Sieg oder Tod!)

### SA

> Die vielen-zu-vielen-Beziehungen zwischen Subjekt-Rolle und Rolle-Berechtigung werden mit Pythons Tupel-Datenstruktur dargestellt und auch in der Implementierung so umgesetzt. Daher wird in dieser Anwendung keine Datenbank verwendet.

```python
subject_role = (('thrimbda', 'archon'),
                ('probe', 'crystal_collector'),
                ('probe', 'pylon_transporter'),
                ('gateway', 'portal'))
```

### PA

```python
role_permission = (('archon', 'get_status'),
                   ('archon', 'for_aiur'),
                   ('archon', 'scout'),
                   ('crystal_collector', 'get_crystal'),
                   ('crystal_collector', 'crystal_status'),
                   ('pylon_transporter', 'get_status'),
                   ('pylon_transporter', 'transport_pylon'),
                   ('portal', 'transport_zealot'),
                   ('portal', 'get_status'))
```

## Implementierung

[Repository-URL](https://github.com/Thrimbda/my-life-for-Aiur)

[Online-Bereitstellung](https://my-life-for-aiur.herokuapp.com/) (langsam)

### Übersicht

Zusammenfassend habe ich mit dem Python-Flask-Framework einen RESTful-Dienst erstellt. Die gesamte Anwendung umfasst keinen Frontend-Teil, daher gibt es auch keine Sicherheitsprobleme wie das Umgehen des Frontends.

Ein Merkmal dieses Demos ist, dass keine Datenbank verwendet wird. RBAC erfordert keine Datenbank, und die Verwendung einer Datenbank in RBAC ist intuitiv und natürlich. In **Für Aiur** verwenden wir jedoch keine Datenbank, sondern stellen die `Subjekt-Rolle-Berechtigung`-Beziehungen von RBAC in Dateiform dar. Datenbanken haben sich auf Basis von Dateisystemen entwickelt. Hier verwenden wir Dateien, weil das System einfach genug ist, um die Komplexität weiter zu reduzieren und das Problem zu veranschaulichen. Die konkrete Dateiform ist in den obigen SA- und PA-Beziehungen beschrieben.

### Über RESTful

Hier kurz zu RESTful (**Re**presentational **S**tate **T**ransfer)

Wie der Name schon sagt: (Ressourcen-)Darstellungsschicht-Zustandsübertragung.

In einem Web-Dienst sind die bereitgestellten Dienste die Ressourcen des Systems, die in Form von URIs dargestellt werden. Die Form des Dienstes ist die Operation auf Ressourcen (Zustandsübertragung), die durch HTTP-Verben dargestellt wird. Diese Konzepte lassen sich gut mit den Ressourcen und Operationen in RBAC korrelieren. Daher muss ich lediglich die Berechtigungsverwaltung von RBAC auf die Operationen an Ressourcen in REST anwenden.

### Die Objekte in RBAC

Wie in den beiden Konfigurationsdateien zu sehen ist, können wir neben SA und PA implizit S, R und P ableiten:

```python
# Leite die S- und R-Listen aus dem obigen Tupel subject_role ab
subjects = list(set([item[0] for item in subject_role]))
roles = list(set([item[1] for item in subject_role]))
```

SE lässt sich gut mit der Session in einer Webanwendung korrelieren, als temporäres Objekt für ein Subjekt während einer Anmeldung:

```python
# Das Subjekt meldet sich über die API des Spear of Adun-Taktikmanagementsystems an. Hier ist session ein globales Objekt von Flask, dessen Implementierungsdetails nicht weiter erläutert werden.
class SpearOfAdun(Resource):
    
    def post(self):
        args = self.putparser.parse_args()
        if args['subject'] is not None:
            abortInvalideSubject(args['subject'])
        if args['role'] is not None:
            abortInvalideRole(args['role'])
        checkRole(args['subject'], args['role'], subject_role)
        session['subject'] = args['subject']
        session['role'] = args['role']
        return {'message': 'login as %s using %s' % (session['subject'], session['role'])}, 201
```

Da die Modellierung von Subjekt-Rolle letztendlich darauf abzielt, Berechtigungen zu isolieren und zuzuweisen, damit die Ressourcen im System ordnungsgemäß genutzt und geschützt werden können.

In **Für Aiur** definiere ich Berechtigungen als interne Eigenschaften der Web-API, z. B.:

```python
# API zum Warpen von Zealots
class Zealot(Resource):

    def put(self):
        permission = 'transport_zealot' # Berechtigung
        abortIfSubjectUnauthenticated(session) # Anmeldeüberprüfung
        checkPermission(session['role'], permission, role_permission) # Prüfen, ob das Subjekt in dieser Rolle diese Berechtigung anfordern kann
        args = self.putparser.parse_args()
        amount = nexus.transport(args['amount'])
        return {'message': 'transport %d zealot warriors, En Taro Tassadar!' % amount}, 200
```

In den beiden oben als Beispiel genannten APIs stellt jede Klasse eine Ressource im System dar, und die bereitgestellten HTTP-Methoden sind Operationen auf diesen Ressourcen.

**Damit sind alle Objekte in RBAC versammelt.**

### Geschäftslogik

Da **Für Aiur** ein echtes, spielbares Echtzeitstrategie-Spiel-API ist, ist es notwendig, seine Geschäftslogik zu erläutern:

Das Ziel des Spielers ist: **Ressourcen sammeln, eine Basis bauen und dann eine Armee erschaffen, die deine Feinde in Angst und Schrecken versetzt, um den Dunklen Amon zu besiegen.**

Die einzige Bedingung, um Amon zu besiegen, ist, eine ausreichende Anzahl von Zealots zu haben. Diese Anzahl ist eine zufällig generierte Ganzzahl zwischen 20 und 100. Gleichzeitig generiert das System basierend auf diesen Daten genau genug ungesammelte Kristalle, um Amon zu besiegen.

**Warum genau genug?**

Da das Warpen von Zealots eine ausreichende Menge an Kristallenergie und Kristallen erfordert und die Pylonen, die Energie bereitstellen, ebenfalls Kristalle zum Bau verbrauchen. Wenn du also zu viele Pylonen baust, reicht zwar die Kristallenergie aus, aber du wirst **die entscheidende Schlacht um das Schicksal des gesamten Universums verlieren, weil du nicht genug Kristalle zum Warpen von Zealots hast**.

Die gesamte Logik wird von einem Objekt bereitgestellt, dessen Lebenszyklus die gesamte Schlacht umspannt. Um Probleme zu vermeiden, habe ich eine Thread-Sperre hinzugefügt, um sicherzustellen, dass jede Operation atomar ist.

```python
# Da es der Kern des gesamten Spiels ist, nenne ich es Nexus
import random
from threading import Lock


class Nexus(object):
    _lock = Lock()
    crestalInControl = None
    crestalRemain = None
    populationCap = None
    zealot = None
    status = {}
    _amond = None

    def __init__(self):
        # Objekt initialisieren
        self._amond = random.randint(20, 100)
        self.crestalRemain = self._amond * 100 + (self._amond // 5 + 1) * 100
        self.crestalInControl = 0
        self.populationCap = 0
        self.zealot = 0

    def collect(self, amount=1000):
        # Kristalle sammeln
        with self._lock:
            amount = min(amount, self.crestalRemain)
            self.crestalRemain -= amount
            self.crestalInControl += amount
            return amount

    def transport(self, amount=5):
        # Zealots warpen
        with self._lock:
            capacity = self.populationCap / 2
            available = self.crestalInControl / 100
            amount = min(amount, capacity, available)
            self.zealot += amount
            self.crestalInControl -= amount * 100
            self.populationCap -= amount * 2
            return amount

    def build(self, amount=1):
        # Pylon bauen
        with self._lock:
            available = self.crestalInControl / 100
            amount = min(amount, available)
            self.populationCap += amount * 10
            self.crestalInControl -= amount * 100
            return amount

    def forAiur(self):
        # Für Aiur kämpfen!
        with self._lock:
            if self.zealot >= self._amond:
                return True
            else:
                return False

    def getStatus(self, role):
        # Status abrufen
        if role == 'archon':
            return {
                'crestalInControl': self.crestalInControl,
                'crestalRemain': self.crestalRemain,
                'populationCap': self.populationCap,
                'zealot': self.zealot
            }
        elif role == 'pylon_transporter':
            return {
                'crestalInControl': self.crestalInControl,
                'populationCap': self.populationCap
            }
        elif role == 'portal':
            return {
                'crestalInControl': self.crestalInControl,
                'populationCap': self.populationCap,
                'zealot': self.zealot
            }
        else:
            return {}


nexus = Nexus() # Objekt instanziieren
```

## Fazit

Eigentlich ist StarCraft II in jeder Partie ein typisches DAC-Modell: Der Spieler beherrscht alles, und alle Operationen im Spiel können als Zustandstransformation der beiden Grundressourcen Kristalle und Vespengas (das hier vereinfacht wurde) betrachtet werden, um die benötigten Ressourcen des Spielers (Produktionseinheiten, Kampfeinheiten) zu werden und die Ressourcen des Gegners zu verbrauchen, um die Partie zu gewinnen. Dies zeigt, dass der RESTful-Dienst-Ansatz sehr universell ist.

In dem kleinen Spiel **Für Aiur** habe ich mehrere Rollen festgelegt und ein RBAC-Modell konstruiert.

Durch diese Praxis habe ich die Anwendung von RBAC in einem System verstanden, das Flask-Framework weiter gelernt und die RESTful-Idee vertieft, was sehr lehrreich war.