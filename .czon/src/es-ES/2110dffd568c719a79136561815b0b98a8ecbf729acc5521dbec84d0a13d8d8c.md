---
"title": "Registro de Prácticas (II): Resumen del Desarrollo de API Backend y Gestión de Proyectos"
"summary": "Este artículo es el registro resumen del autor después de completar básicamente el servidor de API backend del proyecto de prácticas. El artículo detalla el diseño del proyecto 'Seed' (un sistema de gestión de objetivos centrado en mini programas de WeChat), incluyendo la definición clara del posicionamiento del producto, las características principales (como sistema de usuarios, gestión de objetivos, compatibilidad multi-cliente, etc.) y la adopción de la arquitectura RESTful API. En cuanto a la implementación, el autor presenta la elección de la pila tecnológica utilizando Spring y comparte la estrategia de pruebas durante el desarrollo. Además, el autor reflexiona sobre sus deficiencias como gestor de proyecto en el control del progreso, asignación de personal y formación técnica, y discute el equilibrio entre la capacidad de arquitectura de sistemas y la implementación de algoritmos específicos requerida por un ingeniero de software, considerando que las prácticas son un complemento importante a la educación en el aula."
"tags":
  - "Prácticas"
  - "Gestión de Proyectos"
  - "Desarrollo Backend"
  - "Framework Spring"
  - "Mini Programas de WeChat"
  - "RESTful API"
  - "Diseño de Software"
  - "Resumen Personal"
"date": "2017-03-12"
---

---
title: Registro de Prácticas (II)
date: 2017-03-12 16:09:19
taxonomies:
  tags:
    - Diario
    - Prácticas
    - Reflexiones
---

Las prácticas están a punto de llegar a su fin. En este punto, el trabajo de codificación de la versión básica del servidor de API backend está prácticamente terminado. Aquí haré un resumen.

Como líder del grupo del proyecto, mi único conocimiento sobre gestión de proyectos de software proviene de haber leído *The Mythical Man-Month* durante las vacaciones de invierno. Después de esta práctica, me doy cuenta de que aún soy muy inexperto. Sin embargo, creo que he aprendido algunas cosas.

<!--more-->

## Diseño

En comparación con hace dos años, cuando empezaba a escribir tareas en C sin pensarlo dos veces y abría VS, hoy en día he cambiado bastante.

~~En primer lugar, hace mucho que no abro VS.~~

En resumen, durante estos dos años he pasado por varias experiencias intensivas de escritura de código: la etapa de aprendizaje puro de Python, la experiencia de escribir el software de control para el robot en el equipo de robótica, la experiencia de escribir crawlers para el sitio web de la oficina académica (tanto para profesores como para estudiantes), y la participación en el proyecto Orange Juice escribiendo una herramienta de gestión de archivos. Al principio, por supuesto, me lancé sin pensar, pero supongo que después de sufrir las consecuencias de las contradicciones, aprendí la importancia de diseñar con anticipación. Una vez que entras en el mundo del diseño, la cuestión pasa a ser el grado de profundidad; por lo tanto, esta experiencia de gestionar todo el proyecto ha sido un ejercicio muy beneficioso.

**Primero, aclarar qué se quiere hacer**. Esta pregunta es crucial para un equipo que realmente quiere crear un producto: **definir su propio producto** es algo a nivel estratégico. Lamentablemente, esta vez no tuvimos ideas particularmente interesantes, y con la responsabilidad sobre mis hombros, mi expectativa para estas prácticas era hacer un proyecto sólido y sencillo.

En pocas palabras, se trata de una **aplicación web tradicional con mini programas de WeChat como característica principal**: concretamente, un sistema de gestión de objetivos.

Hay mucha gente que hace esto, por lo que el modelado de las tareas a enfrentar puede basarse en muchas soluciones maduras: como Worktile, orientado a proyectos; WonderList, orientado a la gestión personal de la vida; My Study Life, orientado a estudiantes; e incluso la aplicación `Recordatorios` de Apple y otras herramientas que he oído mencionar pero no he usado. Sintetizando las características de estas herramientas, resumimos un clásico sistema de gestión de objetivos con características de WeChat: así nació nuestro `Seed`.

### Características que debería tener

Entonces, ¿qué debería poder hacer `Seed`?

+ Tener un sistema de usuarios sencillo para facilitar la sincronización y aumentar la fidelidad del usuario.
+ Los usuarios pueden crear y gestionar libremente objetivos, similares a los `proyectos` de Worktile.
+ Los usuarios pueden ser invitados a los objetivos de otros.
+ Los objetivos se dividen en tipo de registro diario (recurrente) y tipo de proyecto (único, pueden incluir hitos).
+ El frontend principal son los mini programas de WeChat.
+ También es compatible con otros clientes potenciales.

De esto se deduce que `Seed` debería ser un servicio práctico, pequeño y refinado, lo que coincide con el propósito original de los mini programas de WeChat.

Aquí es necesario enfatizar la característica de **"pequeño y refinado"**. ¿Por qué pequeño y simple? Primero, porque no hay suficiente personal y el tiempo es limitado. Segundo, para evitar el error común en los `segundos proyectos` mencionado en *The Mythical Man-Month*: la arrogancia ciega que lleva a agregar infinitas características redundantes a un proyecto. Esto es un esfuerzo inútil, especialmente porque no involucramos ingresos por publicidad. Un ejemplo simple: la versión de Mac OS de Xunlei y la versión de Windows de Xunlei; obviamente, a todos les gusta más la versión Mac, que es más refinada y usable.

También debe tener una buena compatibilidad con los mini programas de WeChat. Para proporcionar una transición fluida en la experiencia del usuario, debería admitir tanto el email como nombre de usuario para iniciar sesión, como el openId de WeChat como credencial de acceso.

### Estructura del sistema

Como se mencionó anteriormente, queremos hacer una aplicación web con mini programas de WeChat como característica principal. Esto significa que `Seed` tiene la capacidad ~~y la ambición~~ de ser compatible con otros frontends. Por lo tanto, las API de estilo RESTful se convierten en la mejor opción: desacoplamiento completo entre frontend y backend, estructura clara y fácil de consumir.

Por lo tanto, `Seed` debería consistir en mini programas de WeChat y otras formas potenciales como frontend, consumiendo los `recursos` proporcionados por el backend a través del protocolo HTTP.

El backend proporciona servicios seguros y confiables a través de API.

Para ello también aprendí un poco, llegando a conocer la idea de HATEOAS (Hypermedia As The Engine Of Application State). Aunque aún no es madura, es un posible futuro.

## Implementación

Dado que solo participé en el trabajo de codificación del servidor de API, aquí solo hablaré de la implementación del backend.

Me gusta clasificar el diseño en el nivel estratégico (el "dao"), y el resto del trabajo en el nivel táctico (el "shu"). Por lo tanto, la elección de tecnologías y cómo implementar concretamente un sistema pueden incluirse aquí.

### Tecnología

Debido a los requisitos de las prácticas, y también por el deseo de utilizar el lenguaje Java de manera adecuada, elegimos `Spring Framework` como framework backend, utilizando además toda la suite de Spring:

+ Spring Boot como contenedor de aplicaciones
+ Spring Framework para implementar la lógica de negocio
+ Spring Data como DAO
+ Spring Session para gestionar sesiones
+ Spring test para pruebas

Además, utilizamos herramientas como Git, TravisCi y Heroku para mejorar la experiencia de desarrollo.

### Proceso de desarrollo

Como mencioné antes, la experiencia de escribir Controllers en Spring es muy similar a la del framework web Flask de Python. ¿Quizás Flask tomó alguna inspiración de Spring? Creo que las clases controladoras orientadas a recursos son mucho más compactas que la forma tradicional de Java Web, donde hay que escribir un Servlet para cada recurso.

Spring promueve el desarrollo guiado por pruebas (TDD), pero llevarlo a cabo no es fácil, ya que las pruebas no suelen ser un trabajo popular. Asignar a una persona específica para escribir código de pruebas tiene un alto costo de aprendizaje y también plantea algunos problemas interpersonales. Por lo tanto, durante el desarrollo decidí que cada persona fuera responsable de probar su propio código. Finalmente, yo revisaría el código.

## Resumen

La parte interesante sobre `Seed` en sí ya ha sido comentada. Ahora hablemos de otras cosas.

### Resumen personal

Aprendí mucho durante las prácticas, pero aún hay problemas.

Como gestor de proyecto, soy bastante incompetente. El control del progreso, la asignación de personal y otros detalles tienen muchas deficiencias.

Por ejemplo:

- La falta de conocimiento sobre tecnologías frontend hace que probablemente solo el servidor de API funcione al final de este proyecto.
- Solo la mitad de las personas en el grupo del proyecto participaron realmente.
- La formación para quienes participaron en el trabajo fue vaga y careció de paciencia.

Obviamente, todavía necesito seguir desarrollándome. Pero el hecho de actuar tanto como gestor de proyecto como desarrollador me llevó a reflexionar sobre otro tema.

### Discusión sobre las dos capacidades de un ingeniero de software

**La capacidad de arquitectura y control de todo el sistema** y **la capacidad de seleccionar, adaptar y utilizar algoritmos para implementar una función específica**.

La educación en el aula de nuestra facultad de software parece centrarse solo en lo segundo. Esto no es extraño, ya que el dominio de algoritmos es fácil de medir; se puede decir que las diferencias en capacidad son evidentes, como resolver problemas matemáticos: bajo condiciones y restricciones estrictas, la creatividad de las personas es muy fácil de evaluar. Sin embargo, la capacidad de establecer racionalmente estas llamadas "condiciones y restricciones estrictas", aunque importante, es difícil de medir.

En cuanto a por qué digo que es contradictorio, pongamos un ejemplo simple y comprensible, aunque quizás no del todo apropiado: todos saben que es ingenuo e irreal que los padres prohíban a sus hijos tener relaciones amorosas tempranas con el pretexto de que afectan los estudios, y luego esperen que formen una familia inmediatamente después de graduarse. Esperar implícitamente que los estudiantes, **solo** con buenas calificaciones académicas, se conviertan en personas completas al graduarse también es una idea algo distorsionada. La diferencia entre estos dos casos es que la contradicción en el segundo no es tan aguda como en el primero.

Creo que este tipo de prácticas son efectivamente una compensación por las deficiencias de la educación en el aula, y ofrecen la oportunidad de evitar la contradicción entre el **rendimiento académico** como medio de formación y la **capacidad** como objetivo de formación, que estos dos símbolos representan.