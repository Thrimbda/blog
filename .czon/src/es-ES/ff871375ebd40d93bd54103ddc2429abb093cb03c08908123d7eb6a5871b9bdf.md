---
"title": "Un Demo de RBAC: Por Aiur"
"summary": "Este artículo presenta un demo práctico de RBAC llamado 'Por Aiur', construido con el framework Flask de Python para simular un servicio RESTful que gestiona recursos y controla permisos de roles en el contexto del juego StarCraft. Se analizan en detalle el diseño de sujetos, roles, recursos y permisos en el demo, y se muestran ejemplos de código sobre cómo implementar las relaciones SA (Sujeto-Rol) y PA (Rol-Permiso) del modelo RBAC. Además, se explica cómo combinar RBAC con la arquitectura RESTful, así como la lógica de negocio y los detalles de implementación del demo. Finalmente, el autor resume lo aprendido sobre RBAC, Flask y el pensamiento RESTful a través de esta práctica."
"tags":
  - "RBAC"
  - "RESTful"
  - "Flask"
  - "Diseño de Sistemas"
  - "Python"
  - "Gestión de Permisos"
  - "StarCraft"
  - "Demo"
"date": "2017-05-11"
---

---
title: Un Demo de RBAC: Por Aiur
date: 2017-05-11
taxonomies:
  tags:
    - Diseño y Análisis de Sistemas
    - RESTful
    - RBAC
---

Basándome en la comprensión de RBAC del artículo anterior, y debido a los requisitos de una tarea, crearé un demo simple como práctica de RBAC.

No pretendo hacer el demo excesivamente grande. Mi objetivo es ilustrar el concepto, por lo que sigue siendo "pequeño como un gorrión, pero con todos los órganos vitales".

Entonces, ¿cuál es el objetivo de este demo? ¿Qué puede hacer?

<!--more-->

## Análisis y Diseño

Para hacerlo interesante y reflejar plenamente el problema, simularé en mi demo una situación muy simplificada de una partida de StarCraft, donde cada unidad milagrosamente ha adquirido agencia subjetiva, desde la perspectiva de un jugador protoss.

Un buen demo necesita un buen nombre, por lo que este demo se llama: **¡Por Aiur!** (Aiur es el planeta natal de los protoss. Cada zealot dice una frase apasionada al ser teletransportado al campo de batalla: "¡Lucho por Aiur!").

En **Por Aiur**, debes liderar a tu equipo para producir suficientes guerreros zealot, derrotar al destructor Amón y salvar el universo. Si no tienes suficientes zealots, fracasarás, las estrellas susurrarán y todo se desvanecerá.

Todo esto se refleja en un servicio RESTful escrito con el framework Flask de Python.

> En realidad, en el escenario real, excepto el jugador, cada sujeto puede ser creado, por lo que todos pueden considerarse recursos. Para reflejar RBAC, les he añadido las siguientes restricciones:
>
> - Los pocos sujetos proporcionados por este demo son únicos y existen siempre, como si fueran irrepetibles, eliminando así cualquier posibilidad de que un sujeto pueda ser creado recursivamente (por ejemplo: un sonda puede producir un nexo, y un nexo puede producir sondas).
> - En realidad, el portal necesita energía de cristales para funcionar, pero aquí no se refleja. Lo explico asumiendo que nuestro portal recibe apoyo energético de la Spear of Adun, la legendaria nave nodriza protoss en órbita sincrónica, considerando así los pilones solo como recursos que proporcionan límite de población.

Esta partida tiene los siguientes objetos:

### Sujetos (Subject)

- Jugador (tú) - thrimbda
- Sonda (unidad de trabajo básica, puede recolectar recursos y construir edificios) - probe
- Portal (produce zealots, una unidad de combate) - gateway

#### Roles (Role)

- Archon (comandante supremo, asigna todos los recursos) - archon
- Recolector de Cristales (solo las sondas pueden asumir este rol) - crystal_collector
- Centro de Teletransporte para Zealots (baliza que soporta el teletransporte de guerreros protoss) - portal
- Constructor de Pilones (con pilones, podemos tener suficiente límite de población para teletransportar zealots) - pylon_transporter

### Recursos (Resource)

- Cristales sin recolectar (usados para construir pilones y teletransportar zealots, valor inicial desconocido)
- Cristales recolectados (usados para construir pilones y teletransportar zealots, valor inicial 0)
- Capacidad de Población (proporciona energía para teletransportes, es decir, nuestra "población", valor inicial 0)
- Zealots (unidades de combate, los guerreros con los que salvarás el universo, valor inicial 0)

### Permisos (Permission)

> Dado que cada operación sobre un recurso es un permiso, aquí no listamos las operaciones por separado, sino que damos directamente los permisos y sus descripciones.

- Recolectar Cristales (máximo 1000 unidades por vez)
- Observar Cristales sin Recolectar (ver el total)
- Reporte de Estado (informa la cantidad actual de recursos que posees)
- Explorar la Fuerza de Amón (calcular la cantidad de zealots necesarios)
- Construir un Pilón (cada pilón proporciona 10 unidades de capacidad de población y cuesta 100 cristales)
- Producir un Zealot (cada zealot consume 2 unidades de capacidad de población y 100 cristales)
- Atacar a Amón (¡Victoria o muerte!)

### SA (Sujeto-Rol)

> La relación muchos-a-muchos entre Sujeto-Rol y Rol-Permiso se representa usando la estructura de datos de tupla múltiple de Python, y así se implementa también en la aplicación. Por lo tanto, esta aplicación no usa base de datos.

```python
subject_role = (('thrimbda', 'archon'),
                ('probe', 'crystal_collector'),
                ('probe', 'pylon_transporter'),
                ('gateway', 'portal'))
```

### PA (Rol-Permiso)

```python
role_permission = (('archon', 'get_status'),
                   ('archon', 'for_aiur'),
                   ('archon', 'scout'),
                   ('crystal_collector', 'get_crystal'),
                   ('crystal_collector', 'crystal_status'),
                   ('pylon_transporter', 'get_status'),
                   ('pylon_transporter', 'transport_pylon'),
                   ('portal', 'transport_zealot'),
                   ('portal', 'get_status'))
```

## Implementación

[URL del Repositorio](https://github.com/Thrimbda/my-life-for-Aiur)

[Despliegue en Línea](https://my-life-for-aiur.herokuapp.com/) (lento)

### Resumen

En resumen, usé el framework Flask de Python para escribir un servicio con estilo RESTful. La aplicación completa no involucra la parte frontend, por lo que tampoco existen problemas de seguridad como eludir el frontend.

Una característica de este demo es que no utiliza una base de datos. RBAC no obliga a usar una base de datos, y aunque usarla en RBAC es intuitivo y natural, en **Por Aiur** no usamos base de datos, sino que usamos archivos para representar la relación `sujeto-rol-permiso` de RBAC. Las bases de datos se desarrollaron sobre la base del sistema de archivos. Aquí usamos archivos porque el sistema es lo suficientemente simple, para reducir aún más la complejidad del sistema con el fin de ilustrar el problema. La forma específica de los archivos se muestra en las descripciones de las relaciones SA y PA anteriores.

### Sobre RESTful

Mencionemos brevemente RESTful (**Re**presentational **S**tate **T**ransfer)

Como su nombre indica, Transferencia de Estado Representacional (de recursos).

En un servicio web, los servicios proporcionados son los recursos del sistema, representados en forma de URI, y la forma del servicio son las operaciones sobre los recursos (cambio de estado), representadas por verbos HTTP. Varios conceptos aquí pueden corresponder bien con los recursos y operaciones en RBAC, por lo que lo que debo hacer es aplicar la gestión de permisos de RBAC a las operaciones sobre recursos en REST.

### Los objetos en RBAC

Se puede ver que en estos dos archivos de configuración, además de SA y PA, podemos obtener implícitamente S, R, P:

```python
# Obtener las listas S y R a partir de la tupla subject_role anterior
subjects = list(set([item[0] for item in subject_role]))
roles = list(set([item[1] for item in subject_role]))
```

Y SE (Sesión) puede corresponder bien con la sesión en una aplicación web, como un objeto temporal para un sujeto durante un inicio de sesión:

```python
# El sujeto usa esta API para iniciar sesión en el sistema de gestión táctica de la Spear of Adun. Aquí, session es un objeto global de Flask, cuyos detalles de implementación no se repetirán.
class SpearOfAdun(Resource):
    
    def post(self):
        args = self.putparser.parse_args()
        if args['subject'] is not None:
            abortInvalideSubject(args['subject'])
        if args['role'] is not None:
            abortInvalideRole(args['role'])
        checkRole(args['subject'], args['role'], subject_role)
        session['subject'] = args['subject']
        session['role'] = args['role']
        return {'message': 'login as %s using %s' % (session['subject'], session['role'])}, 201
```

Dado que el modelado Sujeto-Rol tiene como objetivo final aislar y asignar permisos, permitiendo que los recursos del sistema sean utilizados y protegidos adecuadamente.

En **Por Aiur**, defino los permisos como atributos internos de la API web, por ejemplo:

```python
# API para teletransportar zealots
class Zealot(Resource):

    def put(self):
        permission = 'transport_zealot' # Permiso
        abortIfSubjectUnauthenticated(session) # Verificación de inicio de sesión
        checkPermission(session['role'], permission, role_permission) # Verificar si el sujeto en este rol puede solicitar este permiso
        args = self.putparser.parse_args()
        amount = nexus.transport(args['amount'])
        return {'message': 'transport %d zealot warriors, En Taro Tassadar!' % amount}, 200
```

Y en las dos APIs usadas como ejemplo anteriormente, cada clase existe como un recurso en el sistema, y los métodos HTTP proporcionados son las operaciones sobre los recursos.

**Hasta aquí, todos los objetos de RBAC están presentes.**

### Lógica de Negocio

Dado que **Por Aiur** es una API jugable en línea de un juego de estrategia en tiempo real, es necesario explicar su lógica de negocio:

El objetivo del jugador es: **Recolectar recursos, construir una base, y luego crear un ejército que aterrorice a tus enemigos para derrotar al oscuro Amón.**

La única condición para derrotar a Amón es tener un número suficiente de zealots, y este número es un entero aleatorio generado por el sistema entre 20 y 100. Simultáneamente, el sistema generará la cantidad exacta de cristales sin recolectar necesarios para que derrotes a Amón.

**¿Por qué exactamente suficiente?**

Dado que teletransportar zealots requiere una cantidad suficiente de energía de cristales y cristales minerales, y los pilones que proporcionan energía también consumen cristales para ser producidos. Por lo tanto, si construyes demasiados pilones, aunque la energía de cristales sea suficiente, **perderás esta batalla que decide el destino del universo por no tener suficientes cristales para teletransportar zealots**.

Toda esta lógica la proporciona un objeto cuyo ciclo de vida abarca toda la batalla. Para evitar problemas, he añadido un bloqueo de hilo (thread lock) para asegurar que cada operación sea atómica.

```python
# Dado que es el núcleo de todo el juego, lo llamo Nexus
import random
from threading import Lock


class Nexus(object):
    _lock = Lock()
    crestalInControl = None
    crestalRemain = None
    populationCap = None
    zealot = None
    status = {}
    _amond = None

    def __init__(self):
        # Inicializar el objeto
        self._amond = random.randint(20, 100)
        self.crestalRemain = self._amond * 100 + (self._amond // 5 + 1) * 100
        self.crestalInControl = 0
        self.populationCap = 0
        self.zealot = 0

    def collect(self, amount=1000):
        # Recolectar cristales
        with self._lock:
            amount = min(amount, self.crestalRemain)
            self.crestalRemain -= amount
            self.crestalInControl += amount
            return amount

    def transport(self, amount=5):
        # Teletransportar zealots
        with self._lock:
            capacity = self.populationCap / 2
            available = self.crestalInControl / 100
            amount = min(amount, capacity, available)
            self.zealot += amount
            self.crestalInControl -= amount * 100
            self.populationCap -= amount * 2
            return amount

    def build(self, amount=1):
        # Construir pilón
        with self._lock:
            available = self.crestalInControl / 100
            amount = min(amount, available)
            self.populationCap += amount * 10
            self.crestalInControl -= amount * 100
            return amount

    def forAiur(self):
        # ¡Luchar por Aiur!
        with self._lock:
            if self.zealot >= self._amond:
                return True
            else:
                return False

    def getStatus(self, role):
        # Obtener estado
        if role == 'archon':
            return {
                'crestalInControl': self.crestalInControl,
                'crestalRemain': self.crestalRemain,
                'populationCap': self.populationCap,
                'zealot': self.zealot
            }
        elif role == 'pylon_transporter':
            return {
                'crestalInControl': self.crestalInControl,
                'populationCap': self.populationCap
            }
        elif role == 'portal':
            return {
                'crestalInControl': self.crestalInControl,
                'populationCap': self.populationCap,
                'zealot': self.zealot
            }
        else:
            return {}


nexus = Nexus() # Instanciar el objeto
```

## Conclusión

En realidad, cada partida de StarCraft II es un modelo DAC típico: el jugador lo domina todo, y todas las operaciones en el juego pueden verse como la transformación de estado de los dos recursos básicos, cristales minerales y gas vespene (que he simplificado aquí), en los recursos que el jugador necesita (unidades de producción, unidades de combate) para consumir los recursos del enemigo y ganar la partida. Esto demuestra que el pensamiento de los servicios RESTful es muy universal.

En el pequeño juego **Por Aiur**, solidifiqué varios roles, construyendo un modelo RBAC.

En esta práctica, comprendí la aplicación de RBAC en un sistema, y además aprendí más sobre el excelente framework Flask, entendiendo más profundamente el pensamiento RESTful, con muchas ganancias.