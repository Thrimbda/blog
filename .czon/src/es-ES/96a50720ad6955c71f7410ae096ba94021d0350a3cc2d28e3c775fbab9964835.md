---
"title": "Diseño de la Integración de Editor WYSIWYG con Backend GitHub para un Blog Zola"
"summary": "Este documento detalla el plan para añadir funcionalidad de edición WYSIWYG en tiempo real de Markdown a un blog Zola existente. El objetivo principal es mantener el estilo de diseño actual y evitar la introducción de un backend personalizado. Mediante el análisis del estado actual y los principios de diseño, el documento recomienda una arquitectura de implementación puramente frontend, utilizando el flujo de dispositivo OAuth de GitHub para la autenticación, guardando borradores localmente y publicando contenido de vuelta al repositorio GitHub mediante la creación de un PR. Este esquema garantiza una experiencia de edición con vista previa en tiempo real y guardado automático, al tiempo que define claramente la ruta de sincronización de contenido sin alterar la estructura existente. El documento también discute otras opciones candidatas, riesgos de seguridad y fases de implementación."
"tags":
  - "Zola"
  - "WYSIWYG"
  - "Markdown"
  - "GitHub"
  - "Frontend"
  - "Edición en tiempo real"
  - "Sin backend"
  - "Blog"
"date": "2026-01-06"
---

# Blog Zola: Diseño del Esquema de Edición WYSIWYG de Markdown en Tiempo Real + Backend Supabase/GitHub

## Objetivo

Diseñar y planificar un esquema de integración de un editor WYSIWYG con edición en tiempo real de Markdown y un backend "sin código personalizado" (Supabase o GitHub Issue/Discussion) para el blog Zola actual, sin alterar el estilo de diseño CSS existente.

## Principios de diseño (deben cumplirse)

- Mantener el lenguaje visual actual de suCSS + variables CSS (incluyendo el cambio de tema claro/oscuro)
- Evitar en la medida de lo posible la introducción de un backend personalizado; priorizar la conexión directa desde el frontend a las APIs de Supabase o GitHub
- Si se requiere React/shadcn, debe justificarse la razón, el coste y el plan de reversión para introducir la cadena de construcción
- La experiencia de edición debe soportar vista previa/renderizado en tiempo real y guardado automático (al menos para borradores)
- Definir claramente la ruta de sincronización del contenido publicado hacia Zola (sin romper la estructura de `content` existente)

## Resumen del estado actual (de la auditoría)

- Este proyecto es un sitio Zola (sin cadena de construcción Node/React), todo el CSS/JS se sirve desde `static/`, y se permite incluir dependencias CDN en `templates/head.html`.
- El tema/colores está completamente impulsado por variables CSS en `static/css/suCSS.css`; JS cambia entre claro/oscuro mediante `data-theme` (`static/js/script.js`).
- La fuente de contenido son archivos Markdown en `content/**`; contienen front matter YAML (`---`) y shortcodes de Zola (como `{{ slideshow(...) }}`).

## Puntos de incertidumbre que necesitas revisar (por favor responde/selecciona)

1.  **Alcance de la edición**: ¿Solo necesitas editar uno/pocos archivos específicos (por ejemplo, `content/gcores-talks.md`) o deseas "poder editar cualquier página en `content/**`"?
2.  **Edición en tiempo real**: Tu "en tiempo real" se refiere a:
    - A) Vista previa/renderizado en tiempo real dentro del editor es suficiente (una sola persona)
    - B) Necesita guardado automático de borradores en segundo plano (una sola persona)
    - C) Necesita colaboración múltiple/edición simultánea (varios usuarios)
3.  **Canal de publicación**: ¿Cómo deseas que el resultado de la edición afecte finalmente al sitio?
    - A) Solo guardar en una biblioteca de borradores (no entra automáticamente en `content/`)
    - B) Publicación con un clic: Sincronización automática al `content/` del repo y activación de la construcción de Zola
    - C) Semiautomático: Exportar archivo/generar parche, para que lo confirmes manualmente
4.  **Autenticación**: El admin es solo para tu uso, ¿aceptas "enlace mágico por email de Supabase + lista de permitidos de un solo usuario"?
5.  **Imágenes**: ¿Necesitas subir imágenes directamente desde el editor? Si es así, ¿aceptas que las imágenes se almacenen en Supabase Storage y se referencien como enlaces externos en Markdown?

> [REVIEW]
> 1. Quiero editar archivos arbitrarios, y luego enviarlos al repositorio de GitHub de alguna manera. Si se necesita un backend, se debe argumentar su necesidad.
> 2. A y B
> 3. B
> 4. Esta versión es solo para mí, solo necesito admin, mientras sea seguro. Incluso aceptaría tener un par de claves de curva elíptica y usarlo para autenticarme, como SSH.
> 5. Necesito subir imágenes y prefiero que se guarden en el repositorio.
>
> [RESPONSE] Recibido. Ajustaré las suposiciones predeterminadas/orientación del esquema según tus respuestas:
>
> 1) Alcance de la edición: Cambiado a "poder editar cualquier archivo en `content/**`" (y permitir extensión a `templates/**` etc., pero MVP primero se limita a `content/**` para reducir riesgo). La ruta de publicación tiene como objetivo central "escribir de vuelta al repositorio GitHub"; ya no usar Supabase como fuente de verdad.
>
> 2) Edición en tiempo real: Elegir A + B -- Renderizado/vista previa en tiempo real dentro del editor + guardado automático (borrador).
>
> 3) Canal de publicación: Elegir B -- Enviar con un clic el resultado de la edición a GitHub (se sugiere usar PR en lugar de push directo a master, para facilitar tu revisión/reversión; si insistes en push directo, también se puede hacer como opción).
>
> 4) Autenticación: MVP solo para ti. Mencionaste que la dirección del "par de claves de curva elíptica como SSH" podría usarse para proteger credenciales locales (ej: usar tu clave privada para descifrar un token de GitHub almacenado en IndexedDB, o como paso de desbloqueo). Pero para escribir realmente en GitHub aún se necesita un token de autorización de GitHub; para cumplir con "evitar en lo posible un backend", prefiero usar el *flujo de dispositivo* OAuth de GitHub (no depende de `client_secret`) completado completamente en el frontend, y luego almacenar el token solo localmente y cifrarlo secundariamente con tu clave privada.
>
> 5) Imágenes: Según tu preferencia, las imágenes también se guardan en el repositorio (ej: escribir en `static/images/uploads/...`, referenciar `/images/uploads/...` en Markdown); la implementación de subida es "usar el mismo token de GitHub para crear blob/commit a través de la API", no se necesita backend adicional.
>
> Mi próximo paso será cambiar en el plan la "recomendación predeterminada A (fuente de verdad Supabase)" por "fuente de verdad GitHub + Discussions/Issues para borradores + publicación por PR", y complementar el diseño con detalles y limitaciones del almacenamiento/cifrado del token y la escritura de imágenes en el repositorio (tamaño máximo de archivo, estrategia de commit para autoguardado frecuente, etc.).
> [STATUS:resolved]

> [REVIEW] Si es posible, creo que puedo aceptar el device flow, entonces no necesitaríamos el par de claves, puedo confiar en mi propio dispositivo.
>
> [RESPONSE] OK, aceptando el device flow, podemos eliminar el "par de claves de curva elíptica" del MVP:
> - Obtener un token de acceso de escritura al repo mediante el flujo de dispositivo OAuth de GitHub
> - El token se guarda solo en la máquina local (IndexedDB/localStorage), confías en tu propio dispositivo
> - Posteriormente, si deseas un "desbloqueo secundario/protección contra observadores locales", el par de claves/OS Keychain se puede añadir como mejora opcional en v2
> [STATUS:resolved]

## Esquemas candidatos (arquitectura de alto nivel)

### Esquema D (Implementación actual / Esquema principal): JS puro `/admin` + Vditor + Flujo de Dispositivo GitHub + Publicación por PR

- **Frontend**: Página estática `static/admin/*`, reutilizando los estilos existentes `reset.css`/`suCSS.css`/`style.css` y el toggle de tema de `static/js/script.js` (manteniendo coherencia del lenguaje de diseño).
- **Editor**: Vditor (modo IR por defecto), edición de cuerpo + edición separada del front matter (para evitar que el modo WYSIWYG lo corrompa).
- **Autenticación**: Flujo de dispositivo OAuth de **GitHub** (sin necesidad de `client_secret`, no requiere backend propio para intercambio de tokens); el token se guarda solo en IndexedDB local.
- **Borradores**: Solo autoguardado local (IndexedDB), sin sincronización entre dispositivos, sin generar ruido de commits Git.
- **Publicación**: Al publicar, crear rama + PR, escritura única que incluye:
  - `content/**.md` (combinando front matter + cuerpo)
  - `static/images/uploads/**` (las imágenes insertadas se registran como activos pendientes y se envían juntas al publicar)

Ventajas: Completamente sin backend propio; la "fuente de verdad" es el repositorio GitHub; coincide con tus preferencias.
Riesgos: Necesita validar la "fidelidad" del editor con los shortcodes/front matter (especialmente páginas que contienen `{{ ... }}`); necesita controlar el alcance de los permisos (scope) de la API de GitHub.

### Esquema A (Opcional): JS puro `/admin` + Vditor + Supabase (solo borradores/sincronización entre dispositivos)

Solo se introduce si en el futuro necesitas "sincronización de borradores entre dispositivos/colaboración"; no como fuente de verdad.

### Esquema B (Opcional): JS puro `/admin` + TOAST UI Editor

Si prefieres la experiencia de edición de TOAST UI, se puede reemplazar el editor (con costo adicional de sobrescribir temas).

### Esquema C (Opcional): React `/admin` (Vite) + shadcn UI + Milkdown/TipTap

Adecuado si necesitas UI/interacciones más complejas (gestión de recursos, bloques extensibles, etc.). Coste: Introducir cadena de construcción Node; necesita mapeo estricto a las variables suCSS existentes para evitar desviación de estilo.

> [REVIEW] Creo que D debería ser un buen esquema, no necesita un backend, el estado está en GitHub, creo que puedo aceptar introducir un proveedor de oauth, mi sistema de comentarios actual también funciona así, puedes ver cómo hacerlo. Si es absolutamente necesario introducir Supabase, solo debería guardar borradores, no como almacenamiento de fuente de verdad.
>
> [RESPONSE] De acuerdo con tu dirección: usar GitHub (Issues/Discussions + repo) como almacenamiento principal donde "el estado está en GitHub" se ajusta más a tus preferencias; si se introduce Supabase, también debería degradarse a "borrador/caché opcional", no a la fuente de verdad del sistema.
>
> Necesito que confirmes 2 puntos más para evitar errores:
>
> 1) **Forma de OAuth**: Dices que "puedes aceptar introducir un proveedor de oauth (el sistema de comentarios también es así)". La escritura del sistema de comentarios giscus se realiza mediante una GitHub App/servidor que realiza el intercambio de tokens y firma; si también usamos el flujo OAuth web tradicional, involucraría la confidencialidad de `client_secret`, lo que normalmente aún requiere un backend/función confiable para intercambiar el token. Para cumplir con "no escribir backend", sugiero más usar el *flujo de dispositivo* OAuth de GitHub: la autorización se puede completar completamente en el frontend (no necesita que un backend guarde `client_secret`). ¿Aceptas el device flow como sustituto del "proveedor de oauth"?
>
> 2) **Dónde guardar borradores**:
> - D1) GitHub Discussions: Cada página corresponde a un discussion, el borrador es el cuerpo del discussion; al publicar, generar PR para escribir en `content/**`.
> - D2) GitHub Issues: Igual, pero issues está más orientado a flujos de tareas.
> - D3) Rama `drafts` en el repo: El autoguardado actualiza directamente el archivo (generaría muchos commits, requiere estrategia de fusión/compresión).
> ¿Cuál prefieres, D1/D2/D3?
>
> Después de tu confirmación, completaré los "pasos de implementación realizables" con: "Fuente de verdad GitHub + estrategia de borradores + estrategia de publicación por PR + estrategia de envío de imágenes + modelo de seguridad (almacenamiento local de token/cifrado opcional con clave privada)".
> [STATUS:need-info]
>
> [RESPONSE] Aceptado y ya convergido según tu última confirmación:
> - El Esquema D (GitHub como almacenamiento principal) como esquema principal, pero ya no necesita "proveedor de oauth + intercambio de tokens en backend", en su lugar usar **device flow**.
> - Supabase se elimina de la ruta principal (si en el futuro se necesitan borradores entre dispositivos/colaboración, se añade como componente opcional).
>
> Implicaciones de implementación (para tu confirmación):
> - `borrador/autoguardado`: Solo escribir en caché local, no generar commits Git; evitar "ruido de commit/PR por cada tecla pulsada".
> - `publicar`: Enviar de una vez los cambios especificados en archivos `content/**` + imágenes, a GitHub (por defecto se sugiere abrir PR; también se puede configurar para push directo a master).
>
> Si estás de acuerdo con esta dirección convergente, mi próximo paso (cuando digas que se puede modificar el código) será implementar según esto.
> [STATUS:resolved]

> [REVIEW] 1. Acepto el device flow. 2. Creo que mejor caché frontend, parece que no tengo necesidad de sincronización entre dispositivos, no lo compliquemos tanto.
>
> [RESPONSE] Confirmación recibida:
> 1) OAuth: Adoptar el flujo de dispositivo de GitHub (sin dependencia de `client_secret`, sin necesidad de backend propio para intercambio de tokens).
> 2) Borradores: Solo caché local en el frontend (IndexedDB principal, localStorage como respaldo/para datos pequeños), sin sincronización entre dispositivos.
>
> En base a esto, convergeré el diseño general en:
> - **Fuente de verdad (publicado)**: Repositorio GitHub `content/**` (escrito de vuelta mediante PR/push)
> - **Borradores (borrador/autoguardado)**: Caché local (no necesita Supabase/GitHub Discussions/Issues)
> - **Imágenes**: Al publicar, escribir también en el repositorio (ej: `static/images/uploads/...`), referenciar rutas internas del sitio en Markdown
> [STATUS:resolved]

## Implementación recomendada (basada en suposiciones predeterminadas)

La implementación actual implementa directamente el Esquema D (sin backend):

1. Página estática `/admin/`: Conectar con GitHub (device flow), obtener lista de `content/**.md`.
2. Cargar archivo: Analizar y separar front matter y cuerpo; editar cuerpo con Vditor.
3. Borrador: Guardar en IndexedDB local con debounce al escribir (no escribir en GitHub).
4. Imágenes: Registrar como activo pendiente mediante "Insertar imagen", e insertar ruta interna del sitio (`/images/uploads/...`); al publicar, enviar junto con el commit al `static/images/uploads/...` del repo.
5. Publicar: Crear rama + PR (un commit que incluya Markdown + imágenes), que al fusionarse active el workflow de despliegue de Zola existente.

## Lista de seguridad y riesgos (necesita verificación/pruebas)

- Fidelidad del editor con `{{ ... }}` (shortcodes de Zola) y front matter (especialmente en modo WYSIWYG).
- XSS: Si se permite HTML crudo en Markdown, publicarlo en el sitio conlleva riesgo de inyección (se necesita restringir/filtrar por reglas "antes de publicar").
- Alcance (scope) del token de GitHub: Minimizar lo máximo posible (usar `public_repo` para repo público).
- Indexación de la página admin: Necesita `noindex` (o ponerla en ruta no adivinable/añadir puerta adicional), para evitar indexación por motores de búsqueda.

## Alcance

- static/css/*
- templates/*
- static/js/*
- scripts/*
- .github/*
- .legion/**

## Resumen de fases

1. **Auditoría del estado actual y restricciones** - 2 tareas
2. **Investigación de selección de editor** - 2 tareas
3. **Diseño del backend y modelo de datos** - 2 tareas
4. **Diseño detallado del esquema de integración y plan de implementación** - 2 tareas

---

*Creado: 2026-01-06 | Última actualización: 2026-01-06*