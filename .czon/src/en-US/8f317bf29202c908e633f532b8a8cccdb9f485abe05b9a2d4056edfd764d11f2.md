---
"title": "May 2020 Work Log"
"summary": "This document is the work log for May 2020, detailing daily activities in technical development, problem-solving, and project planning. Main contents include: fixing a memory leak, where the root cause was dangling pointers not being deleted, resolved by refactoring the NaviEventProvider; handling geometric calculation anomalies caused by duplicate points in PolyLine; fixing multiple HDMAPMDK-related bugs, such as errors due to unreasonable production line segmentation; performing OSM Assembler refactoring; planning the current state and requirements of the CI Pipeline; and handling urgent tasks like incorrect parking space bindings. The log also reflects thoughts on time estimation, problem-solving patterns (short-term vs. long-term solutions), as well as experiences with interviews and team collaboration."
"tags":
  - "Work Log"
  - "Technology"
  - "Bug Fix"
  - "Memory Leak"
  - "Refactoring"
  - "CI"
  - "Interview"
  - "Project Management"
"date": "2020-05-01"
---

### 2020-05-06
#### Du Valid
- Using mill
- Using nexus-osm

#### Brainstorm

### 2020-05-08
#### Memory Leak Issue
- The direct cause of the memory leak was not deleting after new-ing dangling pointers.
- After updating the current position, map kit called `prepareGuidanceData` to find the guidance data closest to the current position.
- `prepareGuidanceData` called `NavInfoProviderImpl::getTrafficLights` & `NavInfoProviderImpl::getCarParks`.
- Taking `NavInfoProviderImpl::getTrafficLights` as an example, it new-ed data pointers in `NaviEventOnPath` during the call.
- However, they were not deleted.
- Also found that `DestEvent` had this issue.

Solution: The core is to not allow dangling pointers. Decided to refactor the `NaviEventProvider`.
- First, add two fields `traffic_light_events_` & `car_park_events_` in `NaviInfoProvider`.
- Update these two fields in `NaviInfoGenerator` after the route is updated.
- Then, filter based on the current vehicle position during each get operation.
- Therefore, `PathReader::getAttributes` needs to be refactored because the previous implementation only considered the offset relative to the current vehicle; now an interface for offset relative to the Path is needed.

### 2020-05-09
#### PolyLine Fix and Testing
The main issue with PolyLine was that duplicate points could be added during PolyLine generation, leading to a series of geometric calculation problems related to segments:
1. Vector calculation: two duplicate points result in a zero vector.
2. Length calculation: segment length is 0, easily causing NaN issues.

Therefore, when constructing a PolyLine, check the points within it. If duplicate points are found, throw an exception.

The following issues were identified:
- Problems with `getEnd` in Jts.
- `Jts LinearLocation` has a normalization issue.
  ```scala
  val loc1 = new LinearLocation(0, 1, 1.0)
  val loc2 = new LinearLocation(0, 2, 0.0)

  loc1 compareTo loc2
  // the output is -1
  ```
- When interpolating, points that are too close might be selected.

### 2020-05-11
- HDMAPMDK-1122
  Could not reproduce the missing road edge line issue; decided not to spend more time investigating the cause.
- Spent half an hour on "Metabolic Growth Theory".
- Refactored Visitor to support lines with the same start and end points.
- Prepared an interview question.

### 2020-05-12
- Interview: Both candidates were unqualified. Thought about how to quickly screen candidates. Took 3 hours.
- Bugfix: HDMAPMDK-1211 Deleting incorrect border issue; the previous fix was unsuccessful.
  Had an idea but didn't finish writing it.
- Went to the gym.

### 2020-05-13
Bugfix: HDMAPMDK-1211 Thought of a solution.
- Root cause: unreasonable production line segmentation.

#### Root Cause Analysis
It can be seen that segmentation occurred before the lane change was completed (the lane centerline was still crossing the lane line), and this segmentation could potentially cross RPs.

The lane border observation information attached to the lane center shape points faithfully records the lane lines on both sides using a scan-line method based on geometry, without semantic filtering. Therefore, at the position where the lane line crosses the lane, the lane centerline intersecting with the lane line will record that lane line on both the left and right lane border refs.

Under the existing code logic, when filtering intersecting lane line border refs based on semantics, the border refs to be deleted are inferred based on the lane change type.

The current logic fails when encountering this type of segmentation, leading to this problem.

#### Solution
The key point is to **find the lane change trend of the intersecting lane line**. Considering that this type of segmentation may cross RPs, filtering should not be performed per RP.

1. First, organize lane lines into paths using edge lifting (can be considered for future graph refactoring): `Seq[LaneCenter]`.
2. Find the lane center to be corrected and the lane border to be corrected (assuming such lane centers are caused by lane changes).
3. Calculate the lane change trend of this lane center based on the lane center path.
4. Perform filtering.

Assigned to Ziliang.

One interview candidate failed.

### 2020-05-14
HDMAPMDK-1132 Id tracing for pole sign lane line endpoints.

The tracing problem for pole sign lane line endpoints is much simpler compared to linear object tracing, involving only Id mapping, without offset and length mapping.

However, there are still many issues to consider:
1. Procedure
2. The Id Typing System is a persistent issue that needs to be addressed.

Essentially, the root of this problem is that we used Long Ids for all definitions, while MDM definitions use Ints, which could easily cause overflow issues.

### 2020-05-15
#### Bug Fixes
- HDMAPMDK-1215 completed.
- HDMAPMDK-1218 Done.

### 2020-05-18
Refactored the OSM Assembler using the previous OSM serialize. Both the ease of understanding the code and the ease of writing have improved.

### 2020-05-19
Fixed a bug in the OSM Assembler (not really a bug).

Had a sprint planning meeting today:
There aren't many tasks for this sprint, but there's a lot to think about. This is a healthy state.

### 2020-05-20
- [ ] Write documentation describing the current state of nexus/mdk CI and the requirements.
- [x] Follow up on HDMAPMDK-1263 bug.
  - It was indeed a production line segmentation issue.
- [ ] Schedule a meeting with Yang Chuan to discuss CI.
- [ ] HDMAPMDK-1262
  Didn't finish.
- [x] Custom Speed Limit issue.

### 2020-05-21
#### TODOs
- [x] Greet Qiaobo.
- [x] HDMAPMDK-1262.
- [x] HDMAPMDK-755.

#### Works
- Went to Yiming's workspace in the morning to debug yesterday's hotfix online. The issue was due to an offset problem. Wrote it too hastily yesterday and didn't add any tests at all. This kind of behavior should not happen again. Thought I saved a lot of time, **but ended up wasting more time**.
- The reason for not getting data in 1262 was that MDK did not load lane-level road marks (and road obstacles).
- Helped Brother Du compile data.

### 2020-05-22
What did I do today????
What did I do????

### 2020-05-25
Received a new task today: HDMAPMDK-1249 - Research methods for calculating lane aggregation using road geometry information. This increased the tasks for this week. As of now, I still have three things to do:

1. 1249
2. Current state, requirements, and plan for the team's CI Pipeline.
3. Nexus graph refactoring.

Each task requires careful thought and is not easy. Unfortunately, I cannot accurately estimate the time for each task. They are all just estimated by Weiyu and written as story points in the Jira tasks. One thing I am clear about: **If I don't start estimating and reviewing, I will never estimate accurately**. So starting from this time, I need to estimate carefully.

Also, I plan to start working on 1249 today because it's a business-related matter, which is generally more urgent, and Weiyu will care more about it. As for refactoring, if I don't take it seriously, probably no one else will (because, cruelly, it doesn't affect functionality but affects efficiency, and efficiency is the hardest to measure. Even I only have qualitative analysis).

### 2020-05-26
Many unexpected things happened today. First, two bugs were reported for parking. Originally planned for delivery today, but due to these bugs, delivery couldn't happen today. Wang Wei negotiated with downstream to postpone delivery by two days to the day after tomorrow. So my main work for these two days became fixing bugs again. This made me think about whether the scheduling during delivery is reasonable. Then there was the HDMAPMDK-1290 issue.

Things completed today:
- Follow-up on HDMAPMDK-1290: When extremely close to the stop line, the matched lane offset could be longer than the lane length.
  > Spent the whole day investigating and trying to solve this problem (currently 8:56 PM). Efficiency was very low.

  The essential reason is that when MDK calculates length, it calculates the length between every two points and then performs a coordinate transform. While this is more accurate, it introduces strong uncertainty.

  Finally used a hacky solution: if the calculated offset is longer than the length, only take the length.
- HDMAPMDK-1297 Incorrect parking space binding.
  Even though it was almost the original off-work time (9 PM), I must at least analyze this problem today!
  Sigh, got it done. Turned out to be a simple problem.

### 2020-05-27
If nothing unexpected happens, I should finish the CI Pipeline work today.

But something unexpected happened - -

Received bugs reported by Yiming:
1. Traffic light binding: A traffic light that should have been bound to the waiting area was bound to the partition before the waiting area. Fixed (1.5h).
2. Missing traffic light binding: Could not reproduce.
   Update: After a round of difficult debugging, finally found the problem. The geometry used for binding rc and offset during compilation was not the same line, causing the offset to exceed the road length, so the traffic light couldn't be found (2h).

### 2020-05-28
Taking the driving license subject 2 test tomorrow. Practiced driving all day today, came back at 5 PM. Feeling pretty good, hope to pass tomorrow.

Started describing the current state and analyzing requirements for the CI Pipeline - -

### 2020-05-29
Didn't pass. Alas, this is tough.

Went to take the test in the morning. Did a few things in the afternoon.

1. Went to Yiming's place to check an abnormal situation. Turned out to be two bugs.
2. After the townhall, synchronized about the MDK Python binding.
3. Went downstairs with Shan Le and Weiyu to solve a downstream problem. Finally summarized a short-term solution and a long-term solution.

I found that when encountering unexpected problems, the problem-solving approach should generally follow this pattern:
A short-term solution and a long-term solution. Because the value exposed by a problem is certain and time-sensitive. Therefore, the short-term solution focuses on quickly and accurately solving the urgent need. Is a long-term solution still needed? Generally, yes, because a specific case of a problem reflects a blind spot in previous solution considerations. Analyzing the root cause and systematically solving it makes the original solution more complete, ensuring such problems are well-handled in the future. There are cases where a long-term solution isn't needed: after thorough analysis, we conclude that the cost of systematically solving the problem outweighs the benefits. (Even so, subjectively, most engineers still want to solve it systematically. Who doesn't want to solve problems systematically as an engineer? But this also creates a trap, leading people to solve important but not urgent, or neither important nor urgent matters, wasting precious time that could be used on more valuable problems.)

4. Came back in the evening and continued working on the CI Pipeline.