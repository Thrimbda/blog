---
"title": "Erste Schritte in die Nebenläufigkeit"
"summary": "Dieser Artikel beschreibt die Erfahrung des Autors mit der Nebenläufigkeitsprogrammierung durch eine kleine Aufgabe. Es wurde eine Demo zur Veranschaulichung der Nebenläufigkeitssteuerung mit den Python-Modulen queue, signal und time erstellt. Der Artikel erklärt die Rolle dieser drei Module in der Demo: queue dient als Nachrichtenwarteschlange zur Signalübertragung, signal zum Abfangen von KeyboardInterrupt-Unterbrechungen und time ermöglicht es dem Hauptthread, rechtzeitig auf Unterbrechungen zu reagieren. Der Autor erörtert weiter die Bedeutung von Nachrichtenwarteschlangen in der Multithread-Programmierung, weist darauf hin, dass sie die Kommunikation zwischen Threads erleichtern und die Systemkopplung verringern, und betont, dass ein gutes Systemdesign für Veränderungen konzipiert sein sollte, wobei die Zusammenarbeit von Modulen durch die Kapselung von Details und ereignisgesteuerte Ansätze erreicht wird."
"tags":
  - "python"
  - "Nebenläufigkeit"
  - "Multithreading"
  - "Nachrichtenwarteschlange"
  - "Systemdesign"
"date": "2017-05-07"
---

---
title: Erste Schritte in die Nebenläufigkeit
date: 2017-05-07
taxonomies:
  tags:
    - python
    - Nebenläufigkeit
---

Gut, durch eine kleine kürzliche Aufgabe hatte ich das Glück, erstmals mit wirklich bedeutungsvoller Nebenläufigkeitsprogrammierung in Berührung zu kommen.

<!--more-->

## Demo

Daher habe ich mit den Python-Modulen `queue`, `signal` und `time` einen kleinen Demo-Code erstellt, der zwar nicht wirklich multithreaded ist, aber zur Veranschaulichung dient:

```python
# -*- coding: utf-8 -*-
# @Author: Michale
# @Date:   2017-05-04 15:00:41
# @Last Modified by:   Michale
# @Last Modified time: 2017-05-07 00:46:52
import signal
import queue
import time


class TestClass(object):
    queue = queue.Queue()

    def __init__(self):
        signal.signal(signal.SIGINT, self.stopIfPressKill)

    def stopIfPressKill(self, mySignal, stack):
        if mySignal == signal.SIGINT:
            print('you pressed CTRL-C')
            self.queue.put_nowait('stop')
            print(self.queue.qsize())

    def mainThread(self):
        while True:
            time.sleep(1)
            if not self.queue.empty():
                data = self.queue.get()
                print(data)
                if data == 'stop':
                    break
                else:
                    self.queue.put(data)


if __name__ == '__main__':
    yoo = TestClass()
    yoo.mainThread()

```

Erklärung der Rolle der drei Module:

-   `queue`: Dient als Nachrichtenwarteschlange, was hier offensichtlich etwas übertrieben ist.
-   `signal`: Wird verwendet, um `KeyboardInterrupt` abzufangen und danach das Stoppsignal in die Nachrichtenwarteschlange zu legen.
-   `time`: Ermöglicht es dem Hauptthread, diesen `KeyboardInterrupt` abzufangen.

## Gedanken

Die Einführung von Multithreading macht es schwierig, nicht zum Hauptthread gehörende Threads nach ihrem Start noch zu kontrollieren, was Menschen dazu zwingt, Methoden wie Nachrichtenwarteschlangen für die Kommunikation zwischen Threads zu verwenden.

Aber eigentlich sollten, unabhängig davon ob Multithreading verwendet wird oder nicht, die verschiedenen Module eines Systems ihre Details kapseln und durch Ereignisse zusammenarbeiten. Dies hilft sehr, die Kopplung des Systems zu verringern, und das ist auch der Entwurfsgedanke eines guten Systems: **Für Veränderungen entwerfen.**