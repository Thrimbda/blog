---
"title": "Praktische Analyse des Beobachter-Musters"
"summary": "Dieser Artikel führt zunächst die Grundkonzepte des Beobachter-Musters (auch bekannt als Publish-Subscribe-Muster), die GoF-Definition und seine Anwendungen in der realen Welt (z.B. RSS-Abonnements) ein. Der Artikel erläutert detailliert die beteiligten Akteure (Subject, Observer, ConcreteSubject, ConcreteObserver) und Anwendungsfälle (z.B. wenn Abhängigkeiten zwischen Objekten bestehen oder ein Objekt geändert werden muss und andere Objekte ebenfalls geändert werden müssen). Anschließend zeigt der Artikel am Beispiel von Action und ActionListener in J2EE anhand eines konkreten Java-Swing-Codebeispiels, wie das Beobachter-Muster im MVC-Paradigma angewendet werden kann, um die Kopplung zwischen Model und View zu reduzieren. Der Artikel weist darauf hin, dass das Beobachter-Muster im Vergleich zu normalen Funktionsaufrufen und Callback-Funktionen die Konsistenz zwischen Objekten mit geringen Kosten aufrechterhalten, einen Broadcast-Effekt erzielen und die Wiederverwendbarkeit des Codes verbessern kann."
"tags":
  - "Entwurfsmuster"
  - "Beobachter-Muster"
  - "J2EE"
  - "ActionListener"
  - "Systemanalyse und -design"
  - "MVC"
  - "Java"
"date": "2017-04-10"
---

---
title: Praktische Analyse des Beobachter-Musters
date: 2017-04-10
taxonomies:
  tags:
    - Entwurfsmuster
    - Systemanalyse und -design
---

> Im Allgemeinen gibt es in der objektorientierten Analyse und Design drei Mechanismen zur Ereignisbehandlung: Neben dem normalen Funktionsaufruf werden häufig Callback-Funktionen verwendet, und in J2EE gibt es außerdem einen ereignisbasierten Behandlungsmechanismus auf Basis von Listenern. Recherchieren Sie bitte Informationen, analysieren Sie den Mechanismus von Action und ActionListener und erstellen Sie eine Analyse anhand eines Beispiels.

Zuerst verstehen wir das Beobachter-Muster.

<!--more-->

## Das Beobachter-Muster (Observer Pattern)

### Beobachter in der realen Welt

Das Beobachter-Muster wird auch als Publish-Subscribe-Muster bezeichnet. Ein Beispiel ist RSS (der Vorläufer von WeChat-Push) – wenn ein Blogger (das beobachtete Subjekt) einen Blogbeitrag aktualisiert, erhalten die Abonnenten automatisch die Aktualisierung in ihrem Reader (dem Beobachter). Dieses Veröffentlichungs-Abonnement-Schema nennen wir das Beobachter-Muster.

### Das Beobachter-Muster

Die Beschreibung des Beobachter-Musters durch die **G**ang **O**f **F**our:

> - Absicht
>
>   Definiere eine Eins-zu-viele-Abhängigkeit zwischen Objekten, sodass, wenn sich der Zustand eines Objekts ändert, alle von ihm abhängigen Objekte benachrichtigt und automatisch aktualisiert werden.
>
> - Alias
>
>   Dependents, Publish-Subscribe
>
> - Motivation
>
>   Eine häufige Nebenwirkung der Aufteilung eines Systems in eine Reihe zusammenarbeitender Klassen ist die Notwendigkeit, die Konsistenz zwischen den zusammenhängenden Objekten aufrechtzuerhalten. Wir möchten nicht, dass die Klassen eng gekoppelt sind, um die Konsistenz zu wahren, da dies ihre Wiederverwendbarkeit verringert.
>
> ...
>
> - Beteiligte
>
>   - Subject (Ziel)
>
>     Das Ziel kennt seine Beobachter. Es kann beliebig viele Beobachter geben, die dasselbe Ziel beobachten.
>
>     Bietet Schnittstellen zum Registrieren und Entfernen von Beobachterobjekten.
>
>   - Observer (Beobachter)
>
>     Definiert eine Aktualisierungsschnittstelle für Objekte, die benachrichtigt werden müssen, wenn sich das Ziel ändert.
>
>   - ConcreteSubject (Konkretes Ziel)
>
>     Speichert den relevanten Zustand in den jeweiligen ConcreteObserver-Objekten.
>
>     Sendet eine Benachrichtigung an alle seine Beobachter, wenn sich sein Zustand ändert.
>
>   - ConcreteObserver (Konkreter Beobachter)
>
>     Verwaltet einen Verweis auf ein ConcreteSubject-Objekt.
>
>     Speichert einen relevanten Zustand, der mit dem Zustand des Ziels konsistent sein sollte.
>
>     Implementiert die Aktualisierungsschnittstelle des Observer, um seinen eigenen Zustand mit dem des Ziels konsistent zu halten.

Man kann sehen, dass das Beobachter-Muster häufig angewendet wird bei:

- Zwei Objekten, die eine Abhängigkeitsbeziehung haben.
- Einem Objekt, das geändert werden muss, während gleichzeitig andere Objekte geändert werden müssen.

Im Vergleich zu normalen Funktionsaufrufen und Callback-Funktionen ermöglicht die Verwendung des Beobachter-Musters, die Konsistenz zwischen Objekten mit geringen Kosten aufrechtzuerhalten, **verringert den Grad der Kopplung zwischen den Objekten erheblich und kann gleichzeitig einen Broadcast-Effekt erzielen, was die ersten beiden nicht können. Die Verwendung des Beobachter-Musters** verbessert die Wiederverwendbarkeit des Codes erheblich.

**Und Action und ActionListener in J2EE sind ein lebendiges Beispiel für das Beobachter-Muster.**

## Action & ActionListener in J2EE

Action & ActionListener können gut im MVC-Paradigma angewendet werden, um die Kopplung zwischen Model und View zu reduzieren.

Ein gutes [Beispiel](http://www.ulisespulido.com/2009/03/observer-design-pattern-and-java-swing.html) wurde gefunden, der Code ist wie folgt:

```java
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JTextField;

public class Frame extends JFrame {

  ActionListener observer1 = new Observer("First Observer");
  ActionListener observer2 = new Observer("Second Observer");
  ActionListener observer3 = new Observer("Third Observer");

  public Frame(){
    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    init();
  }

  private void init(){
    addChangingTextField();
    pack();
    setVisible(true);
  }

  private void addChangingTextField(){
    //Observable class TextField. each time
    //An action or event occurs the observers will be updated
    //Almost all the Swing classes has this kind of behavior
    JTextField dataTextField = new JTextField();

    // Observer registering to the observable class.
    dataTextField.addActionListener(observer1);
    dataTextField.addActionListener(observer2);
    dataTextField.addActionListener(observer3);

    add(dataTextField);
  }

  public static void main(String [] args){
  	Frame frame = new Frame();
  }
}

class Observer implements ActionListener{

  private String name;
  private String message;

  public Observer (String s){
  	name = s;
  }

  public void actionPerformed(ActionEvent e) {
    JTextField textField = (JTextField) e.getSource();
    message = textField.getText();
    JOptionPane.showMessageDialog(null,
    name + " has been confirmed about the change, Thanks!! "
    + " The Message was: " + message);
  }
}
```

### Analyse

Die beiden Klassen übernehmen jeweils die Rolle von Action/ActionListener. `frame.dataTextField` bindet in der Methode `addChangingTextField` drei Listener (`observer1`, `observer2`, `observer3`). Nachdem der Text im Frame bearbeitet wurde (Zustandsänderung), wird die Methode `actionPerformed` in `Observer` ausgelöst, die den entsprechenden Text anzeigt.

In diesem Beispiel fungiert `frame.dataTextField` als `ConcreteSubject`, und `observer1`, `observer2`, `observer3` fungieren als `ConcreteObserver`. Die Schnittstellen, die sie implementieren und die die Action/ActionListener-Methoden definieren, sind das entsprechende `Subject` und `Observer`.

Nach der Bindung der Beobachter kümmert sich das Ziel nicht um das konkrete Verhalten der Beobachter, sondern benachrichtigt sie nur, wenn sich sein eigener Zustand ändert. Die Beobachter entscheiden dann selbst, welche Aktion sie ausführen. Daher ist diese Methode sehr elegant und um Welten besser als das explizite Aufrufen von Funktionen oder das Ausführen von Callback-Funktionen, um Aktionen auszulösen. Es lohnt sich, dies zu lernen.