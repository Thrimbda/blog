<!doctype html><html lang=zh><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>观察者模式实力分析</title><meta content=观察者模式实力分析 name=title><meta content=0xc1 name=author><meta content="c1 的博客" name=description><meta content=website property=og:type><meta content=https://0xc1.space/blog/guan-cha-zhe-mo-shi-shi-li-fen-xi/ property=og:url><meta content="c1 的博客" property=og:site_name><meta content=观察者模式实力分析 property=og:title><meta content="c1 的博客" property=og:description><meta content=https://0xc1.space/favicon.ico property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://0xc1.space/blog/guan-cha-zhe-mo-shi-shi-li-fen-xi/ property=twitter:url><meta content=观察者模式实力分析 property=twitter:title><meta content="c1 的博客" property=twitter:description><meta content=https://0xc1.space/favicon.ico property=twitter:image><link href=https://0xc1.space/blog/guan-cha-zhe-mo-shi-shi-li-fen-xi/ rel=canonical><link rel="shortcut icon" href=https://0xc1.space/favicon.ico type=image/x-icon><link href=https://0xc1.space/atom.xml rel=alternate title=RSS type=application/atom+xml><link href=https://0xc1.space/css/reset.css rel=stylesheet><link href=https://0xc1.space/css/suCSS.css rel=stylesheet><link href=https://0xc1.space/css/style.css rel=stylesheet><script defer src=https://0xc1.space/js/script.js></script><script src=https://unpkg.com/rxjs@^7/dist/bundles/rxjs.umd.min.js></script><script defer src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js></script><script defer>hljs.highlightAll()</script><script defer src=https://cdn.jsdelivr.net/npm/mermaid@10.9.1/dist/mermaid.min.js></script><script defer>mermaid.initialize({startOnLoad:!0})</script><script src="https://www.googletagmanager.com/gtag/js?id=G-8DQTX42T4P" async></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[];gtag(`js`,new Date());gtag(`config`,`G-8DQTX42T4P`,{'page_title':`观察者模式实力分析`,'page_path':`true`})</script><body><header><nav id=nav-bar><h3 id=nav-home><a href=/>0xc1</a> 的博客</h3><div id=nav-links><a href=/blog> |博客| </a><a href=/gcores-talks> |机组| </a><a href=/about> |关于| </a><div><input id=theme-toggle style=display:none type=checkbox><label for=theme-toggle id=theme-toggle-label><svg class=icons id=theme-icon><use href=https://0xc1.space/icons.svg#lightMode></use></svg></label><audio id=theme-sound><source src=https://0xc1.space/click.ogg type=audio/ogg></audio></div></div></nav></header><main><div><a href=..>..</a>/<span class=accent-data>guan-cha-zhe-mo-shi-shi-li-fen-xi</span></div><time datetime=2017-04-10>Published on: <span class=accent-data>2017-04-10</span></time><address rel=author>By <span class=accent-data>0xc1</span></address><h1>观察者模式实力分析</h1><blockquote><p>一般地，面向对象分析与设计中存在三种事件处理的机制，除了普通的函数调用外，常常用到回调函数，而 J2EE 中还提供了一种基于监听方式的事件处理机制，请查阅资料，对 Action 以及 ActionListener 的机制进行分析，完成一个分析实例。</blockquote><p>首先了解观察者模式</p><span id=continue-reading></span><h2 id=guan-cha-zhe-mo-shi-observer-pattern>观察者模式 (Observer Pattern)</h2><h3 id=zhen-shi-shi-jie-zhong-de-guan-cha-zhe>真实世界中的观察者</h3><p>观察者模式又称发布订阅模式，例如 RSS（微信推送的爸爸）订阅，某博客（被观察者）的博主在更新博文后，订阅者的阅读器（观察者）上就会自动能够收到更新。这种发布-订阅的套路我们称作观察者模式。<h3 id=guan-cha-zhe-mo-shi>观察者模式</h3><p>(<strong>G</strong>ang <strong>O</strong>f <strong>F</strong>our)对观察者模式的描述：<blockquote><ul><li><p>意图</p> <p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><li><p>别名</p> <p>依赖(Dependents)，发布-订阅(Publish-Subscribe)</p><li><p>动机</p> <p>将一个系统分割成一系列相互协作的类有一个常见的副作用：需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合，因为这样降低了他们的可重用性。</p></ul><p>…<ul><li><p>参与者</p> <ul><li><p>subject（目标）</p> <p>目标知道他的观察者。可以有任意多个观察者观察同一目标。</p> <p>提供注册和删除观察者对象接口。</p><li><p>Observer（观察者）</p> <p>为那些咋目标发生改变时需获得通知的对象定义一个更新接口。</p><li><p>ConcreteSubject（具体目标）</p> <p>将有关状态存入各 ConcreteObserver 对象。</p> <p>当他的状态发生改变时，向他的各个观察者发出通知。</p><li><p>ConcreteObserver（具体观察者）</p> <p>维护一个指向 ConcreteSubject 对象的引用。</p> <p>存储有关状态，这些状态应与目标的状态保持一致。</p> <p>实现 Observer 的更新接口以使自身状态与目标的状态保持一致。</p></ul></ul></blockquote><p>可以发现观察者模式常常应用于：<ul><li>两个对象具有依赖关系。<li>一个对象更改时需要同时更改其他对象。</ul><p>相比于普通的函数调用以及回调函数，观察者模式的使用能够做到低成本维持对象间一致性，大大<strong>降低了对象间的耦合关系程度，同时可以达到广播的效果，这是前二者做不到的。观察者模式的使用大大</strong>提高了代码的可重用性**。<p><strong>而 J2EE 中的 Action 和 ActionListener 正是观察者模式的一个鲜活的例子。</strong><h2 id=j2ee-zhong-de-action-actionlistener>J2EE 中的 Action&ActionListener</h2><p>Action&ActionListener 可以很好地应用于 MVC 范式用来降低 model 和 view 的耦合程度。<p>找到一个很好的<a href=http://www.ulisespulido.com/2009/03/observer-design-pattern-and-java-swing.html rel=noopener target=_blank>例子</a>，代码如下所示：<pre class=language-java data-lang=java><code class=language-java data-lang=java>import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JTextField;

public class Frame extends JFrame {

  ActionListener observer1 = new Observer("First Observer");
  ActionListener observer2 = new Observer("Second Observer");
  ActionListener observer3 = new Observer("Third Observer");

  public Frame(){
    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    init();
  }

  private void init(){
    addChangingTextField();
    pack();
    setVisible(true);
  }

  private void addChangingTextField(){
    //Observable class TextField. each time
    //An action or event occurs the observers will be updated
    //Almost all the Swing classes has this kind of behavior
    JTextField dataTextField = new JTextField();

    // Observer registering to the observable class.
    dataTextField.addActionListener(observer1);
    dataTextField.addActionListener(observer2);
    dataTextField.addActionListener(observer3);

    add(dataTextField);
  }

  public static void main(String [] args){
  	Frame frame = new Frame();
  }
}

class Observer implements ActionListener{

  private String name;
  private String message;

  public Observer (String s){
  	name = s;
  }

  public void actionPerformed(ActionEvent e) {
    JTextField textField = (JTextField) e.getSource();
    message = textField.getText();
    JOptionPane.showMessageDialog(null,
    name + " has been confirmed about the change, Thanks!! "
    + " The Message was: " + message);
  }
}
</code></pre><h3 id=fen-xi>分析</h3><p>两个类分别担任了 Action/ActionListener 的角色，<code>frame.dataTextField</code>在<code>addChangingTextField</code>方法中绑定了三个监听器（<code>observer1</code>, <code>observer2</code>, <code>observer3</code>），在 frame 中文本框被编辑后（状态改变），触发 Observer 中<code>actionPerformed</code>方法，显示相应文本。<p>在这个例子中，<code>frame.dataTextField</code>作为<code>ConcreteSubject</code>，<code>observer1</code>, <code>observer2</code>, <code>observer3</code>作为<code>ConcreteObserver</code>。而他们所实现的定义了 Action/ActionListener 方法的接口，则是相应的<code>Subject</code>和<code>Observer</code>。<p>在绑定观察者后目标并不关注观察者具体的行为，而只是在自身状态发生改变时通知观察者，由观察者自身决定做什么动作，因此这种方法就很 nice，比显式调用函数或者执行回调函数的方式触发动作不知道高到哪里去了，值得学习一个。<p class=tags-data><a href=/tags/she-ji-mo-shi>/设计模式/</a> <a href=/tags/xi-tong-fen-xi-yu-she-ji>/系统分析与设计/</a></p><script async crossorigin data-category=General data-category-id=DIC_kwDOL-lrA84Cfgx1 data-emit-metadata=0 data-input-position=bottom data-lang=zh-CN data-mapping=og:title data-reactions-enabled=1 data-repo=Thrimbda/blog-comment data-repo-id=R_kgDOL-lrAw data-strict=0 data-theme=preferred_color_scheme src=https://giscus.app/client.js></script></main><footer><hr><div id=footer-container><div><p>Theme and color theme licensed under <a rel="noopener noreferrer" href=https://en.wikipedia.org/wiki/Licence_MIT target=_blank>MIT</a>.<br> Built with <a rel="noopener noreferrer" href=https://www.getzola.org target=_blank>Zola</a> using <a rel="noopener noreferrer" href=https://github.com/Speyll/anemone target=_blank>anemone</a> theme, <a rel="noopener noreferrer" href=https://speyll.github.io/suCSS/ target=_blank>suCSS</a> framework & <a rel="noopener noreferrer" href=https://github.com/Speyll/veqev target=_blank>veqev</a>.<br> Written By C1 with love ❤️.</div><div><a rel="noopener noreferrer" title="Subscribe via RSS for updates." class=no-style href=https://0xc1.space/atom.xml target=_blank><svg class=icons><use href=https://0xc1.space/icons.svg#rss></use></svg></a></div></div></footer>