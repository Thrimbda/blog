---
"title": "Spark 論文ノート"
"summary": "本稿はSparkに関する論文のノートであり、Sparkフレームワークの核となる弾性分散データセット（RDD）に焦点を当てています。RDDは、読み取り専用で再構築可能な分散データ構造であり、複数の並列操作にわたるデータの再利用をサポートします。SparkはScalaで実装されており、その関数型およびオブジェクト指向の特性を活用して、RDDの作成方法（ファイルシステム、Scalaコレクション、既存RDDからの変換など）と永続化戦略（cacheおよびsave）を含む柔軟なプログラミングモデルを提供します。本稿では、Sparkのプログラミングモデル、並列操作（reduce、collectなど）、実装の詳細（Mesosベース、RDDインターフェース設計）、および実験結果（Hadoopよりも10倍高速）の概要を説明します。最後に、著者はSparkの初期の成果と潜在的な価値をまとめ、反復的および対話型のワークロードを処理する際の利点を指摘しています。"
"tags":
  - "Spark"
  - "RDD"
  - "分散システム"
  - "論文ノート"
  - "Scala"
  - "MapReduce"
  - "ビッグデータ"
  - "パフォーマンス最適化"
"date": "2022-01-10"
---

MapReduceは非常に成功しましたが、これらの非循環グラフを基盤とするシステムの多くは汎用的ではありませんでした。そのような中でSparkが登場し、**RDDと呼ばれる分散データ構造を通じて**、以下のような処理をサポートできる分散計算フレームワークを提案しました。

> 複数の並列操作にわたって作業データセットを再利用するもの

RDD（Resilient Distributed Dataset）は、失われた場合にDAG内の前のノードから再構築可能な、読み取り専用のデータ構造です。

SparkはScalaで実装されており、Scalaの特性は以下の通りです：
- JVM上で動作する言語
- 関数型プログラミングをサポート
- オブジェクト指向

## プログラミングモデル

### RDDの紹介

RDDは4つの方法で作成できます。

1. HDFSなどのファイルシステムから作成
2. Scalaコレクションから作成
3. 既存のRDDから変換（flatMap、map、filterなどを使用）
4. 既存のRDDの永続化方法を変更（RDDは読み取り専用であり、変更操作があると論理的に新しいRDDが作成されます）

さらに、RDDは遅延評価（lazy）で一時的（ephemeral）なデータ構造です。ユーザーは以下の2つの方法でRDDを永続化できます：

- cacheを使用：キャッシュされたRDDは依然として遅延評価ですが、一時的ではなくなります。つまり、最初の評価後に保存され、再利用を待ちます。
- saveを使用：分散ファイルシステムに書き込みます。

ユーザーはアクセス速度とストレージ容量の間でトレードオフを行う必要があります。

### 並列操作

- reduce - 結合則を満たす操作
- collect
- foreach - 副作用を伴う操作

## 例

- ログ統計
- ロジスティック回帰
- ALS（交互最小二乗法）

遅延評価と一時的という2つの特性により、SparkはMapReduceのように動作します。しかし、cacheのステップを追加するだけで、計算を大幅に高速化できます。

## 実装

- （論文執筆当時のバージョン）Mesos上に構築
- 実装の核心はRDDインターフェースにあり、Scalaのオブジェクト指向と関数型の特性を十分に活用しています。
  - getPartitions
  - getIterator(partition)
  - getPreferredLocations(partition) - 局所性を考慮
- タスク（クロージャ）はScalaではJavaオブジェクトであるため、シリアライズして送信できます。実装過程ではScalaのバグも発見されました。
- インタプリタ統合も実装されています。
- 論文執筆時点では、シャッフルはまだ実装されていませんでした。

## 実験結果

- Hadoopを圧倒し、10倍高速
- データセットは小規模

## 関連研究

- 分散共有メモリ（Distributed Shared Memory）
- MapReduce
- ScalaはDryadLINQに類似

## 感想

- まだ非常に初期の研究段階であり、著者は興奮して共有しています。Hadoopよりも10倍高速という結果は非常に印象的です。
- 本論文は比較的概括的な内容です。
- 関数型的で不変（immutable）であるため、遅延評価が可能です。
- Hadoopも、当時のSparkも、MapReduceには敵いませんでした。