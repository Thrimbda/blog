---
"title": "Erkundung der Nebenläufigkeit (Actor) - Teil 2"
"summary": "Dieser Artikel untersucht eingehend die Grenzen geteilter Nachrichtenwarteschlangen in der nebenläufigen Programmierung und zeigt auf, dass in Systemen, in denen verschiedene Worker asynchron arbeiten müssen, geteilte Warteschlangen zu Problemen wie nicht zielgerichteter Nachrichtenübermittlung, zeitlichen Fehlern und Ineffizienz führen. Der Autor analysiert schrittweise die Mängel von Lösungsansätzen wie Kennzeichnungen und Wiederholungsmechanismen und schlägt schließlich das Actor-Modell als grundlegende Lösung vor. Der Artikel erläutert detailliert die Konzepte des Actor-Modells, einschließlich seiner Kernmerkmale wie parallele Ausführung, Entkopplung von Nachrichten und Adressenkommunikation, und bietet ein Beispielcode in Python mit Thread-Implementierung. Die Zusammenfassung betont, dass nebenläufige Programmierung abstraktes Denken erfordert und das Actor-Modell eine effektive Einführung in dieses Gebiet darstellt."
"tags":
  - "python"
  - "Nebenläufigkeit"
  - "Actor-Modell"
  - "Nachrichtenwarteschlange"
  - "Asynchrone Programmierung"
  - "Thread-Kommunikation"
"date": "2017-05-19"
---

---
title: Erkundung der Nebenläufigkeit (Actor) - Teil 2
date: 2017-05-19
taxonomies:
  tags:
    - python
    - Nebenläufigkeit
---

[Im letzten Teil](http://0xc1.space/2017/05/06/初探并发/) haben wir darüber gesprochen, wie Nachrichtenwarteschlangen genutzt werden können, um Nachrichten zwischen Threads (oder Prozessen) zu übermitteln und so die Kommunikation zwischen Threads zu ermöglichen.

<!--more-->

## Geteilte Nachrichtenwarteschlange

Dies basiert auf der Annahme, dass **Nebenläufigkeit lediglich die Durchsatzrate des Systems erhöht**. Unter dieser Annahme erledigt jeder Worker die gleiche Arbeit, daher kann eine gemeinsame Nachrichtenwarteschlange verwendet werden – es spielt keine Rolle, wer die nächste Anweisung erhält.

### Was, wenn wir nicht gleichberechtigt sind?

Was ist, wenn wir ein System implementieren müssen, in dem verschiedene Worker asynchron und mit unterschiedlichen Aufgaben arbeiten (z. B. unser IP-Telefon)? Angenommen, wir verwenden weiterhin die oben beschriebene Methode, bei der alle Worker eine gemeinsame Nachrichtenwarteschlange teilen, entsteht ein Problem: Nachrichten können nicht an bestimmte Worker gesendet werden.

Wie lässt sich dieses Problem lösen? Eine einfache und direkte Lösung besteht darin, jeder Nachricht eine Kennzeichnung hinzuzufügen, um den Empfänger der Nachricht zu identifizieren:

```python
queue = Queue([('Send_to_worker_A', 'do_something1'),
               ('Send_to_worker_B', 'do_something2'),
               ('Send_to_worker_B', 'do_something3'),
               ('Send_to_worker_C', 'do_something4'),
               ('Send_to_worker_A', 'do_something5')])
```

Sieht so aus, als wäre das Problem gelöst, oder? Aber wir haben ein neues Problem eingeführt.

### Was, wenn ich versehentlich den Brief eines anderen öffne?

Wenn eine Nachricht für Worker A von Worker B empfangen wird, ist diese Nachricht für Worker B nutzlos. Der eigentlich vorgesehene Empfänger, Worker A, erhält sie nicht, und die Nachricht geht verloren. Dies verschwendet nicht nur die Zeit von Worker B, sondern auch die von Worker A und könnte durch solche Sprünge das gesamte System in seltsame Bugs stürzen.

Wie lässt sich dieses Problem lösen? Intuitiv betrachtet scheint das Hinzufügen der folgenden Strategie für jeden Worker das Problem zu beheben: Wenn eine Nachricht für einen anderen Worker empfangen wird, wird sie zurück in die Nachrichtenwarteschlange gelegt.

```python
class Worker_B:
    
    def run(self):
        while True:
            if not self.queue.empty():
                data = self.queue.get()
                if data['to_whom'] == 'worker_B':
                    do_something_with_data
                else:
                    self.queue.put(data)
```

Es scheint, als hätten wir das Problem mit Flickwerk gelöst... doch tatsächlich haben wir ein weiteres Problem eingeführt.

### Das scheint eine Sackgasse zu sein

Erstens ist eine Nachrichtenwarteschlange eine Warteschlange, was FIFO (First In, First Out) bedeutet. Selbst wenn wir eine priorisierte Nachrichtenwarteschlange einführen, ändert sich dies im Kern nicht. Dadurch wird eine Nachricht, die eigentlich als erste an Worker A übergeben werden sollte, nach der Manipulation durch Worker B zur letzten in der Warteschlange für Worker A. Dies könnte das System in seltsame Bugs stürzen.

Zweitens: Selbst wenn wir es schaffen, falsch verteilte Nachrichten wieder an den Anfang der Warteschlange zu setzen, müssen wir, sofern wir keine Sperrmechanismen einführen, sicherstellen, dass der Vorgang `Nachricht empfangen – prüfen – zurücklegen` von Worker B atomar abläuft. Andernfalls könnte, während Worker B die Nachricht zurücklegt, bereits ein anderer Worker mit dem Empfang von Nachrichten fortfahren, was weiterhin zu erheblichen zeitlichen Problemen führen kann. Die Einführung von Sperrmechanismen könnte zwar logische Fehler beheben, aber dies würde dazu führen, dass bei jeder Abfrage nur ein Worker tatsächlich arbeiten kann, während andere Worker, die falsche Nachrichten erhalten und den Vorgang `Nachricht empfangen – prüfen – zurücklegen` ausführen, ihre Zeit vergeuden – **ineffizient**.

Daher scheint eine gemeinsame Nachrichtenwarteschlange für alle Worker in Systemen, die Nebenläufigkeit für asynchrone Arbeit einführen, keine gute Lösung zu sein.

Die grundlegende Lösung für dieses Problem besteht darin, für jede Gruppe von Workern, die die gleiche Aufgabe ausführen, eine eigene Nachrichtenwarteschlange (Mailbox) einzurichten – oder sogar für jeden Worker eine eigene Nachrichtenwarteschlange, wodurch die Fähigkeit, Speicher zwischen Threads zu teilen, vollständig aufgegeben wird. Die letztere Methode ist das Thema, über das ich heute sprechen möchte: **das Actor-Modell (Teilnehmer-Modell)**.

## Das Actor-Modell

Schauen wir uns zunächst die Definition und Konzepte des Actor-Modells laut Wikipedia an:

### Konzept

In der Informatik ist das Actor-Modell (englisch: Actor model) ein Modell für nebenläufige Berechnungen. Ein "Actor" ist ein abstraktes Konzept in der Programmierung und gilt als grundlegende Einheit nebenläufiger Berechnungen: Wenn ein Actor eine Nachricht empfängt, kann er Entscheidungen treffen, weitere Actors erstellen, weitere Nachrichten senden und festlegen, wie er auf zukünftige Nachrichten reagieren wird. Das Actor-Modell wurde 1973 in einem Artikel von Carl Hewitt, Peter Bishop und Richard Steiger vorgestellt.

Die Philosophie des Actor-Modells lautet "Alles ist ein Actor", ähnlich wie "Alles ist ein Objekt" in der objektorientierten Programmierung, jedoch wird beim Actor-Modell parallel gearbeitet, während die objektorientierte Programmierung meist sequenziell abläuft. Ein Actor ist eine Berechnungseinheit, die auf empfangene Nachrichten reagiert und parallel:

- eine begrenzte Anzahl von Nachrichten an andere Actors sendet;
- eine begrenzte Anzahl neuer Actors erstellt;
- das Verhalten für den Empfang der nächsten Nachricht festlegt.

Diese Operationen setzen keine sequenzielle Ausführung voraus und können daher parallel durchgeführt werden. Die Entkopplung des Senders von den bereits gesendeten Nachrichten ist der grundlegende Vorteil des Actor-Modells. Dies ermöglicht asynchrone Kommunikation und erfüllt gleichzeitig die Kontrollstrukturen der Nachrichtenübermittlung. Nachrichtenempfänger werden über Adressen unterschieden, die manchmal auch als "Mailadressen" bezeichnet werden. Daher kann ein Actor nur mit Actors kommunizieren, deren Adresse er besitzt. Er kann Adressen über empfangene Informationen erhalten oder die Adressen der von ihm erstellten Actors abrufen. Charakteristisch für das Actor-Modell ist, dass Berechnungen innerhalb oder zwischen Actors parallel ablaufen, Actors dynamisch erstellt werden können, Adressen in Nachrichten enthalten sind, die Interaktion nur über direkte asynchrone Nachrichtenkommunikation erfolgt und die Reihenfolge des Nachrichteneingangs nicht eingeschränkt wird.

### Implementierung

Actors sind einfach genug, für Nebenläufigkeit konzipiert und bieten ausreichende Kapselung, um Änderungen zu isolieren (z. B. unabhängig davon, ob es sich um Multithreading oder Multiprocessing handelt).

Schauen wir uns eine typische Python-Thread-Implementierung eines Actors an:

```python

from queue import Queue
from threading import Thread, Event


class WorkerExit(Exception):
    # Ausnahme zum Beenden von Aufgaben
    pass


class BaseWorker(object):
	# Actor
    def __init__(self):
        self._mailbox = Queue()
        super(BaseWorker, self).__init__()

    def send(self, msg):
        self._mailbox.put(msg)

    def recv(self):
        msg = self._mailbox.get()
        if msg is WorkerExit:
            raise WorkerExit()
        return msg

    def close(self):
        self.send(WorkerExit)

    def start(self):
        self._terminated = Event()
        t = Thread(target=self._bootstrap)

        t.daemon = True
        t.start()

    def _bootstrap(self):
        try:
            self.run()
        except WorkerExit:
            pass
        finally:
            self._terminated.set()

    def join(self):
        self._terminated.wait()

    def run(self):
        raise NotImplementedError
```

 Kurz erklärt: Dieser Actor (ich habe ihn BaseWorker genannt und verwende ihn in realen Projekten als Basisklasse) verwaltet zwei Datenstrukturen: eine `Queue` als Mailbox und ein `Event` als Mechanismus zum Blockieren des Hauptthreads.

Die zentrale Operation als externe Schnittstelle ist hier nur die Methode `send()`. Bitte beachten Sie, dass **wir den Typ der übermittelten Nachrichten nicht einschränken**, was maximale Flexibilität bedeutet.

Innerhalb des Actors verwenden wir einen Thread, um die Methode `run()` in Kombination mit `recv()` auszuführen und die spezifischen Aufgaben zu erledigen. Erwähnenswert ist, dass wir ein Sentinel-Signal `WorkerExit` zum Stoppen von Aufgaben eingeführt haben. Beachten Sie, dass `WorkerExit` als Ausnahme ausgelöst wird, sobald es erkannt wird, und in der Ausnahmebehandlung könnten wir sogar mehr tun – hier beenden wir jedoch lediglich den Thread, wenn diese Ausnahme abgefangen wird. Diese Ausnahmebehandlung wird durch die Methode `_bootstrap()` ermöglicht, die `run()` umschließt.

Basierend auf der Philosophie des Actor-Modells können wir dieses einfache Beispiel erweitern und weiter gehen.

## Zusammenfassung

Nebenläufige Programmierung erfordert eine abstraktere Denkweise als gewöhnlich und kann als gute Praxis für das Prinzip "hohe Kohäsion, geringe Kopplung" dienen.

In meiner Erkundung dieses für mich neuen Gebiets war das Actor-Modell tatsächlich ein Leitstern, der mich wirklich eingeführt hat, daher teile ich es hier. :)