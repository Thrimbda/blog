---
"title": "Segunda Inmersión en Concurrencia (Actor)"
"summary": "Este artículo analiza primero cómo, en sistemas concurrentes que utilizan colas de mensajes compartidas, cuando se necesita que cada trabajador (worker) realice su función específica de forma asíncrona, surgen problemas como la incapacidad de enviar mensajes de forma dirigida, la recepción errónea de mensajes que conduce a ineficiencia y problemas de secuenciación. El autor señala los problemas de eficiencia introducidos por la naturaleza FIFO de las colas de mensajes compartidas y sus mecanismos de bloqueo, y propone como solución radical el uso del modelo de Actor. El modelo de Actor resuelve esto asignando a cada trabajador su propia cola de mensajes independiente (buzón), logrando así comunicación asíncrona y dirigida, y evitando la complejidad de la memoria compartida. El artículo explica en detalle el concepto del modelo de Actor y proporciona un código de ejemplo implementado con hilos en Python, mostrando cómo implementar la funcionalidad básica de un Actor a través de una clase BaseWorker, incluyendo el envío y recepción de mensajes y la gestión de hilos. Finalmente, el autor concluye que la programación concurrente requiere un pensamiento más abstracto, y que el modelo de Actor sirve como una guía para principiantes."
"tags":
  - "python"
  - "concurrencia"
  - "modelo de Actor"
  - "cola de mensajes"
  - "programación asíncrona"
"date": "2017-05-19"
---

---
title: Segunda Inmersión en Concurrencia (Actor)
date: 2017-05-19
taxonomies:
  tags:
    - python
    - concurrencia
---

[En la ocasión anterior](http://0xc1.space/2017/05/06/初探并发/) hablamos sobre el uso de colas de mensajes para pasar mensajes entre hilos (o procesos) y así lograr comunicación entre ellos.

<!--more-->

## La cola de mensajes compartida

Esto se basa en la premisa de que **la concurrencia solo sirve para mejorar la tasa de procesamiento del sistema**. Bajo esta suposición, cada trabajador realiza el mismo trabajo, por lo que pueden compartir una cola de mensajes; no importa quién reciba la siguiente instrucción.

### ¿Y si no somos iguales?

¿Qué pasa si necesitamos implementar un sistema donde cada trabajador realice su función específica de forma asíncrona (por ejemplo, nuestro teléfono IP)? Supongamos que seguimos usando el método anterior, donde todos los trabajadores comparten una cola de mensajes. En este caso, surge un problema: no se pueden enviar mensajes a un trabajador específico.

¿Cómo resolver este problema? Una solución simple y directa es agregar una etiqueta a cada mensaje para identificar a quién va dirigido:

```python
queue = Queue([('Send_to_worker_A', 'do_something1'),
               ('Send_to_worker_B', 'do_something2'),
               ('Send_to_worker_B', 'do_something3'),
               ('Send_to_worker_C', 'do_something4'),
               ('Send_to_worker_A', 'do_something5')])
```

Parece que el problema se resuelve fácilmente, ¿verdad? Pero hemos introducido un nuevo problema.

### Si accidentalmente abro una carta destinada a otro

Si un mensaje destinado al trabajador A es recibido por el trabajador B, este mensaje no le sirve de nada. Mientras tanto, el trabajador A, que debería haberlo recibido, no lo hace, por lo que el mensaje se pierde. Esto no solo desperdicia el tiempo del trabajador B, sino que también consume el tiempo del trabajador A, e incluso podría llevar a todo el sistema a un error extraño debido a un salto en la secuencia.

¿Cómo resolver este problema? Intuitivamente, agregar la siguiente estrategia a cada trabajador parece solucionarlo: si recibe un mensaje destinado a otro, lo vuelve a poner en la cola.

```python
class Worker_B:
    
    def run(self):
        while True:
            if not self.queue.empty():
                data = self.queue.get()
                if data['to_whom'] == 'worker_B':
                    do_something_with_data
                else:
                    self.queue.put(data)
```

Parece que con parches hemos resuelto el problema... pero en realidad hemos introducido otro nuevo.

### Esto parece un callejón sin salida

Primero, una cola de mensajes es una cola, lo que significa FIFO (Primero en Entrar, Primero en Salir). Incluso si introducimos colas de mensajes con prioridad, esto no cambia en esencia. Así, un mensaje que debería ser entregado primero al trabajador A, después de ser manipulado por el trabajador B, se convierte en el último en ser entregado al trabajador A en la cola actual, lo que podría llevar al sistema a un error extraño.

Segundo, incluso si logramos que los mensajes mal dirigidos se vuelvan a insertar al principio de la cola, si no introducimos un mecanismo de bloqueo que haga que la operación `recibir-verificar-devolver` del trabajador B que recibió el mensaje por error sea una operación atómica, entonces, mientras el trabajador B realiza la operación de devolución, otros trabajadores podrían estar continuando con sus operaciones de recepción de mensajes, lo que aún podría causar grandes problemas de secuenciación. Introducir un mecanismo de bloqueo puede resolver el problema lógico, pero haría que en cada ciclo de sondeo solo un trabajador pueda trabajar realmente, mientras que los otros trabajadores que reciben mensajes erróneos y ejecutan la operación `recibir-verificar-devolver` desperdician su tiempo de CPU en vano, **reduciendo la eficiencia.**

Por lo tanto, parece que para sistemas que introducen concurrencia para lograr trabajo asíncrono, que cada trabajador comparta la misma cola de mensajes no es una buena solución.

La forma radical de resolver este problema es crear una cola de mensajes dedicada (buzón) para cada grupo de trabajadores que realizan la misma tarea, o incluso asignar a cada trabajador su propia cola de mensajes, renunciando por completo a la capacidad de memoria compartida entre hilos. Este último método es el protagonista de hoy: **el modelo de Actor (o patrón Actor)**.

## El modelo de Actor

Primero, veamos la definición y conceptos del modelo de Actor según Wikipedia:

### Conceptos

En ciencias de la computación, el modelo de Actor es un modelo de computación concurrente. Un "actor" es una abstracción conceptual en programación, considerada la unidad básica de computación concurrente: cuando un actor recibe un mensaje, puede tomar decisiones, crear más actores, enviar más mensajes y decidir cómo responder a los próximos mensajes. El modelo de Actor fue propuesto en 1973 en un artículo de Carl Hewitt, Peter Bishop y Richard Steiger.

La filosofía que promueve el modelo de Actor es "todo es un actor", similar a la programación orientada a objetos donde "todo es un objeto", pero la programación orientada a objetos suele ser secuencial, mientras que el modelo de Actor es paralelo. Un actor es una entidad computacional que responde a los mensajes que recibe, y puede hacerlo en paralelo:

- Enviar un número limitado de mensajes a otros actores;
- Crear un número limitado de nuevos actores;
- Especificar el comportamiento al recibir el siguiente mensaje.

Las operaciones anteriores no asumen ejecución secuencial, por lo que pueden realizarse en paralelo. La desvinculación entre el remitente y el mensaje ya enviado es la ventaja fundamental del modelo de Actor. Esto permite comunicación asíncrona, al tiempo que satisface las estructuras de control de paso de mensajes. Los destinatarios de los mensajes se distinguen por direcciones, a veces llamadas "direcciones de correo". Por lo tanto, un actor solo puede comunicarse con actores cuyas direcciones posee. Puede obtener direcciones a través de la información recibida o de las direcciones de los actores que crea. Las características del modelo de Actor son: computación paralela dentro o entre actores, los actores pueden crearse dinámicamente, las direcciones de los actores se incluyen en los mensajes, la interacción solo se realiza a través de comunicación asíncrona directa por mensajes, y no se restringe el orden de llegada de los mensajes.

### Implementación

El Actor es lo suficientemente simple, está hecho para la concurrencia y tiene una encapsulación lo suficientemente buena para aislar los cambios (por ejemplo, no importa si es multihilo o multiproceso).

Veamos una implementación típica de un Actor usando hilos en Python:

```python

from queue import Queue
from threading import Thread, Event


class WorkerExit(Exception):
    # Excepción para finalizar la tarea
    pass


class BaseWorker(object):
	# Actor
    def __init__(self):
        self._mailbox = Queue()
        super(BaseWorker, self).__init__()

    def send(self, msg):
        self._mailbox.put(msg)

    def recv(self):
        msg = self._mailbox.get()
        if msg is WorkerExit:
            raise WorkerExit()
        return msg

    def close(self):
        self.send(WorkerExit)

    def start(self):
        self._terminated = Event()
        t = Thread(target=self._bootstrap)

        t.daemon = True
        t.start()

    def _bootstrap(self):
        try:
            self.run()
        except WorkerExit:
            pass
        finally:
            self._terminated.set()

    def join(self):
        self._terminated.wait()

    def run(self):
        raise NotImplementedError
```

Para explicarlo brevemente, este Actor (lo llamé BaseWorker, y en proyectos reales se usa como clase base) mantiene dos estructuras de datos: un `Queue` como buzón y un `Event` como mecanismo para bloquear el hilo principal.

Aquí, la operación central que sirve como interfaz externa es solo el método `send()`. Nótese que **no restringimos el tipo de mensaje que se puede pasar**, lo que brinda una flexibilidad enorme.

Dentro del Actor, usamos un hilo para ejecutar el método `run()` combinado con el método `recv()` para realizar el trabajo específico asignado. Vale la pena mencionar que configuramos una señal centinela, `WorkerExit`, para detener la tarea. Nótese que el principio de funcionamiento de `WorkerExit` es que, cuando se identifica, se lanza como una excepción, y en el manejo de excepciones aquí incluso podríamos hacer más cosas, aunque en este caso solo detenemos la ejecución del hilo cuando capturamos esta excepción. La implementación de este manejo de excepciones depende del método `_bootstrap()` que envuelve a `run()`.

Bajo la filosofía del modelo de Actor, podemos extender este ejemplo simple para ir más allá.

## Conclusión

La programación concurrente requiere una forma de pensar más abstracta de lo habitual, y también puede ser una buena práctica del principio de "alta cohesión, bajo acoplamiento".

En mi exploración de este campo completamente nuevo para mí, el modelo de Actor ha sido ciertamente una luz guía, que me ha llevado a entrar realmente en este mundo, por eso lo comparto aquí. :)