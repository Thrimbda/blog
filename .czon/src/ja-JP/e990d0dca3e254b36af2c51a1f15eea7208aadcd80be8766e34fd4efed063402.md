---
"title": "ソースコードリーディング：Harbor-Operator"
"summary": "本稿は、Harbor-Operatorのソースコードに関する技術分析記事です。著者は、設計理念（例：'Worse is Better'）から始め、Harbor-OperatorがKubernetesプラットフォーム上でGolangを用いて実装されている特徴を紹介します。記事はそのコアアーキテクチャに焦点を当て、Dependency Graphによってリソース間の依存関係をどのように解決するか、また、単一の統一されたControllerによって11種類の異なるCRDの調和（Reconcile）ロジックを実現し、コードの再利用性を大幅に向上させている点を詳しく分析しています。さらに、ResourceManagerやProcessFuncなどの主要コンポーネントの設計を詳細に解説し、Harbor-Operatorが単純性、一貫性、保守性の追求において示す優れた実践例を紹介しています。"
"tags":
  - "Operator"
  - "Kubernetes"
  - "Golang"
  - "ソースコード分析"
  - "Harbor"
  - "デザインパターン"
  - "依存グラフ"
  - "Controller"
"date": "2022-01-30"
---

<!--more-->

<a id="orgdafefdb"></a>

## 開始前の準備

<a id="org081213e"></a>

### なぜHarbor-Operatorなのか

<a id="org55a74c9"></a>

#### Worse is Better?

優れたソフトウェアとは何でしょうか？

1980年代後半の有名な記事「The Rise of Worse is Better」の中で、著者は優れたソフトウェア設計は**単純性、正確性、一貫性、完全性**という4つの特質を考慮すべきだと述べています。

記事では、**the right thing** と **worse is better**（この命名は否定的な意味ではないことを強調しておきます）という2つのソフトウェア設計理念が紹介されています。どちらの理念も上記の4つの特質を中心に展開されていますが、これらの特質に対する優先順位が異なります。

---

<a id="orgbebeeee"></a>

##### The right thing

- **単純性** - 設計は単純で理解しやすいものでなければなりません。インターフェースの単純さは実装の単純さよりも重要です。
- **正確性** - 設計は正確でなければなりません。この点は一切譲歩できません。
- **一貫性** - 一貫性は正確性と同じくらい重要です。そのため、単純性と完全性は多少犠牲にしても構いません。
- **完全性** - 設計は様々な状況を考慮しなければなりません。単純性を保つために完全性を過度に犠牲にしてはいけません。

<a id="org948c614"></a>

##### Worse is better

- **単純性** - 設計は単純で理解しやすいものでなければなりません。実装の単純さはインターフェースの単純さよりも重要です。単純性が最も重要な特質です。
- **正確性** - 設計は正確でなければなりません。もちろん、単純性を保つことは正確性よりも少し重要です。
- **一貫性** - 設計はあまりにも一貫性を欠いてはいけません。単純性を保つために一貫性を犠牲にすることができます。単純性が保証されている限り、完全性のために一貫性を犠牲にすることもできます。
- **完全性** - 設計は様々な状況を考慮しなければなりません。設計を単純に保つために、いつでも完全性を犠牲にすることができます。

---

その後、著者は両者の多くの例を挙げ、なぜworse-is-betterが当時のソフトウェア業界を席巻しているのかを論じています。

この2つの理念に優劣はありません。今日でも私たちの身の回りに存在し、実際の状況はしばしば両者の間を行き来します。私たちは優れた、美的価値のある設計を望みますが、コストや人的要因も考慮しなければなりません。最終的には、現実世界の問題を解決するために、品質が基準を満たし、動作するソフトウェアを提供する必要があります。そして、ソフトウェアの作成・保守コストが、問題そのものの価値を絶対に上回ってはなりません。

<a id="org514ce0b"></a>

#### Golang - その言語

Golangは、ほぼ間違いなくworse is better理念の典型例と言えるでしょう：

- Googleが長年にわたってC++で蓄積してきた実践的知見が凝縮されています。
- 非常に単純で、複雑な機能は一切ありません。そのため、問題を解決するための基本的な構成要素（building block）はほぼ1種類しかありません。これはつまり：
    - 言語自体にほとんど労力をかけずに簡単に習得できる。
    - コードが非常に読みやすい。
- コンパイルが高速で、コンパイル速度のためにジェネリクスさえも犠牲にしました。
- goroutineを使って並行タスクを非常に簡単に実行できます。
- 例外スタックという言語機能をほぼ捨て、エラーチェックと処理を強制します。
- 一度コンパイルすれば、どこでも実行できます。

<a id="org2432232"></a>

#### Kubernetes - そのプラットフォーム

Kubernetesは皆さんよくご存知だと思いますので、ここでは詳しく説明しません。一言で言えば：概念的に非常にシンプルなAPI設計を提供し、サイバネティクスに基づく調和（Reconcile）メカニズムを補完することで、コンテナ化されたソフトウェアを自動的にデプロイ、拡張、運用できるようにしています。

k8sは、このAPI仕様と調和メカニズムを公開することで、開発者がその機能を拡張できるようにしています。開発者は**Operatorパターン**を実装できます：ソフトウェアの設定、デプロイ（Day-1）および運用、バックアップ、フェイルオーバー（Day-2）に関する知識を、ソフトウェアを操作するためのソフトウェアとしてコード化し、これらの複雑でエラーが発生しやすい操作を自動化することで、信頼性を高め、コストを削減します。

---

では、Harbor Operatorを選んだ理由は、その優れた設計にあると言えます。優れたプラットフォーム上で、シンプルな言語特性を用い、過度な技巧に頼らず、SOLID設計原則に適合するいくつかの重要な設計によって、実用的で美的価値のあるソフトウェアシステムを実現しており、**the right thing**理念の実践者と見なすことができるからです。

著者のコードにはほとんどコメントがありませんが、異常に読みやすいです。これは、システム全体の設計にもよるものです。

<a id="org6815286"></a>

## 目標

問題を抽象化して単純化することは、必然的に柔軟性の犠牲を伴います。一方、Harbor Operatorは柔軟性を完全に捨て去ることで、最大限の思考負荷軽減をもたらし、Operatorの開発がソフトウェア設定を宣言するようなものになるようにしています。

client-goを使って手動でoperatorを書くことは、golangにジェネリクスが欠けていることもあり、まさに自ら苦しみを求めるようなものです。プロジェクト全体に大量のボイラープレートコードが溢れかえることになるでしょう。client-goで手動で書くにしても、実際にゼロから書き始める人はいないと確信しています。

そこで**kubebuilder**が登場しました。Kubernetes Clientの作成、Kubernetes API Serverへのリクエストの監視、およびリクエストのキューイングなどの操作を、共通ライブラリである**controller runtime**と共通ツールである**controller tools**に抽象化し、開発者がAPIオブジェクト変更リクエストのビジネスロジック開発に集中できるように、スキャフォールディングコードを生成することができます。

Kubebuilderは依然としてビジネスロジックの多様性に一筋の活路を残していますが、Harbor Operatorはその上でさらに極限を追求し、概念の一貫性と単純性を追求するために柔軟性を完全に犠牲にしています。そして、それが直面しているビジネスは、まさにこのアプローチに非常に適しています。

したがって、今回のソースコードリーディングにおける主な目標は、Harbor Operatorから以下を学ぶことです：

- Day-1操作をどのように行うか
- 同一のControllerコードを使用して、11種類の異なる階層のCRDのControllerを実現することで、operatorコードの冗長性をさらにどのように削減するか
- DAG（有向非巡回グラフ）を利用してリソース間の依存関係をどのように解決するか（著者はこのために特許を出願しているようです）

一方、以下については重点的に研究しません：

- Harbor OperatorにおけるDay-2操作（実際、現在のバージョンではこの機能はまだ不安定です）
- Harbor自体のソースコードと機能

<a id="org345a335"></a>

## ソースコードリーディング

<a id="org1198d5f"></a>

### 静的構造

<a id="orgb32de77"></a>

#### ディレクトリ構造

ここではディレクトリのみをリストアップします。

```
    root
    ├── apis
    │   ├── goharbor.io
    │   │   └── v1alpha3
    │   └── meta
    │       └── v1alpha1
    ├── controllers
    │   ├── controller_string.go
    │   ├── controllers.go
    │   └── goharbor
    │       ├── chartmuseum
    │       ├── controller_test.go
    │       ├── core
    │       ├── exporter
    │       ├── harbor
    │       ├── harborcluster
    │       ├── internal
    │       ├── jobservice
    │       ├── notaryserver
    │       ├── notarysigner
    │       ├── portal
    │       ├── registry
    │       ├── registryctl
    │       └── trivy
    ├── pkg
    │   ├── builder
    │   ├── cluster
    │   │   ├── controllers
    │   │   │   ├── cache
    │   │   │   ├── common
    │   │   │   ├── database
    │   │   │   │   └── api
    │   │   │   ├── harbor
    │   │   │   └── storage
    │   │   ├── gos
    │   │   ├── k8s
    │   │   └── lcm
    │   ├── config
    │   │   ├── harbor
    │   │   └── template
    │   ├── controller
    │   │   ├── errors
    │   │   ├── internal
    │   │   │   └── graph
    │   │   └── mutation
    │   ├── event-filter
    │   ├── exit
    │   ├── factories
    │   │   ├── application
    │   │   ├── logger
    │   │   └── owner
    │   ├── graph
    │   ├── harbor
    │   ├── image
    │   ├── manager
    │   ├── resources
    │   │   ├── checksum
    │   │   └── statuscheck
    │   ├── scheme
    │   ├── setup
    │   ├── status
    │   ├── template
    │   ├── tracing
    │   ├── utils
    │   │   └── strings
    │   └── version
    ...
```

<a id="orgfc0f08e"></a>

#### 主要インターフェース

![img](https://0xc1.space/images/2022/01/30/harbor-operator-class.svg)

<a id="org290c6c2"></a>

#### システムアーキテクチャ

v1.0.1時点で、Harbor Operatorは現在主にHarborシステムのDay-1操作を担当しています。
![img](https://0xc1.space/images/2022/01/30/harbor-operator-arch.png)

<a id="org41c8944"></a>

### 大局を捉える：HarborCluster

まず、あまり重要ではない部分を除外しましょう：**HarborCluster** というCRDとそのControllerの実装です。

なぜ特殊だと言えるのでしょうか？まず、システムアーキテクチャ内での位置を観察してください：最上位に位置し、Harborシステム自体とその依存するすべてのステートフルサービスを管理しています。これは、プロジェクトの歴史と、システムアーキテクチャ内での特殊な地位の両方から説明する必要があります。

システムアーキテクチャの観点から見ると、このHarborCluster CRDは定義上、Harbor CRDと非常に似通っており、コードに大量の冗長性があり、非常に見苦しいです。これは、システム全体の中で最も上（外）側のCRDとして、ユーザーに直接向き合っているためです。ユーザーにHarborデプロイメントに必要なすべての設定項目を宣言的に提供できなければなりません。さらに、Harbor自体はステートレスサービスであるため、完全なデプロイメントには、HarborCluster CRDがHarborシステムが依存するすべてのステートフルサービス（Postgres、Minio、Redisを含む）を管理する必要があります。

Harborシステム自体に必要な情報はすでにHarbor CRDで定義されているため、HarborCluster CRD内の冗長部分は、この情報をHarbor CRDに完全かつ正確に渡すことです。さらに、HarborCluster CRDは、自身の責務範囲外にあるステートフルサービスのCRDを管理する必要があるため、HarborおよびHarborのすべてのサブコンポーネント内のControllerロジックを完全に使用することはできません。

歴史的な観点から見ると、Harbor OperatorはもともとOVH Cloudのプライベートプロジェクトであり、後にgoharborコミュニティに寄贈されました。したがって、gitの履歴を観察すると、HarborClusterのCRD定義とそのControllerの実装が、システム内の他のControllerとこれほど大きな不一致を持つ理由は、それがコミュニティによって寄贈された後発者であり、Harbor Operatorの設計当初は、それが担うべき機能が考慮されていなかったためです。

また、HarborCluster Controller自体の実装は、私たちが普段目にする、Controller-runtimeを使用して実装された大多数のControllerと大きな違いはないため、詳細な研究は行いません。

---

HarborCluster Controller

![img](https://0xc1.space/images/2022/01/30/harbor-cluster-controller.png)

---

Harbor Core Controller

![img](https://0xc1.space/images/2022/01/30/harbor-core-controller.png)

---

<a id="orgd9c3526"></a>

### リソース間の依存関係の解決： Dependency Graph

依存グラフは、プロジェクト全体の中で比較的独立したモジュールですが、実際にはHarbor Operator内のすべてのcontrollerの実行エンジンとしての役割を担っています。本質的には、Kubernetes内の各種リソース間に相互依存関係が存在し、一部のリソースのデプロイと調和は他のリソースのデプロイと調和に依存しているという観察に基づいています。例えば、DeploymentはConfigmapに依存するかもしれません。最終的にこれらの依存関係は依存グラフを構成します。実際、このグラフはDAG（有向非巡回グラフ）であるべきです。ここで必要なインターフェース定義は以下の通りです：

```go
    package graph

    type Resource interface{}

    type RunFunc func(context.Context, Resource) error

    type Manager interface {
            Run(ctx context.Context) error
            AddResource(ctx context.Context, resource Resource, blockers []Resource, run RunFunc) error
    }

    type resourceManager struct {
       resources map[Resource][]Resource
       functions map[Resource]RunFunc

       lock sync.Mutex
    }
```

- ここで、**Resource**は抽象的なリソースを定義しています。このモジュールはリソースが何を表しているかに関心がなく、言語の表現力の制限下で最大限の柔軟性を保持するために、トップタイプである`interface{}`を使用しています。
- **RunFunc**は、特定のResourceに対してどのように操作を行うかを担当します。ここでRunFuncは型安全性の問題に直面します：`interface{}`はコンパイラがその型について何も知らないことを意味し、手がかりがありません。しかし、RunFuncはこの「何でもあり得る」型を使って何かをしなければなりません。したがって、型アサーション（強制型変換）を行う必要があると考えられます。各リソースのRunFuncが手動で具体的な型にキャストしなければならないとしたら、非常に退屈で不快なものになってしまいます。後で、Harbor Operatorがどのようにこの面倒な作業を一箇所に集中させるかを見てみましょう。
- **Manager**には2つのメソッドしかありません：リソースの追加と、このグラフの実行です。それぞれ研究する必要があります。
- Managerを実装した**resourceManager**のデータ構造の定義も非常にシンプルです：
    - `resource -> blockers` のマップ
    - `resource -> runFunc` のマップ
    - map操作の並行性を処理するためのlock。ここから、著者が型安全性を失う代わりに並行安全性を保証する`Sync Map`のようなデータ構造を好まないことがわかります。これにより、著者がどのようにして多数（11個のコンポーネント）のRunFuncを処理しているのか、さらに興味が湧いてきます。

グラフである以上、グラフのデータ構造と、このグラフを構築するファクトリメソッドが必要です。resourceManagerのデータ構造は少し生硬に見え、これが本当のグラフなのかどうかは定かではありません。

<a id="org75cbb07"></a>

#### AddResource

シグネチャから、AddResourceは追加されるリソース自体とそのすべての依存関係、および対応するrunFuncを追加していることがわかります。注目すべき点は、依存関係のないリソース（つまり出次数が0のリソース）を最初に追加しなければならないことです。

```go
    func (rm *resourceManager) AddResource(ctx context.Context, resource Resource, blockers []Resource, run RunFunc) error {
       if resource == nil {
          return nil
       }

       if run == nil {
          return errors.Errorf("unsupported RunFunc value %v", run)
       }

       span, _ := opentracing.StartSpanFromContext(ctx, "addResource", opentracing.Tags{
          "Resource": resource,
       })
       defer span.Finish()

       nonNilBlockers := []Resource{}

       for _, blocker := range blockers {
          if blocker == nil {
             continue
          }

          nonNilBlockers = append(nonNilBlockers, blocker)

          _, ok := rm.resources[blocker]
          if !ok {
             return errors.Errorf("unknown blocker %+v", blocker)
          }
       }

       rm.lock.Lock()
       defer rm.lock.Unlock()

       _, ok := rm.resources[resource]
       if ok {
          return errors.Errorf("resource %+v already added", resource)
       }

       rm.resources[resource] = nonNilBlockers
       rm.functions[resource] = run

       return nil
    }
```

<a id="org4cb9f3a"></a>

#### Run

このパッケージのほぼすべての重要なロジックは、Runというメソッドにあります。まず前半部分を見てみましょう：

```go
    func (rm *resourceManager) Run(ctx context.Context) error {
       span, ctx := opentracing.StartSpanFromContext(ctx, "walkGraph", opentracing.Tags{
          "Nodes.count": len(rm.resources),
       })
       defer span.Finish()

       g := errgroup.Group{}
       l := logger.Get(ctx)

       for _, no := range rm.getGraph(ctx) {
       ...
```

現れました！`getGraph`。どうやらグラフを構築するようです。中に入ると、確かにresourceManagerは単なるビルダーであり、本当のグラフはここに隠れていて、隣接リストで表現されています。一見すると複雑に見えるかもしれません：

```go
    type node struct {
       resource Resource
       fn       RunFunc

       parent      chan error
       parentLock  *sync.Mutex
       parentCount int

       children     []chan<- error
       childrenLock []*sync.Mutex
    }

    func (no *node) Wait(ctx context.Context) error {...}
    func (no *node) Terminates(err error) (result error) {...}
    func (no *node) AddChild(child *node) {...}
```

なぜParentとchildrenがchannelなのか、なぜそんなに多くのlockが必要なのか。グラフの構築過程を観察してみましょう：

```go
    func (rm *resourceManager) getGraph(ctx context.Context) []*node {
       span, _ := opentracing.StartSpanFromContext(ctx, "getGraph")
       defer span.Finish()

       rm.lock.Lock()
       defer rm.lock.Unlock()

       graph := make(map[Resource]*node, len(rm.resources))
       result := make([]*node, len(rm.resources))

       i := 0

       for resource, blockers := range rm.resources {
          blockerCount := len(blockers)

          node := &node{
             resource: resource,
             fn:       rm.functions[resource],

             parent:      make(chan error, blockerCount),
             parentLock:  &sync.Mutex{},
             parentCount: blockerCount,

             children:     []chan<- error{},
             childrenLock: []*sync.Mutex{},
          }
          graph[resource] = node
          result[i] = node

          i++

          blockers := blockers

          defer func() {
             for _, blocker := range blockers {
                graph[blocker].AddChild(node)
             }
          }()
       }

       return result
    }
```

なるほど、依存関係が逆転しています。今では、依存される側が依存する側を指しています。各リソースに対してnodeを構築し、同時にリソースの各依存関係に対して、このリソースのparent chanを依存関係のchildrenに追加します。最終的なグラフはnodeの集合です。

これではどうしても混乱してしまいます。そこで、実行過程を観察してみましょう：

```go
    for _, no := range rm.getGraph(ctx) {
       no := no

       g.Go(func() (err error) {

          defer func() {
             err := no.Terminates(err)
             if err != nil {
                l.Error(err, "failed to terminate node when running graph")
             }
          }()

          err = no.Wait(ctx)
          if err != nil {
             return err
          }

          err = no.fn(ctx, no.resource)

          return err
       })
    }
```

非常に単純で強引です。各nodeについて、その入次数nodeの実行が完了するのを待ってから、自身のrunFuncを実行し、潜在的なエラーを、その後のチェーンで待機しているすべての実行待ちnodeに伝播させ、早期に中止させます。

ここで、なぜトポロジカルソートを使ってこの定義が明確な古典的な問題を解決しないのか、非常に理解できません。

<a id="orgdcd001c"></a>

#### 初期化

```go
    GraphManagerの初期化には、スレッドローカルなグローバル変数が使用され、初期化後は空中（ctx）に投げられます。これは、各種APIフレームワークでよく見られる依存性注入の方法です。
    func (c *Controller) NewContext(req ctrl.Request) context.Context {
            ctx := context.TODO()
            application.SetName(&ctx, c.GetName())
            application.SetVersion(&ctx, c.GetVersion())
            application.SetGitCommit(&ctx, c.GetGitCommit())
            ctx = sgraph.WithGraph(ctx)

            logger.Set(&ctx, c.Log.WithValues("request", req))

            return ctx
    }

    func WithGraph(ctx context.Context) context.Context {
            return context.WithValue(ctx, &graphKey, graph.NewResourceManager())
    }

    func Get(ctx context.Context) graph.Manager {
            g := ctx.Value(&graphKey)
            if g == nil {
                    return nil
            }

            return g.(graph.Manager)
    }
```

<a id="org73ef8b0"></a>

### コードの再利用性を極限まで高める：Controller

以前に除外したHarborCluster Controllerを除いて、Harbor Operator内のすべてのコンポーネントのControllerは、この同じControllerを直接組み合わせており、すべてのControllerの共通ロジックを抽出し、同じRun、同じReconcileを使用しています。どうやって実現しているのでしょうか？

- どのようなロジックを抽出したのか
- 相違点をどのように処理するのか
- 何を犠牲にしたのか

<a id="orgbd581d5"></a>

#### データ構造

Controllerのインターフェース実装は、Reconcilerを実装している以外に特に面白い点はありません。それでは、Controllerのデータ構造定義を見てみましょう：

```go
    type ResourceManager interface {
            AddResources(context.Context, resources.Resource) error
            NewEmpty(context.Context) resources.Resource
    }

    type Controller struct {
            client.Client

            BaseController controllers.Controller
            Version        string
            GitCommit      string

            ConfigStore *configstore.Store
            rm          ResourceManager
            Log         logr.Logger
            Scheme      *runtime.Scheme
    }
```

よくわからないものは、BaseControllerとrmだけです。

BaseControllerを見ると、基本的にはController自身の情報やラベル情報を識別するためのもので、Controller間の異なるロジックの差異はResourceManagerの中にしか存在しない可能性があります。ResourceManagerも非常にシンプルなインターフェースに見え、ResourceManagerを実装しているのは確かに各具体的なControllerです。ResourceManagerの具体例については最後に研究します。

```go
    type Controller int

    const (
       Core                Controller = iota // core
       JobService                            // jobservice
       Portal                                // portal
       Registry                              // registry
       RegistryController                    // registryctl
       ChartMuseum                           // chartmuseum
       Exporter                              // exporter
       NotaryServer                          // notaryserver
       NotarySigner                          // notarysigner
       Trivy                                 // trivy
       Harbor                                // harbor
       HarborCluster                         // harborcluster
       HarborConfiguration                   // harborconfiguration
    )

    func (c Controller) GetFQDN() string {
       return fmt.Sprintf("%s.goharbor.io", strings.ToLower(c.String()))
    }

    func (c Controller) Label(suffix ...string) string {
       return c.LabelWithPrefix("", suffix...)
    }

    func (c Controller) LabelWithPrefix(prefix string, suffix ...string) string {
       var suffixString string
       if len(suffix) > 0 {
          suffixString = "/" + strings.Join(suffix, "-")
       }

       if prefix != "" {
          prefix = "." + prefix
       }

       return fmt.Sprintf("%s%s%s", prefix, c.GetFQDN(), suffixString)
    }
```

<a id="orgc9dc9b0"></a>

#### Reconcileロジック

では、Controllerはどのようにして単一のReconcileを使用するだけで、harborファミリーの11種類のCRDとそれに伴う多くのシステムリソースをreconcileできるのでしょうか？

上記ですでに知っている情報によれば、各CRDに対してResourceManagerを使用して、そのCRDが作成および調和する必要がある各種リソースを定義し、これらのリソースは依存グラフによって依存関係を定義し、各CRDに対して具体的なRunFuncを記述して最終的な調和を完了するはずです。

```go
    func (c *Controller) Reconcile(req ctrl.Request) (ctrl.Result, error) {
       ctx := c.NewContext(req)

       span, ctx := opentracing.StartSpanFromContext(ctx, "reconcile", opentracing.Tags{
          "resource.namespace": req.Namespace,
          "resource.name":      req.Name,
          "controller":         c.GetName(),
       })
       defer span.Finish()

       l := logger.Get(ctx)

       // インスタンスを取得

       object := c.rm.NewEmpty(ctx)

       ok, err := c.GetAndFilter(ctx, req.NamespacedName, object)
       if err != nil {
          // オブジェクトの読み取りエラー
          return ctrl.Result{}, err
       }

       if !ok {
          // リクエストオブジェクトが見つかりません。reconcileリクエストの後に削除された可能性があります。
          // 所有されているオブジェクトは自動的にガベージコレクションされます。追加のクリーンアップロジックにはファイナライザーを使用してください。
          l.Info("オブジェクトが存在しません")

          return ctrl.Result{}, nil
       }

       if !object.GetDeletionTimestamp().IsZero() {
          logger.Get(ctx).Info("オブジェクトは削除中です")

          return ctrl.Result{}, nil
       }

       owner.Set(&ctx, object)

       if err := c.Run(ctx, object); err != nil {
          return c.HandleError(ctx, object, err)
       }

       return ctrl.Result{}, c.SetSuccessStatus(ctx, object)
    }
```

非常に典型的なReconcileロジックです。どうやら工夫は`c.Run`の中にあるようです：

```go
    func (c *Controller) Run(ctx context.Context, owner resources.Resource) error {
       span, ctx := opentracing.StartSpanFromContext(ctx, "run")
       defer span.Finish()

       logger.Get(ctx).V(1).Info("オブジェクトを調和しています")

       if err := c.rm.AddResources(ctx, owner); err != nil {
          return errors.Wrap(err, "リソースを追加できません")
       }

       if err := c.PrepareStatus(ctx, owner); err != nil {
          return errors.Wrap(err, "オーナーのステータスを準備できません")
       }

       return sgraph.Get(ctx).Run(ctx)
    }
```

確かにrmがここに現れました。特定のControllerが必要とするリソースを追加した後、`PrepareStatus`は統一されたもののようです。このメソッドのソースコードとCRD定義を組み合わせると、すべてのコンポーネントが同じStatusを持つことを前提としていることがわかります。これもまた、柔軟性を犠牲にして単純性と一貫性を求める設計です。実際、この設計はK8sが推奨する規範に従っており、CRDを設計する際の参考にすることができます。ここでは詳しく説明しません。

最後の行：`sgraph.Get(ctx).Run(ctx)`。依存グラフが来ました。空中（ctx）から取り出します。これでこの部分のロジックは完結しました。残る問題は：ResourceManagerを実装した各具象Controllerが、どのように依存グラフを構築し、自身のRunFuncを構築するかです。

<a id="orgb7ed9a6"></a>

### コードが設定そのもの：ResourceManager

最後のステップは、水が流れるように自然に進みます。

ResourceManagerを実装したすべてのControllerは、地位的に平等であるはずです。harbor coreという一つの例を借りて、その実態を探ってみましょう。

具体的なK8sリソースを生成する部分を除いて、注目すべきはResourceManagerインターフェースを実装した部分です。

```go
    func (r *Reconciler) NewEmpty(_ context.Context) resources.Resource {
       return &goharborv1.Core{}
    }

    func (r *Reconciler) AddResources(ctx context.Context, resource resources.Resource) error {
       core, ok := resource.(*goharborv1.Core)
       if !ok {
          return serrors.UnrecoverrableError(errors.Errorf("%+v", resource), serrors.OperatorReason, "リソースを追加できません")
       }

       service, err := r.GetService(ctx, core)
       if err != nil {
          return errors.Wrap(err, "サービスを取得できません")
       }

       _, err = r.Controller.AddServiceToManage(ctx, service)
       if err != nil {
          return errors.Wrapf(err, "サービス %s を追加できません", service.GetName())
       }

       configMap, err := r.GetConfigMap(ctx, core)
       if err != nil {
          return errors.Wrap(err, "configMapを取得できません")
       }

       configMapResource, err := r.Controller.AddConfigMapToManage(ctx, configMap)
       if err != nil {
          return errors.Wrapf(err, "configMap %s を追加できません", configMap.GetName())
       }

       secret, err := r.GetSecret(ctx, core)
       if err != nil {
          return errors.Wrap(err, "シークレットを取得できません")
       }

       secretResource, err := r.Controller.AddSecretToManage(ctx, secret)
       if err != nil {
          return errors.Wrapf(err, "シークレット %s を追加できません", secret.GetName())
       }

       deployment, err := r.GetDeployment(ctx, core)
       if err != nil {
          return errors.Wrap(err, "デプロイメントを取得できません")
       }

       _, err = r.Controller.AddDeploymentToManage(ctx, deployment, configMapResource, secretResource)
       if err != nil {
          return errors.Wrapf(err, "デプロイメント %s を追加できません", deployment.GetName())
       }

       err = r.AddNetworkPolicies(ctx, core)

       return errors.Wrap(err, "ネットワークポリシー")
    }
```

なんということでしょう。リソースを順番に追加する必要があることを除けば、これはまさに宣言的設計そのものです。新しいControllerを追加したい場合、非常に簡単です：そのControllerがどのリソースを調和する必要があるかさえわかればよく、具体的なReconcileロジックを管理する必要はありません。

待ってください、RunFuncは自分で実装する必要はないのでしょうか？これが今回のソースコードリーディングの最後の問題です。harbor operatorが任意のResourceのReconcileプロセスを汎化し、単一の関数に抽象化する方法を見てみましょう。

例えば、ここに`r.Controller.AddServiceToManage(ctx, service)`があります。

```go
    func (c *Controller) AddServiceToManage(ctx context.Context, resource *corev1.Service, dependencies ...graph.Resource) (graph.Resource, error) {
       if resource == nil {
          return nil, nil
       }

       mutate, err := c.GlobalMutateFn(ctx)
       if err != nil {
          return nil, err
       }

       res := &Resource{
          mutable:   mutate,
          checkable: statuscheck.True,
          resource:  resource,
       }

       g := sgraph.Get(ctx)
       if g == nil {
          return nil, errors.Errorf("現在のコンテキストにグラフがありません")
       }

       return res, g.AddResource(ctx, res, dependencies, c.ProcessFunc(ctx, resource, dependencies...))
    }
```

興味深い点が2つあります：

1.  Resourceの定義。これは以前に見たことがありません。
2.  Graph AddResourceの呼び出しが現れました。私たちが気になるRunFuncの構築はここにあります。後で研究します。

まず、このResourceを見てみましょう。Graphでは、Resourceが具体的に何であるかに関心がないため、`interface{}`が与えられていました。ここではResourceに関心があるため、比較的重要です：

```go
    package controller

    type Resource struct {
            mutable   resources.Mutable
            checkable resources.Checkable
            resource  resources.Resource
    }

    package resources

    type Mutable func(context.Context, runtime.Object) error

    func (m *Mutable) AppendMutation(mutate Mutable) {
       old := *m
       *m = func(ctx context.Context, resource runtime.Object) error {
          if err := old(ctx, resource); err != nil {
             return err
          }

          return mutate(ctx, resource)
       }
    }

    func (m *Mutable) PrependMutation(mutate Mutable) {
       old := *m
       *m = func(ctx context.Context, resource runtime.Object) error {
          if err := mutate(ctx, resource); err != nil {
             return err
          }

          return old(ctx, resource)
       }
    }

    type Resource interface {
       runtime.Object
       metav1.Object
    }

    type Checkable func(context.Context, runtime.Object) (bool, error)
```

本質的には、K8sのジェネリックリソースをベースに、Harbor Operatorがいくつかの追加のカプセル化を行っていることがわかります。

これらの追加のカプセル化は、checkableとmutableです。

checkableはリソースの正当性チェックを定義しており、比較的シンプルです。

Mutableは見た目が派手ですが、実際には単純なモナド合成です。

---

Mutableはモナドを構成します。関数合成と異なるのは、合成するたびに計算結果が追加の結果を生成し、計算の副作用を表現するために使用されるため、関数を直接連続して適用することができない点です。一部の関数型言語では、モナド合成を実現するためにfish operator `>=>` が提供されています。

Scala構文で記述されたfish operatorのシグネチャは以下の通りです：

```go
    def >=>[A, B, C](f: A => M[B], g: B => M[C]): A => M[C]
```

わかりやすく言えば、mutableデータ構造は、多くのmutation functionを特定の順序で組み合わせることを可能にし、エラーが発生した場合には直接終了します。

---

これで、RunFuncを構築する方法を研究するための前提条件がすべて揃いました。最後に、harbor operatorがこれらの前提条件を利用して、まったく異なるResourceに対して、同じロジックを通じてReconcileの具体的な実装をどのように構築するかを見てみましょう。

<a id="orgcce49ab"></a>

### 最後の謎：ProcessFunc

ProcessFuncは本質的には高階関数であり、クロージャを使用してdepManager（主にリソース自体とその依存関係のチェックサムを計算および変更するために使用されます）をキャプチャします。

構築されたRunFuncは、まずリソースとその依存関係が変更されたかどうかをチェックし、変更されていなければ、readyをチェックするだけで終了します。そうでなければ、次回のチェック用にチェックサムを更新した後、`c.applyAndCheck`を呼び出して実際の変更をReconcileします。

```go
    func (c *Controller) ProcessFunc(ctx context.Context, resource runtime.Object, dependencies ...graph.Resource) func(context.Context, graph.Resource) error { // nolint:funlen
            depManager := checksum.New(c.Scheme)

            depManager.Add(ctx, owner.Get(ctx), true)

            gvks, _, err := c.Scheme.ObjectKinds(resource)
            if err == nil {
                    resource.GetObjectKind().SetGroupVersionKind(gvks[0])
            }

            for _, dep := range dependencies {
                    if dep, ok := dep.(*Resource); ok {
                            gvks, _, err := c.Scheme.ObjectKinds(dep.resource)
                            if err == nil {
                                    dep.resource.GetObjectKind().SetGroupVersionKind(gvks[0])
                            }

                            depManager.Add(ctx, dep.resource, false)
                    }
            }

            return func(ctx context.Context, r graph.Resource) error {
                    res, ok := r.(*Resource)
                    if !ok {
                            return nil
                    }

                    span, ctx := opentracing.StartSpanFromContext(ctx, "process")
                    defer span.Finish()

                    namespace, name := res.resource.GetNamespace(), res.resource.GetName()

                    gvk := c.AddGVKToSpan(ctx, span, res.resource)
                    l := logger.Get(ctx).WithValues(
                            "resource.apiVersion", gvk.GroupVersion(),
                            "resource.kind", gvk.Kind,
                            "resource.name", name,
                            "resource.namespace", namespace,
                    )

                    logger.Set(&ctx, l)
                    span.
                            SetTag("resource.name", name).
                            SetTag("resource.namespace", namespace)

                    changed, err := c.Changed(ctx, depManager, res.resource)
                    if err != nil {
                            return errors.Wrap(err, "変更検出")
                    }

                    if !changed {
                            l.V(0).Info("依存関係は変更されていません")

                            err = c.EnsureReady(ctx, res)

                            return errors.Wrap(err, "チェック")
                    }

                    res.mutable.AppendMutation(func(ctx context.Context, resource runtime.Object) error {
                            if res, ok := resource.(metav1.Object); ok {
                                    depManager.AddAnnotations(res)
                            }

                            return nil
                    })

                    err = c.applyAndCheck(ctx, r)

                    return errors.Wrapf(err, "%s (%s/%s) の適用", gvk, namespace, name)
            }
    }
```

実際のReconcileロジックは`applyAndCheck`の中にあり、これは以前にResourceに登録されたmutable functionを使用します。

```go
    func (c *Controller) applyAndCheck(ctx context.Context, node graph.Resource) error {
       span, ctx := opentracing.StartSpanFromContext(ctx, "applyAndCheck")
       defer span.Finish()

       res, ok := node.(*Resource)
       if !ok {
          return serrors.UnrecoverrableError(errors.Errorf("%+v", node), serrors.OperatorReason, "リソースを適用できません")
       }

       err := c.Apply(ctx, res)
       if err != nil {
          return errors.Wrap(err, "適用")
       }

       err = c.EnsureReady(ctx, res)

       return errors.Wrap(err, "チェック")
    }

    func (c *Controller) Apply(ctx context.Context, res *Resource) error {
       span, ctx := opentracing.StartSpanFromContext(ctx, "apply")
       defer span.Finish()

       l := logger.Get(ctx)

       l.V(1).Info("リソースをデプロイしています")

       resource := res.resource

       if err := res.mutable(ctx, resource); err != nil {
          return errors.Wrap(err, "変更")
       }

       err := c.Client.Patch(ctx, resource, client.Apply, &client.PatchOptions{
          Force:        &force,
          FieldManager: application.GetName(ctx),
       })
       if err != nil {
          l.Error(err, "リソースをデプロイできません")

          if apierrs.IsForbidden(err) {
             return serrors.RetryLaterError(err, "dependencyStatus", err.Error())
          }

          if apierrs.IsInvalid(err) {
             return serrors.UnrecoverrableError(err, "dependencySpec", err.Error())
          }

          return err
       }

       return nil
    }
```

すべての操作が完了した後、`c.EnsureReady`を呼び出して、以前に登録されたcheckableを呼び出し、Reconcileプロセスを完了させます。

これで、Harbor Operatorのコードの中で私たちが関心を持つ重要な設計の研究は終了です。実に見事なものです。