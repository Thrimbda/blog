---
"title": "Mit dem neuen Blog herumspielen: Ich habe meine Gcores-Talks in den Blog integriert"
"summary": "Dieser Artikel beschreibt detailliert den technischen Prozess, wie der Autor Inhalte von seinen Gcores-Talks in seinen persönlichen Blog migriert hat. Ausgehend von einem alten Blog, der aufgrund veralteter Abhängigkeiten nicht mehr funktionierte, erläutert der Artikel die Wahl von Zola als neuen Blog-Generator. Der Schwerpunkt liegt auf dem Abrufen der Talk-Daten über eine API, deren Verarbeitung in Markdown-Format und der Implementierung einer interaktiven Bildergalerie mit HTML, CSS und JavaScript. Der Autor betont die Freude an der schnellen Feedback-Schleife in der Frontend-Entwicklung und teilt seine RxJS-Implementierung für Touch-Interaktionen. Abschließend resümiert der Artikel die Zufriedenheit über die vollständige Kontrolle über den Blog und die reine Freude am Programmieren, auch wenn der Inhalt relativ oberflächlich ist, der Prozess jedoch erfüllend war."
"tags":
  - "Blog"
  - "Technik"
  - "Frontend-Entwicklung"
  - "Web-Scraping"
  - "Zola"
  - "Gcores"
  - "RxJS"
  - "Markdown"
"date": "2024-06-18"
---

**Dieser Artikel entsprang meiner kindlichen Neugier.**

Im April, während einer Reise, verspürte ich diesen starken Drang, einen Reisebericht zu schreiben, den ich zuerst auf Gcores veröffentlichte. Wie üblich wollte ich dann eine Markdown-Version auf meinem eigenen Blog posten.

Nachdem ich fertig war, stellte ich fest, dass mein Blog kaputt war.

## Der alte Blog

Der Trend, persönliche Blogs zu erstellen, war in meinem Studienjahrgang im dritten Jahr aufgekommen. In diesem [Artikel](./搭好博客后的一点话.md) von vor sieben Jahren, der mir heute peinlich ist, beschrieb ich meine anfänglichen Gedanken beim Aufbau dieses Blogs.

Die Gründe waren: Erstens wollte ich mich dazu anhalten, etwas zu schreiben; zweitens wollte ich praktische Erfahrungen sammeln und einige neue, modische Technologien ausprobieren, die an der Uni nicht gelehrt wurden; und außerdem ist es einfach cool, eine eigene Domain zu haben – zumindest fand ich das.

Lassen Sie uns die Szene von damals nachspielen:

---

Nachdem ich etwas Neues gelernt hatte, notierte ich aufgeregt meine Ideen in einem Markdown-Dokument.

Nach dem Schreiben führte ich lässig ein paar Befehle aus, um den neuen Blogbeitrag hochzuladen:

```shell
$ git add .
$ git commit -m "new blog! hahahaha"
$ git push origin master
```

Dann öffnete ich aufgeregt die CI-Oberfläche – CI war damals noch ziemlich modern, die DevOps-Idee war erst seit ein paar Jahren im Umlauf. Auf der Log-Seite der CI wartete ich darauf, dass der gesamte Blog inklusive dieses Artikels zu einer statischen HTML-Website gebaut wurde, dass Travis die Build-Artefakte mit meinem Schlüssel in das Git-Repository pushte und dass Github die Artefakte veröffentlichte.

Schließlich ging ich auf meine Domain [https://blog.thrimbda.com](https://blog.thrimbda.com) und sah zufrieden den neuen Artikel ganz oben auf der Seite.

---

Im Laufe der Jahre wurde dieser Prozess langweilig, langweilig und doch weiterhin effektiv, bis der Tag kam, an dem er versagte.

## Der neue Blog

An jenem Tag Ende April versuchte ich dreimal hintereinander, die CI-Pipeline neu zu starten, und alle schlugen fehl. Ein kurzer Blick in die Logs zeigte, dass eine Build-Abhängigkeit aufgrund ihres Alters anscheinend aus dem Internet verschwunden war. Mir wurde klar, was für eine enorme Zeitspanne sieben Jahre in dieser Branche sind – lang genug, dass Sandstürme Burgen zerstören und das Meer Berge verschlingt.

Also nutzte ich die Zeit zwischen meiner Arbeit, um mit einigen nicht sonderlich spannenden Anforderungen eine Technologieauswahl zu treffen: **Einfach genug, bequem genug.**

So entstand dieser neue Blog, und wie üblich stelle ich ihn vor:

-   Ich wählte [Zola](https://www.getzola.org/) als Generator;
-   Ich suchte ein sehr einfaches, aber hübsches [Theme](https://github.com/Speyll/anemome) aus;

Als Ersatz für den alten Blog war dieser neue Blog damit fertig.

## Der verspielte Herumspiel-Prozess

Vielleicht weil er neu genug war, oder weil die Technologieauswahl einfach genug war, vielleicht weil die Feedback-Schleife in der Frontend-Arbeit kurz genug ist, und zusätzlich, weil die Arbeit mit Azheng mich unweigerlich mit einigem Frontend-Wissen infiziert hat, was meine Wissenslücken aus dem ersten Studienjahr schloss, wurde das Herumspielen am Blog wieder interessant.

Einige bescheidene CSS-Anpassungen, die Integration eines neuen Giscus, das Hosten der Kommentare auf Github; ich war mit meinem Ich von vor sieben Jahren einer Meinung: Programmieren und an Projekten herumbasteln macht wirklich Spaß, es ist die Freude an der Arbeit, die Freude am Spiel.

Ich möchte mit der Nachwirkung dieser Freude den (selbstverliebten) technischen Prozess beschreiben, wie ich meine Gcores-Talks in den Blog integriert habe.

<!--more-->

---

### Die Daten

Bei einer früheren Erkundung hatte ich bereits festgestellt, dass Gcores Crawlern gegenüber äußerst freundlich ist. Seine Daten-APIs sind sehr einheitlich und ausdrucksstark. Zum Beispiel, wenn man meine Talks erkundet:

![gcores-api-at-glance](https://0xc1.space/images/2024/06/18/gcores-api-at-glance.jpg)

Man entdeckt, dass dies die API zum Abrufen der Talk-Daten ist:

```
https://www.gcores.com/gapi/v1/users/464460/recommend?talk-include=topic%2Cuser%2Chelpful%2Cpoll-options%2Crelated-content.radio%2Crelated-content.video%2Crelated-content.article%2Crelated-content.game%2Crelated-content.film%2Crelated-content.album%2Crelated-content.album-bundle%2Crelated-content.product%2Crelated-content.discussion&original-include=user%2Cdjs%2Ccategory&order-by=time&before=1718720726.986&fields[articles]=title%2Cdesc%2Cexcerpt%2Cis-published%2Cthumb%2Capp-cover%2Ccover%2Ccomments-count%2Clikes-count%2Cbookmarks-count%2Cis-verified%2Cpublished-at%2Coption-is-official%2Coption-is-focus-showcase%2Cduration%2Cdraft%2Caudit-draft%2Cuser%2Ccomments%2Ccategory%2Ctags%2Centries%2Centities%2Csimilarities%2Clatest-collection%2Ccollections%2Coperational-events%2Cportfolios%2Ccatalog-tags&fields[videos]=title%2Cdesc%2Cexcerpt%2Cis-published%2Cthumb%2Capp-cover%2Ccover%2Ccomments-count%2Clikes-count%2Cbookmarks-count%2Cis-verified%2Cpublished-at%2Coption-is-official%2Coption-is-focus-showcase%2Cduration%2Cdraft%2Caudit-draft%2Cuser%2Ccomments%2Ccategory%2Ctags%2Centries%2Centities%2Csimilarities%2Clatest-collection%2Ccollections%2Coperational-events%2Cportfolios%2Ccatalog-tags%2Cmedia%2Cdjs%2Calbums%2Cpublished-albums&fields[radios]=title%2Cdesc%2Cexcerpt%2Cis-published%2Cthumb%2Capp-cover%2Ccover%2Ccomments-count%2Clikes-count%2Cbookmarks-count%2Cis-verified%2Cpublished-at%2Coption-is-official%2Coption-is-focus-showcase%2Cduration%2Cdraft# 1. 两数之和

## 题目

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

## 思路

* 使用哈希表 将每一个元素的值和下标存储在哈希表中
* 遍历数组 对于每一个元素 在哈希表中查找是否存在target - nums[i] 如果存在 返回两个下标

## 代码

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> heap;
        for(int i = 0; i < nums.size(); i++)
        {
            int r = target - nums[i];
            if(heap.count(r))
            {
                return {heap[r],i};
            }
            heap[nums[i]] = i;
        }
        return {};
    }
};
```