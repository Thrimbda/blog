---
"title": "並行処理の再考（アクターモデル）"
"summary": "本記事ではまず、並行プログラミングにおいて、複数のワーカーが非同期でそれぞれ異なる役割を果たす必要がある場合、単一のメッセージキューを共有すると、メッセージの宛先指定ができない、誤ったメッセージを受信する、タイミングの問題が発生するといった課題が生じることを論じています。\
  著者は段階的な分析を通じて、このようなシナリオにおいて共有メッセージキューが非効率であり、潜在的なバグを引き起こす可能性があることを指摘します。\
  続いて、この問題の根本的な解決策としてアクターモデルを紹介します。このモデルでは各ワーカーに独立したメッセージキュー（メールボックス）を割り当て、完全なメッセージの分離と非同期通信を実現します。\
  記事では、アクターモデルの概念（並列実行、メッセージパッシング、アドレス機構など）を詳細に説明し、Pythonのスレッドを用いた実装例として基本的なアクター（BaseWorker）の構築方法を示しています。\
  最後に、著者はアクターモデルが並行プログラミングにもたらす利点をまとめ、その抽象的な思考様式と「高凝集、低結合」という実践的価値を強調しています。"
"tags":
  - "python"
  - "並行処理"
  - "アクターモデル"
  - "メッセージキュー"
  - "非同期プログラミング"
  - "マルチスレッド"
  - "プログラミングモデル"
"date": "2017-05-19"
---

---
title: 並行処理の再考（アクターモデル）
date: 2017年5月19日
taxonomies:
  tags:
    - python
    - 並行処理
---

[前回](http://0xc1.space/2017/05/06/初探并发/)は、スレッド（プロセス）間でメッセージをやり取りするためにメッセージキューを利用する方法について述べました。

<!--more-->

## 共有されるメッセージキュー

これは、**並行処理がシステムのスループット向上だけを目的としているという前提**に基づいています。この仮定では、各ワーカーは同じ仕事を行うため、単一のメッセージキューを共有し、誰が次の命令を受け取っても問題ありません。

### もし私たちが同じ役割を持たないなら

例えば、各ワーカーがそれぞれ異なる役割を果たし、非同期に動作するシステム（例：IP電話）を実装する必要がある場合はどうでしょうか？先ほどの方法、つまりすべてのワーカーが単一のメッセージキューを共有する方法を使うと、問題が発生します：特定のワーカーにメッセージを送ることができません。

この問題をどう解決すればよいでしょうか？単純で直接的な解決策は、各メッセージに宛先を識別するタグを付けることです：

```python
queue = Queue([('Send_to_worker_A', 'do_something1'),
               ('Send_to_worker_B', 'do_something2'),
               ('Send_to_worker_B', 'do_something3'),
               ('Send_to_worker_C', 'do_something4'),
               ('Send_to_worker_A', 'do_something5')])
```

これで問題は解決したように見えますね？しかし、新たな問題を導入してしまいました。

### もし誤って他人への手紙を開封してしまったら

もしworker A宛のメッセージがworker Bに届いてしまった場合、worker Bにとってそのメッセージは何の役にも立ちません。一方、本来そのメッセージを受け取るべきworker Aはそれを受け取れず、メッセージは失われてしまいます。これはworker Bの時間を浪費し、worker Aの時間を無駄にし、さらにはステップの飛び越しによってシステム全体が奇妙なバグに陥る可能性さえあります。

この問題はどう解決すればよいでしょうか？直感的には、各ワーカーに次のような戦略を追加すれば問題は解決するように思えます：他人宛のメッセージを受け取ったら、そのメッセージをメッセージキューに戻す。

```python
class Worker_B:
    
    def run(self):
        while True:
            if not self.queue.empty():
                data = self.queue.get()
                if data['to_whom'] == 'worker_B':
                    do_something_with_data
                else:
                    self.queue.put(data)
```

一見、修正を加えて問題を解決したように見えます...しかし実際には、また新たな問題を導入してしまいました。

### これは行き止まりのように見える

第一に、メッセージキューはキューであり、FIFO（先入れ先出し）を意味します。優先順位付きメッセージキューを導入したとしても、本質的にはこの点は変わりません。このため、本来最初にworker Aに渡されるべきメッセージが、worker Bによって処理された後、現在のメッセージキューの中でworker Aに渡されるのが最も遅いメッセージになってしまい、システムが奇妙なバグに陥る可能性があります。

第二に、誤って配信されたメッセージをメッセージキューの先頭に戻す方法を考えたとしても、誤ったメッセージを受け取ったworker Bの「受信-確認-返却」操作をアトミック操作にするためのロック機構を導入しなければ、worker Bが返却操作を実行している間に、他のワーカーが既にメッセージ受信操作を続行している可能性があり、依然としてタイミングに関する大きな問題を引き起こす可能性があります。ロック機構を導入すれば論理的な誤りは解決できますが、これにより各ポーリングサイクルで実際に仕事ができるワーカーは1つだけになり、誤ったメッセージを受け取って「受信-確認-返却」操作を実行する他のワーカーは自分のタイムスライスを無駄にすることになり、**効率が非常に悪くなります。**

したがって、非同期作業のために並行処理を導入するシステムにおいては、各ワーカーが単一のメッセージキューを共有することは良い方法ではなさそうです。

この問題を根本的に解決する方法は、同じタスクを実行するワーカーのグループごとに専用のメッセージキュー（メールボックス）を設けること、あるいは各ワーカーに独自のメッセージキューを設け、スレッド間でのメモリ共有能力を完全に放棄することです。後者の方法が、今日お話しする主役、**アクターモデル（Actor model、参与者模式）**です。

## アクターモデル

まず、ウィキペディアによるアクターモデルの定義と概念を見てみましょう：

### 概念

コンピュータサイエンスにおいて、アクターモデル（英語: Actor model）は並行計算におけるモデルの一つです。「アクター」はプログラム上の抽象概念であり、並行計算の基本単位と見なされます：アクターがメッセージを受信すると、いくつかの決定を下したり、さらに多くのアクターを作成したり、より多くのメッセージを送信したり、次のメッセージにどのように応答するかを決定したりすることができます。アクターモデルは1973年にCarl Hewitt、Peter Bishop、Richard Steigerの論文で提唱されました。

アクターモデルが提唱する哲学は「すべてがアクターである」というもので、オブジェクト指向プログラミングの「すべてがオブジェクトである」という考えに似ています。しかし、オブジェクト指向プログラミングは通常順次実行されるのに対し、アクターモデルは並列実行されます。アクターは計算実体であり、受信したメッセージに応答すると同時に、並列に以下のことができます：

- 他のアクターに有限数のメッセージを送信する；
- 有限数の新しいアクターを作成する；
- 次のメッセージを受信したときの振る舞いを指定する。

上記の操作には順次実行の前提が含まれていないため、並列に行うことができます。送信者と送信済みメッセージの分離は、アクターモデルの根本的な利点です。これにより、非同期通信が可能になり、メッセージパッシングの制御構造が満たされます。メッセージの受信者はアドレスによって識別され、これは「メールアドレス」とも呼ばれることがあります。したがって、アクターは自分がアドレスを持っているアクターとしか通信できません。アクターは受信した情報からアドレスを取得したり、自分が作成したアクターのアドレスを取得したりすることができます。アクターモデルの特徴は、アクター内部またはアクター間で並列計算が行われ、アクターは動的に作成でき、アドレスはメッセージに含まれ、相互作用は直接的な非同期メッセージ通信によってのみ行われ、メッセージの到着順序に制限がないことです。

### 実装

アクターは十分にシンプルで、並行処理のために生まれ、変化を隔離するのに十分なカプセル化を備えています（例：マルチスレッドかマルチプロセスかを気にしない）。

典型的なアクターのPythonスレッド実装を見てみましょう：

```python
from queue import Queue
from threading import Thread, Event


class WorkerExit(Exception):
    # タスクを終了させるための例外
    pass


class BaseWorker(object):
    # Actor
    def __init__(self):
        self._mailbox = Queue()
        super(BaseWorker, self).__init__()

    def send(self, msg):
        self._mailbox.put(msg)

    def recv(self):
        msg = self._mailbox.get()
        if msg is WorkerExit:
            raise WorkerExit()
        return msg

    def close(self):
        self.send(WorkerExit)

    def start(self):
        self._terminated = Event()
        t = Thread(target=self._bootstrap)

        t.daemon = True
        t.start()

    def _bootstrap(self):
        try:
            self.run()
        except WorkerExit:
            pass
        finally:
            self._terminated.set()

    def join(self):
        self._terminated.wait()

    def run(self):
        raise NotImplementedError
```

簡単に説明すると、このアクター（私はBaseWorkerと名付け、実際のプロジェクトでは親クラスとして使用しています）は、2つのデータ構造を維持します：`Queue`をメールボックスとして、`Event`をメインスレッドをブロックする終了手段として使用します。

ここでの外部インターフェースとしての核心操作は`send()`メソッドだけです。**渡すメッセージの型を制限しない**ことに注意してください。これは非常に大きな柔軟性を意味します。

アクター内部では、1つのスレッドを使用して`run()`メソッドを実行し、`recv()`メソッドと組み合わせて指定された具体的な仕事を行います。特筆すべきは、タスクを停止させるための番兵信号`WorkerExit`を設定している点です。`WorkerExit`の動作原理は、認識されると例外として送出され、例外処理の部分でさらに多くのことを行うことも可能ですが、ここではこの例外をキャッチしたときにスレッドの実行を停止するだけです。この例外処理の実装は、`run()`メソッドをラップする`_bootstrap()`メソッドに依存しています。

アクターモデルの哲学の下で、このシンプルな例を拡張し、さらに先へ進むことができます。

## まとめ

並行プログラミングには、通常よりもさらに抽象的な思考様式が必要であり、「高凝集、低結合」という思想の良い実践にもなります。

私にとってこの全く新しい領域での探求において、アクターは確かに道を照らす明かりであり、私を本当の意味で入門させてくれました。ですから、ここで共有させていただきます。 :)