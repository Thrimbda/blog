---
"title": "Análisis de la Fuerza del Patrón Observador"
"summary": "Este artículo presenta primero los conceptos básicos del patrón Observador (también conocido como patrón Publicar-Suscribir), su definición según GoF y sus aplicaciones en el mundo real (como las suscripciones RSS). Explica en detalle los participantes del patrón Observador (Sujeto, Observador, SujetoConcreto, ObservadorConcreto) y los escenarios de aplicación (cuando existe una relación de dependencia entre objetos, cuando un cambio en un objeto requiere cambiar otros simultáneamente). Luego, tomando como ejemplo Action y ActionListener en J2EE, el artículo muestra, a través de un ejemplo concreto de código Java Swing, cómo el patrón Observador se aplica en el paradigma MVC para reducir el acoplamiento entre el modelo y la vista. El artículo señala que, en comparación con las llamadas a funciones ordinarias y las funciones de retorno de llamada (callbacks), el patrón Observador puede mantener la consistencia entre objetos a bajo costo, lograr un efecto de difusión (broadcast) y mejorar significativamente la reutilización del código."
"tags":
  - "Patrones de Diseño"
  - "Análisis y Diseño de Sistemas"
  - "Patrón Observador"
  - "J2EE"
  - "ActionListener"
  - "MVC"
  - "Java"
  - "Acoplamiento"
"date": "2017-04-10"
---

---
title: Análisis de la Fuerza del Patrón Observador
date: 2017-04-10
taxonomies:
  tags:
    - Patrones de Diseño
    - Análisis y Diseño de Sistemas
---

> En general, en el análisis y diseño orientado a objetos existen tres mecanismos para el manejo de eventos: además de las llamadas a funciones ordinarias, a menudo se utilizan funciones de retorno de llamada (callbacks), y J2EE proporciona un mecanismo de manejo de eventos basado en escuchas (listeners). Consulta la documentación, analiza el mecanismo de Action y ActionListener, y completa un ejemplo de análisis.

Primero, comprendamos el patrón Observador.

<!--more-->

## Patrón Observador (Observer Pattern)

### El Observador en el Mundo Real

El patrón Observador también se conoce como patrón Publicar-Suscribir. Por ejemplo, en las suscripciones RSS (el precursor de las notificaciones push de WeChat), cuando el autor de un blog (el sujeto observado) actualiza una entrada, el lector (el observador) de los suscriptores recibe automáticamente la actualización. Este esquema de publicar-suscribir lo llamamos patrón Observador.

### El Patrón Observador

La descripción del patrón Observador por el **G**rupo de **C**uatro (**G**ang **O**f **F**our):

> - **Intención**
>
>   Definir una relación de dependencia uno-a-muchos entre objetos, de modo que cuando un objeto cambie de estado, todos los objetos que dependen de él sean notificados y actualizados automáticamente.
>
> - **Alias**
>
>   Dependientes (Dependents), Publicar-Suscribir (Publish-Subscribe)
>
> - **Motivación**
>
>   Un efecto secundario común de dividir un sistema en una serie de clases que cooperan es la necesidad de mantener la consistencia entre los objetos relacionados. No queremos que las clases estén fuertemente acopladas para mantener la consistencia, ya que esto reduce su reutilización.
>
>   ...
>
> - **Participantes**
>
>   - **Sujeto (Subject)**
>
>     El sujeto conoce a sus observadores. Puede haber cualquier número de observadores observando el mismo sujeto.
>
>     Proporciona una interfaz para registrar y eliminar objetos observadores.
>
>   - **Observador (Observer)**
>
>     Define una interfaz de actualización para los objetos que deben ser notificados cuando el sujeto cambia.
>
>   - **SujetoConcreto (ConcreteSubject)**
>
>     Almacena el estado de interés para los objetos ObservadorConcreto.
>
>     Cuando su estado cambia, notifica a sus observadores.
>
>   - **ObservadorConcreto (ConcreteObserver)**
>
>     Mantiene una referencia a un objeto SujetoConcreto.
>
>     Almacena un estado que debe ser consistente con el estado del sujeto.
>
>     Implementa la interfaz de actualización de Observer para mantener su estado consistente con el estado del sujeto.

Se puede observar que el patrón Observador se aplica a menudo en:

- Dos objetos tienen una relación de dependencia.
- Cuando un objeto cambia, es necesario cambiar otros objetos simultáneamente.

En comparación con las llamadas a funciones ordinarias y las funciones de retorno de llamada (callbacks), el uso del patrón Observador permite mantener la consistencia entre objetos a bajo costo, **reduce significativamente el grado de acoplamiento entre objetos y, al mismo tiempo, puede lograr un efecto de difusión (broadcast), algo que los dos primeros no pueden hacer. El uso del patrón Observador **mejora enormemente la reutilización del código**.

**Y Action y ActionListener en J2EE son un ejemplo vivo del patrón Observador.**

## Action y ActionListener en J2EE

Action y ActionListener se pueden aplicar muy bien en el paradigma MVC para reducir el acoplamiento entre el modelo (model) y la vista (view).

Encontré un buen [ejemplo](http://www.ulisespulido.com/2009/03/observer-design-pattern-and-java-swing.html), cuyo código se muestra a continuación:

```java
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JTextField;

public class Frame extends JFrame {

  ActionListener observer1 = new Observer("First Observer");
  ActionListener observer2 = new Observer("Second Observer");
  ActionListener observer3 = new Observer("Third Observer");

  public Frame(){
    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    init();
  }

  private void init(){
    addChangingTextField();
    pack();
    setVisible(true);
  }

  private void addChangingTextField(){
    //Clase observable TextField. Cada vez que
    //ocurre una acción o evento, los observadores serán actualizados
    //Casi todas las clases Swing tienen este tipo de comportamiento
    JTextField dataTextField = new JTextField();

    // Registro del observador en la clase observable.
    dataTextField.addActionListener(observer1);
    dataTextField.addActionListener(observer2);
    dataTextField.addActionListener(observer3);

    add(dataTextField);
  }

  public static void main(String [] args){
  	Frame frame = new Frame();
  }
}

class Observer implements ActionListener{

  private String name;
  private String message;

  public Observer (String s){
  	name = s;
  }

  public void actionPerformed(ActionEvent e) {
    JTextField textField = (JTextField) e.getSource();
    message = textField.getText();
    JOptionPane.showMessageDialog(null,
    name + " has been confirmed about the change, Thanks!! "
    + " The Message was: " + message);
  }
}
```

### Análisis

Las dos clases asumen los roles de Action/ActionListener respectivamente. `frame.dataTextField` en el método `addChangingTextField` vincula tres escuchas (`observer1`, `observer2`, `observer3`). Después de que se edita el campo de texto en el frame (cambio de estado), se activa el método `actionPerformed` en Observer, mostrando el texto correspondiente.

En este ejemplo, `frame.dataTextField` actúa como `SujetoConcreto` (ConcreteSubject), y `observer1`, `observer2`, `observer3` actúan como `ObservadoresConcretos` (ConcreteObservers). Las interfaces que implementan, que definen los métodos Action/ActionListener, son los `Sujeto` (Subject) y `Observador` (Observer) correspondientes.

Después de vincular los observadores, el sujeto no se preocupa por el comportamiento específico de los observadores, sino que simplemente los notifica cuando cambia su propio estado, dejando que los observadores decidan qué acción tomar. Por lo tanto, este método es muy bueno, supera con creces a activar acciones mediante llamadas explícitas a funciones o ejecución de funciones de retorno de llamada, y merece la pena estudiarlo.