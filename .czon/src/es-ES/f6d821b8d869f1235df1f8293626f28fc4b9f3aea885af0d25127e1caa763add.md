---
"title": "Explorando la Concurrencia (Actor) - Segunda Parte"
"summary": "Este artículo profundiza en las limitaciones de las colas de mensajes compartidas en programación concurrente, señalando que en sistemas donde cada worker debe funcionar de forma asíncrona, las colas compartidas causan problemas como incapacidad de enviar mensajes dirigidos, desorden en la secuencia temporal y baja eficiencia. El autor analiza progresivamente soluciones como identificadores y mecanismos de reenvío, destacando sus defectos, para finalmente proponer el modelo Actor como solución definitiva. Se explica en detalle el concepto del modelo Actor, incluyendo sus características clave como ejecución paralela, desacoplamiento de mensajes y comunicación por direcciones, junto con un ejemplo de implementación en Python con hilos. La conclusión enfatiza que la programación concurrente requiere pensamiento abstracto, y el modelo Actor sirve como guía efectiva para iniciarse en este campo."
"tags":
  - "python"
  - "concurrencia"
  - "modelo Actor"
  - "colas de mensajes"
  - "programación asíncrona"
  - "comunicación entre hilos"
"date": "2017-05-19"
---

---
title: Explorando la Concurrencia (Actor) - Segunda Parte
date: 2017-05-19
taxonomies:
  tags:
    - python
    - concurrencia
---

[En la entrega anterior](http://0xc1.space/2017/05/06/初探并发/) hablamos sobre el uso de colas de mensajes para pasar mensajes entre hilos (o procesos) y así lograr comunicación entre ellos.

<!--more-->

## La cola de mensajes compartida

Esto se basa en la premisa de que **la concurrencia solo sirve para mejorar la tasa de procesamiento del sistema**. Bajo esta suposición, cada worker realiza el mismo trabajo, por lo que pueden compartir una cola de mensajes; no importa quién tome la siguiente instrucción.

### ¿Y si no somos iguales?

¿Qué pasa si necesitamos implementar un sistema donde cada worker tiene una función específica y trabaja de forma asíncrona (por ejemplo, nuestro IP-phone)? Supongamos que seguimos usando el método anterior, donde todos los workers comparten una cola de mensajes. En este caso surgiría un problema: los mensajes no se pueden enviar a un worker específico.

¿Cómo resolver esto? Una solución simple y directa es agregar un identificador a cada mensaje, indicando a quién va dirigido:

```python
queue = Queue([('Send_to_worker_A', 'do_something1'),
               ('Send_to_worker_B', 'do_something2'),
               ('Send_to_worker_B', 'do_something3'),
               ('Send_to_worker_C', 'do_something4'),
               ('Send_to_worker_A', 'do_something5')])
```

Parece que el problema se resuelve fácilmente, ¿verdad? Pero hemos introducido un nuevo problema.

### ¿Y si accidentalmente abro una carta destinada a otro?

Si un mensaje destinado al worker A es recibido por el worker B, este mensaje no le sirve de nada, mientras que el worker A, que debería haberlo recibido, no lo obtiene. Así, el mensaje se pierde. Se desperdicia el tiempo del worker B, se consume el tiempo del worker A, e incluso podría provocar que todo el sistema caiga en algún error extraño debido a un salto inesperado.

¿Cómo solucionamos este problema? Intuitivamente, agregar la siguiente estrategia a cada worker parece resolverlo: si recibe un mensaje destinado a otro, lo vuelve a poner en la cola.

```python
class Worker_B:
    
    def run(self):
        while True:
            if not self.queue.empty():
                data = self.queue.get()
                if data['to_whom'] == 'worker_B':
                    do_something_with_data
                else:
                    self.queue.put(data)
```

Parece que con parches hemos solucionado el problema... pero en realidad hemos introducido otro nuevo.

### Esto parece un callejón sin salida

Primero, una cola de mensajes es una cola, lo que implica FIFO (primero en entrar, primero en salir). Incluso si introducimos colas de mensajes con prioridad, esto no cambia en esencia. Así, un mensaje que debería entregarse primero al worker A, después de ser manipulado por el worker B, se convierte en el último en entregarse al worker A en la cola actual, lo que podría llevar al sistema a un error extraño.

Segundo, incluso si logramos que los mensajes mal dirigidos se reinserten al principio de la cola, si no introducimos un mecanismo de bloqueo para que la operación `recibir-verificar-devolver` del worker B que recibió el mensaje incorrecto sea una operación atómica, entonces, mientras el worker B realiza la operación de devolución, otros workers podrían estar continuando con la recepción de mensajes, lo que aún podría causar grandes problemas de secuencia temporal. Introducir un mecanismo de bloqueo puede resolver los errores lógicos, pero haría que en cada sondeo solo un worker pueda trabajar realmente, mientras que otros workers que reciben mensajes incorrectos y ejecutan la operación `recibir-verificar-devolver` desperdician su tiempo de CPU en vano, **reduciendo la eficiencia**.

Por lo tanto, parece que para sistemas que introducen concurrencia para trabajar de forma asíncrona, que cada worker comparta la misma cola de mensajes no es una buena solución.

La forma radical de resolver este problema es crear una cola de mensajes (buzón) específica para cada grupo de workers que realizan la misma tarea, o incluso asignar una cola de mensajes propia a cada worker, renunciando completamente a la capacidad de memoria compartida entre hilos. Este último método es el protagonista de hoy: **el modelo Actor (modelo de actores)**.

## Modelo Actor

Primero, veamos la definición y conceptos del modelo Actor según Wikipedia:

### Concepto

En ciencias de la computación, el modelo de actores (en inglés: Actor model) es un modelo de computación concurrente. Un "actor" es un concepto abstracto en programación, considerado la unidad básica de computación concurrente: cuando un actor recibe un mensaje, puede tomar decisiones, crear más actores, enviar más mensajes y decidir cómo responder a los próximos mensajes. El modelo de actores fue propuesto en 1973 en un artículo de Carl Hewitt, Peter Bishop y Richard Steiger.

La filosofía que promueve el modelo de actores es "todo es un actor", similar a la programación orientada a objetos donde "todo es un objeto", pero la programación orientada a objetos suele ser secuencial, mientras que el modelo de actores es paralelo. Un actor es una entidad computacional que responde a los mensajes recibidos y, en paralelo:

- Envía un número limitado de mensajes a otros actores;
- Crea un número limitado de nuevos actores;
- Especifica el comportamiento al recibir el siguiente mensaje.

Las operaciones anteriores no asumen ejecución secuencial, por lo que pueden realizarse en paralelo. La desvinculación entre el emisor y los mensajes ya enviados es la ventaja fundamental del modelo de actores. Esto permite comunicación asíncrona y satisface las estructuras de control de paso de mensajes. Los receptores de mensajes se distinguen por direcciones, a veces llamadas "direcciones de correo". Por lo tanto, un actor solo puede comunicarse con actores cuyas direcciones posee. Puede obtener direcciones a través de la información recibida o de las direcciones de los actores que crea. Las características del modelo de actores son: computación paralela dentro o entre actores, los actores pueden crearse dinámicamente, las direcciones de los actores se incluyen en los mensajes, la interacción solo se realiza mediante comunicación asíncrona directa de mensajes, y no se restringe el orden de llegada de los mensajes.

### Implementación

Los actores son lo suficientemente simples, nacidos para la concurrencia, y tienen una encapsulación lo suficientemente buena para aislar cambios (por ejemplo, sin importar si son multihilo o multiproceso).

Veamos una implementación típica de un Actor en Python con hilos:

```python
from queue import Queue
from threading import Thread, Event


class WorkerExit(Exception):
    # Excepción para finalizar tareas
    pass


class BaseWorker(object):
    # Actor
    def __init__(self):
        self._mailbox = Queue()
        super(BaseWorker, self).__init__()

    def send(self, msg):
        self._mailbox.put(msg)

    def recv(self):
        msg = self._mailbox.get()
        if msg is WorkerExit:
            raise WorkerExit()
        return msg

    def close(self):
        self.send(WorkerExit)

    def start(self):
        self._terminated = Event()
        t = Thread(target=self._bootstrap)

        t.daemon = True
        t.start()

    def _bootstrap(self):
        try:
            self.run()
        except WorkerExit:
            pass
        finally:
            self._terminated.set()

    def join(self):
        self._terminated.wait()

    def run(self):
        raise NotImplementedError
```

En pocas palabras, este Actor (lo llamé BaseWorker, y en proyectos reales se usa como clase base) mantiene dos estructuras de datos: un `Queue` como buzón y un `Event` como mecanismo para bloquear el hilo principal.

Aquí, la operación central que sirve como interfaz externa es solo el método `send()`. Nótese que **no restringimos el tipo de mensaje que se puede pasar**, lo que ofrece una flexibilidad enorme.

Dentro del Actor, usamos un hilo para ejecutar el método `run()` combinado con `recv()` para realizar el trabajo específico asignado. Vale la pena mencionar que establecemos una señal centinela `WorkerExit` para detener tareas. Nótese que `WorkerExit` funciona lanzando una excepción cuando se identifica, y en el manejo de excepciones podríamos hacer incluso más cosas, aunque aquí solo detenemos la ejecución del hilo al capturar esta excepción. Esta implementación del manejo de excepciones depende de `_bootstrap()`, que envuelve el método `run()`.

Bajo la filosofía del modelo Actor, podemos extender este ejemplo simple para ir más allá.

## Conclusión

La programación concurrente requiere una forma de pensamiento más abstracta de lo habitual, y también puede ser una buena práctica del principio "alta cohesión, bajo acoplamiento".

En mi exploración de este campo completamente nuevo para mí, el modelo Actor ha sido ciertamente una luz guía, llevándome realmente a adentrarme en él, por eso lo comparto aquí. :)