---
"title": "Praktische Analyse des Beobachter-Musters"
"summary": "Dieser Artikel führt zunächst die Grundkonzepte des Beobachter-Musters (auch bekannt als Publish-Subscribe-Muster), die GoF-Definition und seine Anwendungen in der realen Welt (z.B. RSS-Abonnements) ein. Der Artikel erläutert detailliert die Beteiligten des Beobachter-Musters (Subject, Observer, ConcreteSubject, ConcreteObserver) und geeignete Anwendungsszenarien (wenn Abhängigkeiten zwischen Objekten bestehen, eine Änderung eines Objekts gleichzeitige Änderungen anderer Objekte erfordert). Anschließend zeigt der Artikel am Beispiel von Action und ActionListener in J2EE anhand eines konkreten Java-Swing-Codebeispiels, wie das Beobachter-Muster im MVC-Paradigma angewendet werden kann, um die Kopplung zwischen Model und View zu reduzieren. Der Artikel weist darauf hin, dass das Beobachter-Muster im Vergleich zu normalen Funktionsaufrufen und Callback-Funktionen die Konsistenz zwischen Objekten mit geringen Kosten aufrechterhalten, einen Broadcast-Effekt erzielen und die Wiederverwendbarkeit des Codes erheblich verbessern kann."
"tags":
  - "Entwurfsmuster"
  - "Systemanalyse und -design"
  - "Beobachter-Muster"
  - "J2EE"
  - "ActionListener"
  - "MVC"
  - "Java"
  - "Kopplung"
"date": "2017-04-10"
---

---
title: Praktische Analyse des Beobachter-Musters
date: 2017-04-10
taxonomies:
  tags:
    - Entwurfsmuster
    - Systemanalyse und -design
---

> Im Allgemeinen gibt es in der objektorientierten Analyse und Design drei Mechanismen zur Ereignisbehandlung: Neben normalen Funktionsaufrufen werden häufig Callback-Funktionen verwendet, und J2EE bietet außerdem einen ereignisbasierten Behandlungsmechanismus auf Basis von Listenern. Bitte recherchieren Sie und analysieren Sie den Mechanismus von Action und ActionListener, und erstellen Sie ein Analysebeispiel.

Zunächst das Beobachter-Muster verstehen

<!--more-->

## Das Beobachter-Muster (Observer Pattern)

### Beobachter in der realen Welt

Das Beobachter-Muster wird auch als Publish-Subscribe-Muster bezeichnet, zum Beispiel RSS-Abonnements (der Vorläufer von WeChat-Push). Wenn der Autor eines Blogs (das beobachtete Subjekt) einen Blogbeitrag aktualisiert, erhalten die Abonnenten automatisch die Aktualisierung in ihrem Reader (dem Beobachter). Dieses Veröffentlichungs-Abonnement-Schema nennen wir das Beobachter-Muster.

### Das Beobachter-Muster

Die Beschreibung des Beobachter-Musters durch die **G**ang **O**f **F**our (GoF):

> - Absicht
>
>   Definiere eine Eins-zu-viele-Abhängigkeit zwischen Objekten, sodass, wenn sich der Zustand eines Objekts ändert, alle von ihm abhängigen Objekte benachrichtigt und automatisch aktualisiert werden.
>
> - Alias
>
>   Abhängige (Dependents), Veröffentlichen-Abonnieren (Publish-Subscribe)
>
> - Motivation
>
>   Ein häufiger Nebeneffekt der Aufteilung eines Systems in eine Reihe zusammenarbeitender Klassen ist die Notwendigkeit, die Konsistenz zwischen den zusammengehörigen Objekten aufrechtzuerhalten. Wir möchten nicht, dass die Klassen eng gekoppelt sind, um die Konsistenz zu wahren, da dies ihre Wiederverwendbarkeit verringert.
>
>   ...
>
> - Beteiligte
>
>   - Subjekt (Ziel)
>
>     Das Subjekt kennt seine Beobachter. Es kann beliebig viele Beobachter geben, die dasselbe Subjekt beobachten.
>
>     Bietet Schnittstellen zum Registrieren und Entfernen von Beobachterobjekten.
>
>   - Beobachter (Observer)
>
>     Definiert eine Aktualisierungsschnittstelle für Objekte, die benachrichtigt werden müssen, wenn sich das Subjekt ändert.
>
>   - Konkretes Subjekt (ConcreteSubject)
>
>     Speichert den relevanten Zustand in den jeweiligen ConcreteObserver-Objekten.
>
>     Sendet eine Benachrichtigung an alle seine Beobachter, wenn sich sein Zustand ändert.
>
>   - Konkreter Beobachter (ConcreteObserver)
>
>     Verwaltet einen Verweis auf ein ConcreteSubject-Objekt.
>
>     Speichert einen relevanten Zustand, der mit dem Zustand des Subjekts konsistent sein sollte.
>
>     Implementiert die Aktualisierungsschnittstelle des Observers, um seinen eigenen Zustand mit dem des Subjekts konsistent zu halten.

Man kann sehen, dass das Beobachter-Muster häufig angewendet wird bei:

- Zwei Objekten, die eine Abhängigkeitsbeziehung haben.
- Einem Objekt, dessen Änderung gleichzeitige Änderungen anderer Objekte erfordert.

Im Vergleich zu normalen Funktionsaufrufen und Callback-Funktionen ermöglicht die Verwendung des Beobachter-Musters, die Konsistenz zwischen Objekten mit geringen Kosten aufrechtzuerhalten, den **Grad der Kopplung zwischen Objekten erheblich zu reduzieren und gleichzeitig einen Broadcast-Effekt zu erzielen, was die ersten beiden nicht können. Die Verwendung des Beobachter-Musters verbessert die Wiederverwendbarkeit des Codes erheblich**.

**Und Action und ActionListener in J2EE sind ein lebendiges Beispiel für das Beobachter-Muster.**

## Action & ActionListener in J2EE

Action & ActionListener können gut im MVC-Paradigma angewendet werden, um die Kopplung zwischen Model und View zu reduzieren.

Ein gutes [Beispiel](http://www.ulisespulido.com/2009/03/observer-design-pattern-and-java-swing.html) wurde gefunden, der Code ist wie folgt:

```java
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JTextField;

public class Frame extends JFrame {

  ActionListener observer1 = new Observer("First Observer");
  ActionListener observer2 = new Observer("Second Observer");
  ActionListener observer3 = new Observer("Third Observer");

  public Frame(){
    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    init();
  }

  private void init(){
    addChangingTextField();
    pack();
    setVisible(true);
  }

  private void addChangingTextField(){
    //Observable class TextField. each time
    //An action or event occurs the observers will be updated
    //Almost all the Swing classes has this kind of behavior
    JTextField dataTextField = new JTextField();

    // Observer registering to the observable class.
    dataTextField.addActionListener(observer1);
    dataTextField.addActionListener(observer2);
    dataTextField.addActionListener(observer3);

    add(dataTextField);
  }

  public static void main(String [] args){
  	Frame frame = new Frame();
  }
}

class Observer implements ActionListener{

  private String name;
  private String message;

  public Observer (String s){
  	name = s;
  }

  public void actionPerformed(ActionEvent e) {
    JTextField textField = (JTextField) e.getSource();
    message = textField.getText();
    JOptionPane.showMessageDialog(null,
    name + " has been confirmed about the change, Thanks!! "
    + " The Message was: " + message);
  }
}
```

### Analyse

Die beiden Klassen übernehmen jeweils die Rolle von Action/ActionListener. `frame.dataTextField` bindet in der Methode `addChangingTextField` drei Listener (`observer1`, `observer2`, `observer3`). Nachdem der Text im Frame-Fenster bearbeitet wurde (Zustandsänderung), wird die Methode `actionPerformed` in `Observer` ausgelöst, die den entsprechenden Text anzeigt.

In diesem Beispiel fungiert `frame.dataTextField` als `ConcreteSubject`, und `observer1`, `observer2`, `observer3` fungieren als `ConcreteObserver`. Die Schnittstellen, die sie implementieren und die Action/ActionListener-Methoden definieren, sind die entsprechenden `Subject` und `Observer`.

Nach der Bindung der Beobachter kümmert sich das Subjekt nicht um das konkrete Verhalten der Beobachter, sondern benachrichtigt sie nur, wenn sich sein eigener Zustand ändert. Die Beobachter entscheiden selbst, welche Aktion sie ausführen. Daher ist diese Methode sehr elegant und deutlich überlegen gegenüber dem expliziten Aufruf von Funktionen oder der Ausführung von Callback-Funktionen, um Aktionen auszulösen. Es lohnt sich, dies zu lernen.