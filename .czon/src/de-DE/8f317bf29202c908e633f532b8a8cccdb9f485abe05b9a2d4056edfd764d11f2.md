---
"title": "Arbeitsprotokoll Mai 2020"
"summary": "Dies ist das Arbeitsprotokoll für Mai 2020, das die täglichen Arbeiten in den Bereichen technische Entwicklung, Problemlösung und Projektplanung detailliert dokumentiert. Die Hauptinhalte umfassen: Behebung eines Speicherlecks, dessen Ursache nicht gelöschte verwaiste Zeiger waren, gelöst durch Refactoring des NaviEventProvider; Behandlung von Ausnahmen bei geometrischen Berechnungen aufgrund doppelter Punkte in PolyLine; Behebung mehrerer HDMAPMDK-bezogener Bugs, z.B. Fehler durch unangemessene Segmentierung der Produktionslinie; Refactoring des OSM Assembler; Planung des aktuellen Stands und der Anforderungen der CI-Pipeline; sowie Bearbeitung von Ad-hoc-Aufgaben wie falscher Parkplatzbindung. Das Protokoll reflektiert auch Gedanken zur Zeitschätzung, Problemlösungsmustern (kurz- vs. langfristige Lösungen) sowie Erfahrungen mit Interviews und Teamarbeit."
"tags":
  - "Arbeitsprotokoll"
  - "Technik"
  - "Bugfix"
  - "Speicherleck"
  - "Refactoring"
  - "CI"
  - "Interview"
  - "Projektmanagement"
"date": "2020-05-01"
---

### 2020-05-06
#### Du Valid
- Verwendung von mill
- Verwendung von nexus-osm

#### Brainstorming

### 2020-05-08
#### Speicherleck-Problem
- Die direkte Ursache für das Speicherleck war, dass nach dem `new` eines verwaisten Zeigers kein `delete` erfolgte.
- Nach dem `update current position` rief das Map Kit `prepareGuidanceData` auf, um die nächstgelegenen Guidance-Daten zur aktuellen Position zu finden.
- `prepareGuidanceData` rief `NavInfoProviderImpl::getTrafficLights` & `NavInfoProviderImpl::getCarParks` auf.
- Am Beispiel von `NavInfoProviderImpl::getTrafficLights`: Beim Aufruf wurden Datenzeiger in `NaviEventOnPath` mit `new` erzeugt.
- Diese wurden jedoch nie gelöscht (`delete`).
- Es wurde festgestellt, dass `DestEvent` das gleiche Problem hat.

Lösung: Der Kern liegt darin, keine verwaisten Zeiger zuzulassen. Es wurde entschieden, den `NaviEventProvider` zu refaktorisieren.
- Zuerst werden zwei Felder `traffic_light_events_` & `car_park_events_` in `NaviInfoProvider` hinzugefügt.
- In `NaviInfoGenerator` werden diese Felder aktualisiert, nachdem die Route geupdated wurde.
- Bei jedem `get`-Aufruf wird dann basierend auf der aktuellen Fahrzeugposition gefiltert.
- Daher muss `PathReader::getAttributes` refaktorisiert werden, da die vorherige Implementierung nur den Offset relativ zum aktuellen Fahrzeug berücksichtigte. Jetzt wird eine Schnittstelle für den Offset relativ zum Pfad benötigt.

### 2020-05-09
#### PolyLine-Reparatur und Tests
Das Hauptproblem bei PolyLine bestand darin, dass bei der Erstellung doppelte Punkte eingefügt werden konnten, was zu einer Reihe von Problemen bei geometrischen Segmentberechnungen führte:
1. Vektorberechnung: Zwei doppelte Punkte ergeben einen Nullvektor.
2. Längenberechnung: Segmentlänge ist 0, was leicht zu NaN-Problemen führt.

Daher wurde beim Konstruieren der PolyLine eine Prüfung der Punkte eingeführt. Wenn doppelte Punkte gefunden werden, wird eine Ausnahme ausgelöst.

Folgende Probleme wurden dabei entdeckt:
- In Jts trat ein Problem bei `getEnd` auf.
- In Jts `LinearLocation` gibt es ein `normalize`-Problem.
  ```scala
  val loc1 = new LinearLocation(0, 1, 1.0)
  val loc2 = new LinearLocation(0, 2, 0.0)
  
  loc1 compareTo loc2
  // die Ausgabe ist -1
  ```
- Beim Interpolieren könnten zwei Punkte genommen werden, die zu nahe beieinander liegen.

### 2020-05-11
- HDMAPMDK-1122
  Das Problem der fehlenden Straßenrandlinien konnte nicht reproduziert werden. Es wurde entschieden, keine weitere Zeit für die Untersuchung der Ursache aufzuwenden.
- Eine halbe Stunde über "Metabolic Growth Theory".
- Refactoring des Visitors, damit er Linien mit gleichem Start- und Endpunkt unterstützt.
- Eine Interviewfrage vorbereitet.

### 2020-05-12
- Interview: Beide Kandidaten waren ungeeignet. Nachgedacht darüber, wie man Kandidaten schnell identifizieren kann. Dauer: 3 Stunden.
- Bugfix: HDMAPMDK-1211 Problem mit dem Löschen falscher Borders, wurde beim letzten Fix nicht erfolgreich behoben.
  Habe eine Idee, aber noch nicht fertig geschrieben.
- War im Fitnessstudio.

### 2020-05-13
Bugfix: HDMAPMDK-1211 Lösungsidee gefunden.
- Grundursache war eine unangemessene Segmentierung der Produktionslinie.

#### Ursachenanalyse
Es ist zu sehen, dass die Segmentierung erfolgte, bevor der Spurwechsel abgeschlossen war (die Fahrstreifenmittellinie überquerte noch die Fahrstreifenlinie), und diese Segmentierung möglicherweise Rp-Grenzen überschritt.

Da die an den Shape-Punkten der `lanecenter` anhaftenden `lane border`-Beobachtungsinformationen die geometrischen Gegebenheiten getreu widerspiegeln und mithilfe eines Scanline-Verfahrens die Fahrstreifenlinien auf beiden Seiten aufgezeichnet werden, ohne semantische Filterung, wird eine Fahrstreifenlinie, die an einer Stelle die Fahrstreifenmittellinie kreuzt, an der ein Spurwechsel stattfindet, sowohl im linken als auch im rechten `lane border ref` vermerkt.

In der bestehenden Logik schlägt die semantische Filterung der `border refs` für kreuzende Fahrstreifenlinien bei solchen Segmentierungen fehl, was zu diesem Problem führt.

#### Lösung
Der Kernpunkt liegt darin, **den Spurwechseltrend der kreuzenden Fahrstreifenlinie zu ermitteln**. Da diese Segmentierung Rp-Grenzen überschreiten kann, sollte die Filterung nicht pro Rp-Einheit erfolgen.

1. Zuerst werden die Fahrstreifenlinien mithilfe von `edge lifting` zu einem Pfad organisiert (kann für zukünftige Graph-Refaktorisierung in Betracht gezogen werden): `Seq[LaneCenter]`
2. Finde den zu korrigierenden `LaneCenter` sowie den zu korrigierenden `lane border` (hier wird angenommen, dass dieser `LaneCenter` definitiv durch einen Spurwechsel verursacht wurde).
3. Berechne den Spurwechseltrend dieses `LaneCenter` basierend auf dem `LaneCenter`-Pfad.
4. Filterung durchführen.

Wurde Ziliang zur Bearbeitung übergeben.

Ein Interviewkandidat war nicht bestanden.

### 2020-05-14
HDMAPMDK-1132 ID-Tracing für Pfähle Fahrstreifenlinien-Endpunkte

Das Tracing-Problem für Pfähle Fahrstreifenlinien-Endpunkte ist im Vergleich zum Tracing linearer Objekte sehr einfach, da es nur eine ID-Zuordnung gibt, aber keine Offset- und Längenzuordnung.

Dennoch sind einige Punkte zu beachten:
1. Prozedur
2. Das ID-Typisierungssystem ist ein hartnäckiges Problem, das angegangen werden muss.

Im Wesentlichen liegt die Wurzel des Problems darin, dass wir bei der Definition von IDs durchgängig Long-IDs verwendet haben, während die MDM-Definition Int verwendet, was leicht zu Überlaufproblemen führen kann.

### 2020-05-15
#### Bugfixes
- HDMAPMDK-1215 abgeschlossen.
- HDMAPMDK-1218 erledigt.

### 2020-05-18
Refactoring des OSM Assembler durchgeführt, wobei die vorherige OSM-Serialisierung verwendet wurde. Die Verständlichkeit und die Leichtigkeit der Code-Erstellung haben sich verbessert.

### 2020-05-19
Einen Bug im OSM Assembler behoben (eigentlich kein richtiger Bug).

Heute Sprint-Planning-Meeting:
In diesem Sprint gibt es nicht viel zu tun, aber viel zu überlegen. Das ist ein gesunder Zustand.

### 2020-05-20
- [ ] Dokumentation schreiben, die den aktuellen Status der nexus/mdk CI sowie die Anforderungen beschreibt.
- [x] HDMAPMDK-1263 Bug verfolgen
  - Es handelt sich tatsächlich um ein Problem mit der Produktionslinien-Segmentierung.
- [ ] Meeting mit Yang Chuan zur Diskussion der CI vereinbaren.
- [ ] HDMAPMDK-1262
  Nicht fertig geworden.
- [x] Problem mit Custom Speed Limit.

### 2020-05-21
#### TODOs
- [x] Qiaobo grüßen.
- [x] HDMAPMDK-1262
- [x] HDMAPMDK-755

#### Arbeiten
- Morgens im Yiming-Arbeitsbereich online den Hotfix von gestern debuggt. Das Problem lag an einem Offset. Gestern zu hastig geschrieben und überhaupt keine Tests hinzugefügt. Solches Verhalten sollte nicht mehr vorkommen. Dachte, ich hätte viel Zeit gespart, **aber habe letztendlich mehr Zeit verschwendet**.
- Der Grund, warum bei 1262 keine Daten abgerufen werden konnten, war, dass das MDK keine lane-level `road marks` (und `road obstacles`) geladen hat.
- Für Bruder Du Daten kompiliert.

### 2020-05-22
Was habe ich heute gemacht???
Was habe ich eigentlich gemacht???

### 2020-05-25
Heute eine neue Aufgabe erhalten: HDMAPMDK-1249 - Untersuchung der Methode zur Berechnung der Lane Aggregation unter Verwendung von Straßengeometrieinformationen. Dadurch sind die Aufgaben für diese Woche etwas mehr geworden. Bisher habe ich noch drei Dinge zu erledigen:

1. 1249
2. Aktueller Stand, Anforderungen und Lösung für die CI-Pipeline im Team.
3. Nexus-Graph-Refaktorisierung.

Jede dieser Aufgaben erfordert sorgfältige Überlegungen und ist nicht einfach. Leider kann ich für keine dieser Aufgaben die Zeit genau abschätzen. Es sind nur die von Weiyu geschätzten und in den Jira-Aufgaben als Story Points eingetragenen Schätzungen vorhanden. Eines ist mir klar: **Wenn ich nicht anfange, selbst zu schätzen und zu reflektieren, werde ich es nie genau schätzen können**. Also werde ich von jetzt an genau schätzen.

Außerdem plane ich, heute mit 1249 anzufangen, da es sich um eine geschäftliche Angelegenheit handelt, die in der Regel dringender ist und Weiyu mehr daran liegt. Was die Refaktorisierung betrifft, wenn ich mich nicht selbst darum kümmere, wird sich wahrscheinlich auch niemand sonst darum kümmern (weil es hart ist: Es beeinflusst nicht die Funktionalität, aber die Effizienz, und Effizienz ist am schwierigsten zu messen, selbst ich habe nur qualitative Analysen).

### 2020-05-26
Heute gab es viele unerwartete Vorkommnisse. Zuerst wurden zwei Bugs im Parking gemeldet, die ursprünglich für heute geplant waren. Wegen dieser Bugs konnte die Auslieferung nicht heute erfolgen. Wang Wei hat mit den Downstream-Partnern vereinbart, die Auslieferung um zwei Tage auf übermorgen zu verschieben. Daher besteht meine Hauptarbeit für die nächsten zwei Tage wieder darin, Bugs zu beheben. Das lässt mich über die Planung bei Auslieferungen nachdenken. Dann gab es noch das Problem HDMAPMDK-1290.

Heute erledigte Dinge:
- Folge von HDMAPMDK-1290: Wenn man sich extrem nahe an einer Stop-Line befindet, kann der gematchte Lane-Offset länger sein als die Lane-Länge.
  > Habe den ganzen Tag damit verbracht, dieses Problem zu untersuchen und eine Lösung zu finden (aktuell 20:56 Uhr abends), die Effizienz war sehr niedrig.

  Der Grund liegt darin, dass das MDK bei der Längenberechnung für jeweils zwei Punkte eine Koordinatentransformation durchführt. Obwohl dies genauer ist, führt es zu starker Unvorhersehbarkeit des Ergebnisses.

  Schlussendlich wurde eine Art Hack verwendet: Wenn der berechnete Offset länger als die Länge ist, wird nur die Länge genommen.
- HDMAPMDK-1297 Falsche Parkplatzbindung
  Obwohl es fast zur ursprünglich geplanten Feierabendzeit ist (21 Uhr), muss ich dieses Problem heute zumindest analysieren!
  Na ja, erledigt. Es war ein einfaches Problem.

### 2020-05-27
Heute sollte ich, wenn nichts dazwischenkommt, die CI-Pipeline-Angelegenheit abschließen.

Dann kam doch etwas dazwischen - -

Bugs von Yiming erhalten:
1. Ampelbindung: Eine Ampel, die an der Aufstellfläche hätte gebunden werden sollen, wurde an der Partition davor gebunden. Bereits behoben (1,5h).
2. Fehlende Ampelbindung: Konnte nicht reproduziert werden.
   Update: Nach einer schwierigen Debugging-Session wurde das Problem gefunden. Beim Kompilieren wurde für die Bindung von rc und offset eine andere Geometrielinie verwendet, was zu einem Offset führte, der die Straßenlänge überschritt, sodass die Ampel nicht gefunden wurde (2h).

### 2020-05-28
Morgen ist die praktische Fahrprüfung (Kategorie 2), heute den ganzen Tag Fahrstunde gehabt, bin erst um 17 Uhr zurück. Fühlt sich gut an, hoffe, ich bestehe morgen.

Habe mit der Beschreibung des aktuellen Stands und der Anforderungsanalyse für die CI-Pipeline begonnen - -

### 2020-05-29
Habe nicht bestanden. Ach, das ist echt schwer.

War morgens zur Prüfung, nachmittags ein paar Dinge erledigt.

1. Bei Yiming eine abnormale Situation angeschaut, stellte sich als zwei Bugs heraus.
2. Nach dem Townhall das MDK Python Binding besprochen.
3. Mit Shanle und Weiyu nach unten gegangen, um ein Downstream-Problem zu lösen. Schlussendlich eine kurzfristige und eine langfristige Lösung erarbeitet.

Ich stelle fest, dass bei unerwarteten Problemen die Lösungsmethode im Allgemeinen diesem Muster folgen sollte:
Eine kurzfristige Lösung und eine langfristige Lösung. Denn der Wert, den ein Problem offenbart, ist begrenzt und hat eine zeitliche Begrenzung. Daher zielt die kurzfristige Lösung darauf ab, die dringendsten Probleme schnell und präzise zu lösen. Braucht es dann noch eine langfristige Lösung? Im Allgemeinen ja, denn ein spezieller Fall eines Problems spiegelt eine Klasse von bisher nicht berücksichtigten blinden Flecken in der Lösungsfindung wider. Dann ist es notwendig, die Ursache des Problems zu analysieren und es systematisch zu lösen, damit solche Probleme in Zukunft gut gelöst werden können und die ursprüngliche Lösung vollständiger wird. Es gibt auch Fälle, in denen keine langfristige Lösung benötigt wird, nämlich wenn wir **nach gründlicher Analyse** zu dem Schluss kommen, dass der Aufwand für die systematische Lösung des Problems den Nutzen übersteigt. (Selbst dann möchten wir subjektiv oft das Problem systematisch lösen – welcher Ingenieur möchte nicht systematisch Probleme lösen? Aber das birgt auch eine Falle, da man dazu neigen könnte, wichtige, aber nicht dringende oder weder wichtige noch dringende Dinge zu lösen und dabei wertvolle Zeit zu verschwenden, die für andere, wertvollere Probleme hätte verwendet werden können.)

4. Abends zurückgekommen und weiter an der CI-Pipeline gearbeitet.