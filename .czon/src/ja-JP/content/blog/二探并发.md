---
"title": "並行処理の再考（アクターモデル）"
"summary": "本稿では、並行システムにおいて共有メッセージキューを使用する場合、各ワーカーが非同期に各々の役割を果たす必要がある際に、メッセージの宛先指定ができず、誤ったメッセージを受信することで効率低下やタイミングの問題が生じることを分析します。著者は、共有メッセージキューのFIFO特性とロック機構がもたらす効率問題を指摘し、根本的な解決策としてアクターモデルを提案します。アクターモデルは、各ワーカーに独立したメッセージキュー（メールボックス）を設けることで、メッセージの宛先指定と非同期通信を実現し、共有メモリの複雑さを回避します。記事ではアクターモデルの概念を詳細に説明し、Pythonスレッドによる実装例を示します。BaseWorkerクラスを通じて、メッセージ送信、受信、スレッド管理といったアクターの基本機能を実装する方法を解説します。最後に、並行プログラミングにはより抽象的な思考が必要であり、アクターモデルはその入門として有効であると結論づけています。"
"tags":
  - "python"
  - "並行処理"
  - "アクターモデル"
  - "メッセージキュー"
  - "非同期プログラミング"
"date": "2017-05-19"
---

---
title: 並行処理の再考（アクターモデル）
date: 2017-05-19
taxonomies:
  tags:
    - python
    - 並行処理
---

[前回](http://0xc1.space/2017/05/06/初探并发/)は、スレッド（プロセス）間の通信を実現するためにメッセージキューを用いてメッセージをやり取りする方法について述べました。

<!--more-->

## 共有メッセージキュー

これは、**並行処理がシステムのスループット向上だけを目的としているという前提**に基づいています。この仮定では、各ワーカーは同じ仕事を行うため、一つのメッセージキューを共有し、誰が次の命令を受け取っても問題ありません。

### もし私たちが同じ役割ではないなら

例えば、各ワーカーが非同期に各々の役割を果たすシステム（例：IP電話）を実装する必要がある場合はどうでしょうか？上記の方法をそのまま使用し、すべてのワーカーが一つのメッセージキューを共有すると、問題が発生します：特定のワーカーにメッセージを送ることができません。

この問題をどう解決するでしょうか？単純で直接的な解決策は、各メッセージに宛先を示す識別子を付けることです：

```python
queue = Queue([('Send_to_worker_A', 'do_something1'),
               ('Send_to_worker_B', 'do_something2'),
               ('Send_to_worker_B', 'do_something3'),
               ('Send_to_worker_C', 'do_something4'),
               ('Send_to_worker_A', 'do_something5')])
```

これで問題は解決したように見えますね？しかし、新たな問題を導入してしまいました。

### もし誤って他人への手紙を開封してしまったら

もしworker A宛のメッセージがworker Bに届いてしまった場合、そのメッセージはworker Bにとって何の役にも立ちません。一方、本来そのメッセージを受け取るべきworker Aはそれを受け取れず、メッセージは失われてしまいます。これはworker Bの時間を浪費し、worker Aの時間を無駄にし、さらにはステップの飛び越しによってシステム全体が奇妙なバグに陥る可能性さえあります。

この問題はどう解決すればよいでしょうか？直感的には、各ワーカーに次のような戦略を追加すれば問題は解決するように思えます：他人宛のメッセージを受け取ったら、そのメッセージをメッセージキューに戻す。

```python
class Worker_B:
    
    def run(self):
        while True:
            if not self.queue.empty():
                data = self.queue.get()
                if data['to_whom'] == 'worker_B':
                    do_something_with_data
                else:
                    self.queue.put(data)
```

一見、問題を修正したように見えます...しかし、実際にはまた新たな問題を導入してしまいました。

### これは行き止まりのように見える

第一に、メッセージキューはキューであり、FIFO（先入れ先出し）を意味します。優先順位付きメッセージキューを導入しても、本質的にはこの点は変わりません。このため、本来最初にworker Aに渡されるべきメッセージが、worker Bによって処理された後、現在のメッセージキューの中でworker Aに渡されるのが最も遅いメッセージになってしまい、システムが奇妙なバグに陥る可能性があります。

第二に、たとえ誤って配信されたメッセージをメッセージキューの先頭に戻す方法を考えたとしても、誤ったメッセージを受け取ったworker Bの「受信-確認-返却」操作をアトミック操作にするロック機構を導入しなければ、worker Bが返却操作を実行している間に、他のワーカーがすでにメッセージ受信操作を続行している可能性があり、依然としてタイミングに関する大きな問題を引き起こす可能性があります。ロック機構を導入すれば論理的な誤りは解決できますが、これにより各ポーリングサイクルで実際に仕事ができるのは一つのワーカーだけになり、誤ったメッセージを受け取って「受信-確認-返却」操作を実行する他のワーカーは、自分のタイムスライスを無駄にし、**効率が低下します。**

したがって、非同期作業のために並行処理を導入するシステムにとっては、各ワーカーが同じメッセージキューを共有することは良い方法ではないようです。

この問題を根本的に解決する方法は、同じタスクを実行するワーカーのグループごとに専用のメッセージキュー（メールボックス）を設けること、あるいは各ワーカーに独自のメッセージキューを設け、スレッド間でのメモリ共有能力を完全に放棄することです。後者の方法が、本日お話しする主役である**アクターモデル（Actor model）**です。

## アクターモデル

まず、ウィキペディアによるアクターモデルの定義と概念を見てみましょう：

### 概念

計算機科学において、アクターモデル（Actor model）は並行計算におけるモデルの一つです。「アクター」はプログラム上の抽象概念であり、並行計算の基本単位と見なされます：アクターがメッセージを受信すると、いくつかの決定を下したり、より多くのアクターを作成したり、より多くのメッセージを送信したり、次のメッセージにどのように応答するかを決定したりすることができます。アクターモデルは、1973年にCarl Hewitt、Peter Bishop、Richard Steigerの論文で提唱されました。

アクターモデルが提唱する哲学は「すべてがアクターである」というもので、これはオブジェクト指向プログラミングの「すべてがオブジェクトである」という考えに似ていますが、オブジェクト指向プログラミングは通常逐次実行されるのに対し、アクターモデルは並行実行されます。アクターは計算実体であり、受信したメッセージに応答し、同時に並行して以下のことができます：

- 他のアクターに有限数のメッセージを送信する；
- 有限数の新しいアクターを作成する；
- 次のメッセージを受信したときの振る舞いを指定する。

以上の操作は逐次実行を前提としていないため、並行して行うことができます。送信者と送信済みメッセージの分離は、アクターモデルの根本的な利点です。これにより、非同期通信が可能になり、メッセージパッシングの制御構造が満たされます。メッセージの受信者はアドレスによって区別され、時には「メールアドレス」とも呼ばれます。したがって、アクターは自分がアドレスを持っているアクターとしか通信できません。アクターは受信した情報からアドレスを取得したり、自分が作成したアクターのアドレスを取得したりすることができます。アクターモデルの特徴は、アクター内部またはアクター間で並行計算が行われ、アクターは動的に作成でき、アドレスはメッセージに含まれ、相互作用は直接的な非同期メッセージ通信のみを通じて行われ、メッセージの到着順序に制限がないことです。

### 実装

アクターは十分にシンプルで、並行処理のために生まれ、変化を隔離するのに十分なカプセル化を備えています（例：マルチスレッドかマルチプロセスかを気にしない）。

典型的なアクターのPythonスレッド実装を見てみましょう：

```python

from queue import Queue
from threading import Thread, Event


class WorkerExit(Exception):
    # タスク終了用の例外
    pass


class BaseWorker(object):
	# Actor
    def __init__(self):
        self._mailbox = Queue()
        super(BaseWorker, self).__init__()

    def send(self, msg):
        self._mailbox.put(msg)

    def recv(self):
        msg = self._mailbox.get()
        if msg is WorkerExit:
            raise WorkerExit()
        return msg

    def close(self):
        self.send(WorkerExit)

    def start(self):
        self._terminated = Event()
        t = Thread(target=self._bootstrap)

        t.daemon = True
        t.start()

    def _bootstrap(self):
        try:
            self.run()
        except WorkerExit:
            pass
        finally:
            self._terminated.set()

    def join(self):
        self._terminated.wait()

    def run(self):
        raise NotImplementedError
```

簡単に説明すると、このアクター（BaseWorkerと名付け、実際のプロジェクトでは親クラスとして使用します）は、メールボックスとしての`Queue`と、メインスレッドをブロックする仕掛けとしての`Event`という2つのデータ構造を維持します。

ここでの外部インターフェースの核心となる操作は`send()`メソッドだけです。**渡すメッセージの型を制限しない**ことに注意してください。これは非常に高い柔軟性を意味します。

アクター内部では、一つのスレッドを使用して`run()`メソッドを実行し、`recv()`メソッドと組み合わせて指定された具体的な仕事を実行します。特筆すべきは、タスクを停止させるための番兵信号`WorkerExit`を設定している点です。`WorkerExit`の動作原理は、認識されると例外としてスローされることです。例外処理の部分ではさらに多くのことを行うこともできますが、ここではこの例外をキャッチしたときにスレッドの実行を停止するだけです。この例外処理の実装は、`run()`メソッドをラップする`_bootstrap()`メソッドに依存しています。

アクターモデルの哲学の下で、このシンプルな例を拡張し、さらに先へ進むことができます。

## まとめ

並行プログラミングには、通常よりもより抽象的な思考様式が必要であり、「高凝集、低結合」という思想の良い実践例ともなり得ます。

私にとってこの全く新しい分野の探求において、アクターモデルは確かに道を照らす灯台であり、私を本当の意味で入門させてくれました。ですから、ここで共有させていただきます。 :)