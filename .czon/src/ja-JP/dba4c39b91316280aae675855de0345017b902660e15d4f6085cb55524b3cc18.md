---
"title": "並行処理への初めての一歩"
"summary": "本記事では、筆者が小さな課題を通じて並行プログラミングに触れ、Pythonのqueue、signal、timeモジュールを使用して簡単なデモを作成した経験を紹介します。このデモは、メッセージキューを用いたスレッド間通信の実現方法を示しています。queueをメッセージキューとして、signalをKeyboardInterruptの捕捉に、timeをメインスレッドの応答のために使用する役割を説明し、マルチスレッド環境下でメッセージキューを用いてシステムの結合度を下げる設計思想について考察します。また、「変化に対応するための設計」の重要性を強調しています。"
"tags":
  - "python"
  - "並行処理"
  - "マルチスレッド"
  - "メッセージキュー"
  - "queue"
  - "signal"
  - "time"
"date": "2017-05-07"
---

---
title: 並行処理への初めての一歩
date: 2017-05-07
taxonomies:
  tags:
    - python
    - 並行処理
---

最近の小さな課題で、初めて意味のある並行プログラミングに触れる機会がありました。

<!--more-->

## デモ

そこで、Pythonの`queue`、`signal`、`time`モジュールを使って、厳密なマルチスレッドではないものの、概念を示すための小さなデモを作成しました：

```python
# -*- coding: utf-8 -*-
# @Author: Michale
# @Date:   2017-05-04 15:00:41
# @Last Modified by:   Michale
# @Last Modified time: 2017-05-07 00:46:52
import signal
import queue
import time


class TestClass(object):
    queue = queue.Queue()

    def __init__(self):
        signal.signal(signal.SIGINT, self.stopIfPressKill)

    def stopIfPressKill(self, mySignal, stack):
        if mySignal == signal.SIGINT:
            print('you pressed CTRL-C')
            self.queue.put_nowait('stop')
            print(self.queue.qsize())

    def mainThread(self):
        while True:
            time.sleep(1)
            if not self.queue.empty():
                data = self.queue.get()
                print(data)
                if data == 'stop':
                    break
                else:
                    self.queue.put(data)


if __name__ == '__main__':
    yoo = TestClass()
    yoo.mainThread()

```

3つのモジュールの役割を説明します：

- `queue`：メッセージキューとして使用しています。ここでは少々大げさな使い方かもしれません。
- `signal`：`KeyboardInterrupt`を捕捉し、停止信号をメッセージキューに投入するために使用します。
- `time`：メインスレッドがこの`KeyboardInterrupt`を捕捉できるようにするために使用します。

## 設計思想

マルチスレッドを導入すると、メインスレッド以外のスレッドは起動後に制御が難しくなるため、メッセージキューなどの方法を用いてスレッド間通信を実現することが求められます。

しかし、マルチスレッドであるかどうかに関わらず、システムの各モジュールは本来、詳細をカプセル化し、イベントを用いて協調動作させるべきです。これはシステムの結合度を下げるのに大きく役立ち、優れたシステムの設計思想でもあります：**変化に対応するための設計です。**