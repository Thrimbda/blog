---
title: Erste Schritte in die Nebenläufigkeit
date: 2017-05-07
taxonomies:
  tags:
    - python
    - Nebenläufigkeit
---

Gut, eine kürzliche kleine Aufgabe hat mich dazu gebracht, erstmals mit wirklich bedeutungsvoller nebenläufiger Programmierung in Berührung zu kommen.

<!--more-->

## Demo

Daher habe ich mit Pythons `queue`-, `signal`- und `time`-Modulen ein kleines Demo erstellt, das nicht wirklich multithreaded ist, sondern nur zur Veranschaulichung dient:

```python
# -*- coding: utf-8 -*-
# @Author: Michale
# @Date:   2017-05-04 15:00:41
# @Last Modified by:   Michale
# @Last Modified time: 2017-05-07 00:46:52
import signal
import queue
import time


class TestClass(object):
    queue = queue.Queue()

    def __init__(self):
        signal.signal(signal.SIGINT, self.stopIfPressKill)

    def stopIfPressKill(self, mySignal, stack):
        if mySignal == signal.SIGINT:
            print('you pressed CTRL-C')
            self.queue.put_nowait('stop')
            print(self.queue.qsize())

    def mainThread(self):
        while True:
            time.sleep(1)
            if not self.queue.empty():
                data = self.queue.get()
                print(data)
                if data == 'stop':
                    break
                else:
                    self.queue.put(data)


if __name__ == '__main__':
    yoo = TestClass()
    yoo.mainThread()

```

Erklärung der drei Module:

- `queue`: Dient als Nachrichtenwarteschlange, was hier offensichtlich etwas übertrieben ist.
- `signal`: Wird verwendet, um `KeyboardInterrupt` abzufangen und danach das Stoppsignal in die Nachrichtenwarteschlange zu legen.
- `time`: Ermöglicht es dem Hauptthread, diesen `KeyboardInterrupt` abzufangen.

## Gedankengang

Die Einführung von Multithreading macht es schwierig, nicht-primäre Threads nach ihrem Start zu kontrollieren, weshalb man gezwungen ist, Methoden wie Nachrichtenwarteschlangen für die Kommunikation zwischen Threads zu verwenden.

Aber unabhängig davon, ob es sich um Multithreading handelt oder nicht, sollten die verschiedenen Module eines Systems ihre Details kapseln und mithilfe von Ereignissen zusammenarbeiten. Dies trägt erheblich zur Verringerung der Systemkopplung bei und ist auch ein gutes Designprinzip für ein System: **Entwurf für Veränderung.**