---
"title": "新しいブログをいじくり回す：ブログに「机组」を移した過程"
"summary": "本稿では、著者がGcores上の「机组」コンテンツを個人ブログに移行した技術的過程を詳細に紹介します。古いブログが依存関係の陳腐化により機能しなくなったことから始まり、新しいブログジェネレーターとしてZolaを選んだ理由を説明。APIを用いた机组データの取得、Markdown形式への変換処理、そしてスライド式画像ギャラリーを実現するためのHTML、CSS、JavaScriptによるフロントエンド実装に焦点を当てています。著者は、フロントエンド開発における迅速なフィードバックループの楽しさを強調し、タッチ操作のRxJS実装についても共有しています。最後に、ブログを完全に掌握できた満足感と、コードを書くことの純粋な喜びについてまとめています。内容は比較的浅いものの、過程は達成感に満ちたものでした。"
"tags":
  - "ブログ"
  - "技術"
  - "フロントエンド開発"
  - "データスクレイピング"
  - "Zola"
  - "Gcores"
  - "RxJS"
  - "Markdown"
"date": "2024-06-18"
---

**この記事は、私の忘れられない童心から生まれました。**

4月、ある旅の途中で、私は強い衝動に駆られて旅行記を書き、まずGcoresに投稿しました。そしていつものように、Markdown形式に整理して自分のブログに載せようとしました。

編集を終えた後、ブログが壊れていることに気づきました。

## 以前のブログ

個人ブログを構築するブームは、大学3年生の時に私の学科で流行りました。7年前に書いた[この記事](./搭好博客后的一点话.md)（今読むと恥ずかしさで足の指が丸まるような文章です）は、私が最初にこのブログを構築した時の心境を紹介しています。

その理由は、まず自分に何かを書くことを促したかったからです。次に、学校では教えてくれない、最新で派手な技術を組み合わせたエンジニアリングの実践をしたかったからです。そして、独自ドメインを持つことは本当にかっこいいと思ったからです、少なくとも私にはそう思えました。

当時の情景を再現してみましょう。

---

何か新しいことを少し学ぶたびに、興奮した気持ちで、心に浮かんだ考えをMarkdown形式のドキュメントに記録しました。

書き終えた後、新しいブログをアップロードするために、いくつかのコマンドを粋に実行しました：

```shell
$ git add .
$ git commit -m "new blog! hahahaha"
$ git push origin master
```

そしてワクワクしながらCIのインターフェースを開きました。当時、CIはまだ比較的新しい概念で、DevOpsの理念が提唱されてから数年しか経っていませんでした。CIのログページで、この記事を含むブログ全体が静的なHTMLサイトとして構築されるのを待ち、Travisが私の鍵を使ってビルド成果物をGitリポジトリにプッシュするのを待ち、Githubがビルド成果物を公開するのを待ちました。

最後に、私のドメイン [https://blog.thrimbda.com](https://blog.thrimbda.com) にアクセスし、その新しい記事がページの一番上に表示されているのを満足げに見つめました。

---

年月が経つにつれ、このプロセスは退屈なものになり、退屈でありながらも有効であり続けました。それがついに機能しなくなる日が来るまで。

## 新しいブログ

4月末のある日、CIパイプラインを3回連続で再実行しましたが、すべて失敗しました。ログをざっと見ると、ビルドに使用されていたある依存関係が古すぎて、インターネット上から消えてしまったようでした。私はこの業界において7年という時間がどれほど巨大なスパンであるかを痛感しました。砂嵐が城を壊し、海水が山頂を飲み込むほどに長い時間です。

そこで、仕事の合間の「サボり時間」に、あまり面白くない要件をいくつか持って技術選定を行いました：**十分にシンプルで、十分に便利であること。**

この新しいブログはそうして生まれました。いつものように紹介します：

- ジェネレーターとして [Zola](https://www.getzola.org/) を選びました；
- 非常にシンプルですがなかなか良い見た目の[テーマ](https://github.com/Speyll/anemone)を見つけました；

古いブログの代替として、この新しいブログは完成しました。

## 童心が忘れられない、いじくり回す過程

おそらく十分に新しいから、あるいは技術選定が十分にシンプルだったから、フロントエンド作業のフィードバックループが十分に短いから、そして阿錚と一緒に仕事をしていると自然とフロントエンドの知識が耳に入ってきて、大学1年生の時にあまり真剣に学ばなかった知識の穴を埋めることができたからでしょう。ブログをいじくり回す過程は再び面白くなりました。

ちょっとした腕試しのCSSスタイル修正、新しいgitcus（Githubにコメント欄をホストするもの）の追加。私は7年前の自分と意見が一致しました：コーディングとエンジニアリングをいじくり回すことは、やはり楽しいことです。労働の喜びであり、遊びの喜びです。

私はこの喜びの余韻に乗って、自分が「机组」をブログに移した技術的過程を（自己満足で）詳しく話したいと思います。

<!--more-->

---

### データ

以前のある探索で、私はGcoresがクローラーに対して驚くほど友好的であることに気づいていました。そのデータインターフェースは非常に統一されていて表現力に富んでいます。例えば、私の「机组」を探索してみましょう：

![gcores-api-at-glance](https://0xc1.space/images/2024/06/18/gcores-api-at-glance.jpg)

このURLが「机组」データをリクエストするためのAPIであることがわかります。

```
https://www.gcores.com/gapi/v1/users/464460/recommend?talk-include=topic%2Cuser%2Chelpful%2Cpoll-options%2Crelated-content.radio%2Crelated-content.video%2Crelated-content.article%2Crelated-content.game%2Crelated-content.film%2Crelated-content.album%2Crelated-content.album-bundle%2Crelated-content.product%2Crelated-content.discussion&original-include=user%2Cdjs%2Ccategory&order-by=time&before=1718720726.986&fields[articles]=title%2Cdesc%2Cexcerpt%2Cis-published%2Cthumb%2Capp-cover%2Ccover%2Ccomments-count%2Clikes-count%2Cbookmarks-count%2Cis-verified%2Cpublished-at%2Coption-is-official%2Coption-is-focus-showcase%2Cduration%2Cdraft%2Caudit-draft%2Cuser%2Ccomments%2Ccategory%2Ctags%2Centries%2Centities%2Csimilarities%2Clatest-collection%2Ccollections%2Coperational-events%2Cportfolios%2Ccatalog-tags&fields[videos]=title%2Cdesc%2Cexcerpt%2Cis-published%2Cthumb%2Capp-cover%2Ccover%2Ccomments-count%2Clikes-count%2Cbookmarks-count%2Cis-verified%2Cpublished-at%2Coption-is-official%2Coption-is-focus-showcase%2Cduration%2Cdraft%2Caudit-draft%2Cuser%2Ccomments%2Ccategory%2Ctags%2Centries%2Centities%2Csimilarities%2Clatest-collection%2Ccollections%2Coperational-events%2Cportfolios%2Ccatalog-tags%2Cmedia%2Cdjs%2Calbums%2Cpublished-albums&fields[radios]=title%2Cdesc%2Cexcerpt%2Cis-published%2Cthumb%2Capp-cover%2Ccover%2Ccomments-count%2Clikes-count%2Cbookmarks-count%2Cis-verified%2Cpublished-at%2Coption-is-official%2Coption-is-focus-showcase%2Cduration%2Cdraft%2Caudit-draft%2Cuser%2Ccomments%2Ccategory%2Ctags%2Centries%2Centities%2Csimilarities%2Clatest-collection%2Ccollections%2Coperational-events%2Cportfolios%2Ccatalog-tags%2Cmedia%2Cdjs%2Clatest-album%2Calbums%2Cis-free%2Cis-require-privilege
```

#### 生データ

情報を整理してみましょう：

```ts
const user = 464460;

const url = new URL(
  `https://www.gcores.com/gapi/v1/users/${user}/recommend?talk-include=topic%2Cuser%2Chelpful%2Cpoll-options%2Crelated-content.radio%2Crelated-content.video%2Crelated-content.article%2Crelated-content.game%2Crelated-content.film%2Crelated-content.album%2Crelated-content.album-bundle%2Crelated-content.product%2Crelated-content.discussion&original-include=user%2Cdjs%2Ccategory&order-by=time&fields[articles]=title%2Cdesc%2Cexcerpt%2Cis-published%2Cthumb%2Capp-cover%2Ccover%2Ccomments-count%2Clikes-count%2Cbookmarks-count%2Cis-verified%2Cpublished-at%2Coption-is-official%2Coption-is-focus-showcase%2Cduration%2Cdraft%2Caudit-draft%2Cuser%2Ccomments%2Ccategory%2Ctags%2Centries%2Centities%2Csimilarities%2Clatest-collection%2Ccollections%2Coperational-events%2Cportfolios%2Ccatalog-tags&fields[videos]=title%2Cdesc%2Cexcerpt%2Cis-published%2Cthumb%2Capp-cover%2Ccover%2Ccomments-count%2Clikes-count%2Cbookmarks-count%2Cis-verified%2Cpublished-at%2Coption-is-official%2Coption-is-focus-showcase%2Cduration%2Cdraft%2Caudit-draft%2Cuser%2Ccomments%2Ccategory%2Ctags%2Centries%2Centities%2Csimilarities%2Clatest-collection%2Ccollections%2Coperational-events%2Cportfolios%2Ccatalog-tags%2Cmedia%2Cdjs%2Calbums%2Cpublished-albums&fields[radios]=title%2Cdesc%2Cexcerpt%2Cis-published%2Cthumb%2Capp-cover%2Ccover%2Ccomments-count%2Clikes-count%2Cbookmarks-count%2Cis-verified%2Cpublished-at%2Coption-is-official%2Coption-is-focus-showcase%2Cduration%2Cdraft%2Caudit-draft%2Cuser%2Ccomments%2Ccategory%2Ctags%2Centries%2Centities%2Csimilarities%2Clatest-collection%2Ccollections%2Coperational-events%2Cportfolios%2Ccatalog-tags%2Cmedia%2Cdjs%2Clatest-album%2Calbums%2Cis-free%2Cis-require-privilege`
);
```

さらに観察すると、ページネーションは `before` というパラメータで決定されているようです。このパラメータのタイムスタンプを前に進め続け、データが取得できなくなるまで繰り返せばよいのです。これにより、次のようなコードが得られます：

```ts
import {
  EMPTY,
  Observable,
  expand,
  map,
  mergeAll,
  mergeMap,
  of,
  shareReplay,
  skip,
  takeWhile,
  tap,
  toArray,
} from "https://esm.sh/rxjs@7.8.1";

const user = 464460;

const url = new URL(
  `https://www.gcores.com/gapi/v1/users/${user}/recommend?talk-include=topic%2Cuser%2Chelpful%2Cpoll-options%2Crelated-content.radio%2Crelated-content.video%2Crelated-content.article%2Crelated-content.game%2Crelated-content.film%2Crelated-content.album%2Crelated-content.album-bundle%2Crelated-content.product%2Crelated-content.discussion&original-include=user%2Cdjs%2Ccategory&order-by=time&fields[articles]=title%2Cdesc%2Cexcerpt%2Cis-published%2Cthumb%2Capp-cover%2Ccover%2Ccomments-count%2Clikes-count%2Cbookmarks-count%2Cis-verified%2Cpublished-at%2Coption-is-official%2Coption-is-focus-showcase%2Cduration%2Cdraft%2Caudit-draft%2Cuser%2Ccomments%2Ccategory%2Ctags%2Centries%2Centities%2Csimilarities%2Clatest-collection%2Ccollections%2Coperational-events%2Cportfolios%2Ccatalog-tags&fields[videos]=title%2Cdesc%2Cexcerpt%2Cis-published%2Cthumb%2Capp-cover%2Ccover%2Ccomments-count%2Clikes-count%2Cbookmarks-count%2Cis-verified%2Cpublished-at%2Coption-is-official%2Coption-is-focus-showcase%2Cduration%2Cdraft%2Caudit-draft%2Cuser%2Ccomments%2Ccategory%2Ctags%2Centries%2Centities%2Csimilarities%2Clatest-collection%2Ccollections%2Coperational-events%2Cportfolios%2Ccatalog-tags%2Cmedia%2Cdjs%2Calbums%2Cpublished-albums&fields[radios]=title%2Cdesc%2Cexcerpt%2Cis-published%2Cthumb%2Capp-cover%2Ccover%2Ccomments-count%2Clikes-count%2Cbookmarks-count%2Cis-verified%2Cpublished-at%2Coption-is-official%2Coption-is-focus-showcase%2Cduration%2Cdraft%2Caudit-draft%2Cuser%2Ccomments%2Ccategory%2Ctags%2Centries%2Centities%2Csimilarities%2Clatest-collection%2Ccollections%2Coperational-events%2Cportfolios%2Ccatalog-tags%2Cmedia%2Cdjs%2Clatest-album%2Calbums%2Cis-free%2Cis-require-privilege`
);

const imageUrl = (image: string) =>
  `https://image.gcores.com/${image}?x-oss-process=image/quality,q_90/format,webp`;

// ページネーション
url.searchParams.set("before", `${Date.now() / 1000}`);

interface IGcoresTalk {
  text: string;
  images: string[];
  published_at: number;
  tags: string[];
}

const rawGcoresTalkData$: Observable<any[]> = of({
  before: Date.now() / 1000,
}).pipe(
  // 生データ
  expand(async ({ before }) => {
    url.searchParams.set("before", `${before}`);
    const res = await fetch(url);
    const data = await res.json();
    if (!data.data || data.data.length === 0) {
      return EMPTY;
    }
    return {
      before:
        new Date(
          data.data[data.data.length - 1].attributes["published-at"]
        ).getTime() / 1000,
      ...data,
    };
  }),
  skip(1),
  // デバッグ用
  // take(1),
  takeWhile((v) => !!v.data),
  // filter((v) => v.data.length > 0),
  tap((v) => {
    console.info(v);
  }),
  toArray(),
  shareReplay(1)
);
```

これで、あるユーザーのすべての「机组」生データを保持するRxストリームが得られました。

#### データ処理

生データが手に入ったので、次はMarkdownに処理します。直接処理を始めましょう。ポイントは以下の通りです：

- 表示する内容を決める
- Gcoresのインターフェースフィールドを理解する

「机组」は、SNSの投稿や微博と似ていて、文字と画像、それにいくつかのタグで構成されています。そのまま平らに表示しましょう。

「机组」のデータは以下のように定義できます：

```json
{
  "blocks": [
    {
      "data": { "spoiler": false },
      "depth": 0,
      "entityRanges": [{ "key": 0, "length": 1, "offset": 0 }],
      "inlineStyleRanges": [],
      "key": "7u4tf",
      "text": "-",
      "type": "atomic"
    },
    {
      "data": { "spoiler": false },
      "depth": 0,
      "entityRanges": [],
      "inlineStyleRanges": [],
      "key": "wisz4",
      "text": "核聚变好玩，和雨川西蒙合了影，见到了做志愿者的 merz，然而社恐差点没敢上前搭话，腿快走断了，给没能来的小朋友们买了点纪念品，Celeste 随机异变速通震撼我妈，全程硬是没把因为震惊而张开的大嘴合上。可惜周天广州下雨航班被取消所以急匆匆买了深圳回上海的高铁票就没去成周天的。",
      "type": "unstyled"
    },
    {
      "data": { "spoiler": false },
      "depth": 0,
      "entityRanges": [],
      "inlineStyleRanges": [],
      "key": "nzffe",
      "text": "",
      "type": "unstyled"
    },
    {
      "data": { "spoiler": false },
      "depth": 0,
      "entityRanges": [],
      "inlineStyleRanges": [],
      "key": "7f8m6",
      "text": "下次还来！",
      "type": "unstyled"
    }
  ],
  "entityMap": {
    "0": {
      "data": {
        "caption": "",
        "images": [
          {
            "path": "0ad6514d154c80a9ef6b4b0d6173d132-3024-4032.HEIC",
            "width": 3024,
            "height": 4032
          },
          {
            "path": "69cea053377d3155d5f7e22e8584f289-4032-3024.HEIC",
            "width": 4032,
            "height": 3024
          },
          {
            "path": "aedf102fa319ce3df2438386f894def4-4032-3024.HEIC",
            "width": 4032,
            "height": 3024
          }
        ]
      },
      "mutability": "IMMUTABLE",
      "type": "GALLERY"
    }
  }
}
```

出力したい内容と合わせて、以下のような構造体を定義します：

```ts
interface IGcoresTalk {
  text: string;
  images: string[];
  published_at: number;
  tags: string[];
}
```

出力するのは、`string` 型のMarkdownテキストにします。

```ts
const cookedData$ = rawGcoresTalkData$.pipe(
  mergeAll(),
  mergeMap(({ data, included }): IGcoresTalk[] => {
    // トークのタグとしてタイトルのみが必要
    const mapTypeIdToTitle = Object.fromEntries(
      included.map((v: any) => [`${v.type}-${v.id}`, v.attributes.title])
    );
    console.info(mapTypeIdToTitle);
    const talks = data
      .filter((v: any) => v.type === "talks")
      .map((v: any) => {
        const content = JSON.parse(v.attributes.content);
        const text = content.blocks
          .filter((v: any) => v.type === "unstyled")
          .map((v: any) => v.text.replace(/\#/, "\\#"))
          .join("\n");

        const images = (content.entityMap?.[0]?.data?.images ?? []).map(
          (v: any) => v.path
        );
        const published_at = new Date(v.attributes["published-at"]).getTime();
        const tags = Object.values(v.relationships as any[])
          .filter((v) => !!v.data)
          .filter((v) => ["topics", "games"].includes(v.data.type))
          .map(({ data }) => mapTypeIdToTitle[`${data.type}-${data.id}`]);
        return {
          text,
          images,
          published_at,
          tags,
        };
      });

    return talks;
  })
);
```

これで、欲しいデータ構造が大量に得られました。次は `string` に処理するだけです。

```ts
cookedData$
  .pipe(
    //
    tap((v) => {
      console.info(v);
    }),
    map((v: IGcoresTalk): string => {
      const published_time = new Date(v.published_at);
      const title = `## ${published_time.getFullYear()}-${
        published_time.getMonth() + 1
      }-${published_time.getDate()}`;
      const content = v.text;
      const images = v.images.map((v) => `![${v}](${imageUrl(v)})`).join("\n");
      const tags = v.tags.map((v) => `- ${v}`).join("\n");

      return `${title}\n\n${images}\n\n${content}\n\n${tags}\n`;
    }),
    toArray(),
    map(
      (all) =>
        `---\ntitle: '0xc1 の机组ログ'\ndate: ${new Date().toISOString()}\n---\n元のリンク：[Thrimbda の机组](https://www.gcores.com/users/464460/talks)\n${all.join(
          "\n\n---\n---\n\n"
        )}`
    ),
    tap((v) => {
      console.info(v);
    }),
    tap((v) => Deno.writeTextFile(`./content/gcores-talks.md`, v))
  )
  .subscribe();
```

私は最も強引な処理方法を選び、直接近くのディレクトリに出力しました。

このコードの完全版は[こちら](https://github.com/Thrimbda/blog/blob/184bad3cbc217b52248dfe169a09fb44aa551328/scripts/get-gcores-talk.ts)にあり、`deno` で実行します：

```shell
deno cache get-gcores-talk.ts
deno run -A get-gcores-talk.ts
```

### 画像の表示とレンダリング

これで、有効なMarkdownが出力され、まあまあ見られるウェブページとしてレンダリングできるようになりました。

![gcores-pictures-render](https://0xc1.space/images/2024/06/18/gcores-pictures-render.jpg)

しかし、画像は奇妙に見えます：Markdownを直接レンダリングして平らに積み重ねると、画像と文字の比率が非常に不釣り合いで、頭でっかちな印象を与えます。Gcoresのようにスライド式の画像ギャラリーにできたらいいのに。

#### 実装方法の選択

MarkdownはHTMLで表現力を拡張できるので、どのみち自分のコードで画像を直接HTMLとしてレンダリングし、望む効果を得ることができます。しかし、Zolaは別の方法を提供しており、目標をより簡単に実現できます：[Shortcodes | Zola](https://www.getzola.org/documentation/content/shortcodes/)

私たちがやるべきことは、適切なCSSでスタイルを提供し、JSコードでインタラクションを担当するHTMLテンプレートを書くことです。そして、本文のMarkdownの中で直接このHTMLを呼び出します。

待って？HTML + CSS + JSを書くって、大学1年生の頃に戻ったみたいだ。

#### フロントエンドを書く

##### HTML

HTMLの部分は非常にシンプルで退屈です。各画像ギャラリーに以下の要素を提供します：

- スライド画像ギャラリー自体のコンテナ
- 画像
- 下のインデックスを示すドット
- 左右の画像を切り替えるための矢印ボタン

```html
<div class="slider-container">
  <div class="slider-wrapper">
    <div class="slider">
      {% for slide in slides %}
      <div class="slider-item">
        <img src="{{slide}}" />
        {% if slide.caption %}
        <div class="caption">{{slide.caption}}</div>
        {% endif %}
      </div>
      {% endfor %}
    </div>
    <button class="slider-prev" type="button">&#10094;</button>
    <button class="slider-next" type="button">&#10095;</button>
  </div>
  <!-- ドット/円 -->
  <div class="slider-dot-container">
    {% for slide in slides %}
    <span class="slider-dot"></span>
    {% endfor %}
  </div>
</div>
```

##### CSS

よりモダンなフロントエンド技術のおかげで、今ではflexレイアウトを使ってこれを実現するのは非常に簡単です。核心的な考え方は、画像を一列に並べるが、1枚の画像の位置だけを露出させ、他の画像はすべて後ろに隠すことです：

```css
.slider-wrapper {
  overflow: hidden;
  position: relative;
  box-sizing: border-box;
  width: 100%;
}

.slider {
  position: relative;
  display: flex;
  box-sizing: border-box;
}

.slider-item {
  position: relative;
  flex: 1 0 100%;
  min-height: 150px;
  max-height: min(550px, 55svh);

  display: flex;
  align-items: center;
  justify-items: center;
  box-sizing: border-box;

  overflow: visible;
}

.slider-item img {
  position: relative;
  width: auto;
  max-height: 100%;
  margin: auto; /* 水平方向に中央揃え */
}

/* 次へ & 前へ ボタン */
.slider-prev,
.slider-next {
  /* cursor: pointer; */
  position: absolute;
  /* top: 50%; */
  width: auto;
  height: 100%;
  transform: translateY(-100%);
  font-weight: bold;
  font-size: 1.2rem;

  z-index: 1;
  color: white;
  transition: 0.6s ease;
  border-radius: 5px;
  border: none;
  background-color: transparent;
}

/* "次へボタン"を右に配置 */
.slider-next {
  right: 0;
  border-radius: 5px;
  /* border-radius: 3px 0 0 3px; */
}
.slider-prev:hover:enabled,
.slider-next:hover:enabled {
  border: none;
  color: var(--accent);
  background-color: rgba(71, 71, 71, 0.3);
}

.slider-dot-container {
  text-align: center;
}

.slider-dot {
  cursor: pointer;
  height: 15px;
  width: 15px;
  margin: 0 2px;
  background-color: #bbb;
  border-radius: 50%;
  display: inline-block;
  transition: background-color 0.6s ease;
}
.slider-dot:hover,
.slider-dot-active {
  background-color: #717171;
}
```

##### JavaScript

JSの部分は、ユーザーがインタラクションを通じて表示領域の画像を切り替えられるようにする責任があります。これらのインタラクションには以下が含まれます：

- マウスで左右のボタンをクリック
- マウスでドットをクリック
- タッチデバイスでの左右スワイプ

Web APIがJQueryを取り込んだ後、rxjsの助けを借りれば、これは非常に簡単です：

```js
const ELS = (selector, parent) =>
  (parent || document).querySelectorAll(selector);
const EL = (selector, parent) => (parent || document).querySelector(selector);
const mod = (n, m) => ((n % m) + m) % m;

ELS(".slider-container").forEach((EL_parent) => {
  const EL_slider = EL(".slider", EL_parent);
  const ELS_items = ELS(".slider-item", EL_parent);
  const ELS_dots = ELS(".slider-dot", EL_parent);
  const total = ELS_items.length;
  let c = 0;

  const setDotActive = () => {
    ELS_dots.forEach((EL_dot, i) => {
      EL_dot.classList.toggle("slider-dot-active", i === c);
    });
  };

  setDotActive();

  const anim = () => {
    EL_slider.style.transform = `translateX(-${c * EL_slider.offsetWidth}px)`;
  };
  const prev = () => {
    distance = 0;
    startX = 0;
    c = mod(c - 1, total);
    setDotActive();
    anim();
  };
  const next = () => {
    distance = 0;
    startX = 0;
    c = mod(c + 1, total);
    setDotActive();
    anim();
  };

  EL(".slider-prev", EL_parent).addEventListener("click", prev);
  EL(".slider-next", EL_parent).addEventListener("click", next);

  ELS(".slider-dot", EL_parent).forEach((dot, i) => {
    dot.addEventListener("click", () => {
      c = i;
      setDotActive();
      anim();
    });
  });

  const touchstart$ = fromEvent(EL_parent, "touchstart");
  const touchend$ = fromEvent(EL_slider, "touchend");
  const touchmove$ = fromEvent(EL_slider, "touchmove");

  touchstart$
    .pipe(
      tap(() => {
        EL_slider.style.transition = "none";
      }),
      switchMap((start) =>
        animationFrames().pipe(
          withLatestFrom(touchmove$),
          map(([, touchEvent]) => {
            const distance =
              touchEvent.touches[0].clientX - start.touches[0].clientX;

            EL_slider.style.transform = `translateX(-${
              c * EL_slider.offsetWidth - distance
            }px)`;
            return distance;
          }),
          takeUntil(touchend$),
          defaultIfEmpty(0),
          last()
        )
      ),
      tap({
        next: (distance) => {
          EL_slider.style.transition = "transform 0.3s ease-in-out";
          if (distance / EL_slider.offsetWidth > 0.2) {
            c = mod(c - 1, total);
          } else if (distance / EL_slider.offsetWidth < -0.2) {
            c = mod(c + 1, total);
          }
          setDotActive();
          anim();
        },
      }),
      repeat()
    )
    .subscribe();
});
```

このコード全体の大意は、各スライド画像ギャラリーに対して、現在表示されている画像のインデックス `[0, 1, ..., imageNumbers - 1]` を記録することです。ユーザーのインタラクションはインデックスを変更し、それによって現在のスライド画像ギャラリーがインデックスが示す画像を表示するために何ピクセルシフトすべきかを計算します。

私が特に気に入っているのは、最後のタッチインタラクション用のRxコードです。

タッチインタラクションはボタンインタラクションよりも複雑です。なぜなら、ユーザーがスワイプしている間、画像はユーザーの指と一緒に動かなければならず、この感触をうまく調整しないとユーザーをがっかりさせてしまうからです。

この複雑さは、インタラクションにより多くの情報と、より複雑なWEB APIを必要とすることを意味します。

インタラクションロジックの観点から、タッチ開始時の指のピクセル位置、そして各レンダリングフレームが到来した時の初期位置からの指のピクセル位置のオフセットを記録する必要があります。そして、各フレームをレンダリングする際に、このオフセットをスライド画像ギャラリーに追加して、画像が指と一緒に動くようにします。ある距離を移動した後、指が画面から離れたとき、画像を切り替えるかどうかを決定します。例えば、指が画面を軽くタップしただけで、2ピクセルの右へのオフセットが生じた場合、画像は切り替わるべきではありません。一方、指が画面の半分を右にスワイプした場合、画像は切り替わるべきです。オフセットとコンテナ全体の幅の比率の閾値を20%に設定してみましょう。指のスワイプ距離が画像ギャラリー幅の20%を超えた場合、画像を切り替えるべきだと判断します。

APIの観点から、関連するイベントは3つあります：

- touchstart - ユーザーが画面に触れ始めたことを示し、このイベントは最初の指のピクセル座標を保持します。
- touchmove - ユーザーの指が動くたびにトリガーされ、現在の指の座標を保持します。
- touchend - 指が画面から離れたことを示します。

Rxはこの種の要件を実装するのに非常に適しています。ユーザーの指のタッチイベントをデータストリームにラップします。処理後、指の水平オフセットのストリームに変え、各アニメーションフレームで画像の位置を更新するために使用します。最後に、タッチ終了後、オフセットとコンテナ幅の比率に基づいて画像を切り替えるかどうかを決定します。

---

### 喜びはどこから来るのか

仕事は人に喜びをもたらします。なぜなら、私たちの脳はフィードバックとループを好むからです。

{% mermaid() %}

stateDiagram-v2
    [*] --> 労働
    労働 --> 効果を確認
    効果を確認 --> 不満足
    不満足 --> 問題点を考える
    問題点を考える --> 労働
    効果を確認 --> 満足して離れる
    満足して離れる --> [*]

{%