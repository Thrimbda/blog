---
"title": "Lectura de Código Fuente: Análisis de Diseño de Harbor-Operator"
"summary": "Este artículo analiza en detalle el diseño del código fuente de Harbor-Operator, centrándose en cómo resuelve las dependencias entre recursos mediante un Grafo de Dependencias (Dependency Graph), utiliza un único Controlador (Controller) para implementar la lógica de reconciliación de múltiples CRDs, y emplea un ResourceManager para convertir el código en configuración y aumentar la reutilización. El artículo también analiza las prácticas de Harbor-Operator en las plataformas Golang y Kubernetes, mostrando cómo es un ejemplo del principio de diseño 'the right thing', logrando un equilibrio entre simplicidad, consistencia e integridad, proporcionando así una valiosa referencia de diseño para el desarrollo de Operadores."
"tags":
  - "Harbor-Operator"
  - "Análisis de Código Fuente"
  - "Kubernetes"
  - "Patrón Operator"
  - "Grafo de Dependencias"
  - "Diseño de Controladores"
  - "Golang"
  - "Arquitectura de Software"
"date": "2022-01-30"
---

<!--more-->

<a id="orgdafefdb"></a>

## Preparativos Antes de Comenzar

<a id="org081213e"></a>

### ¿Por qué Harbor-Operator?

<a id="org55a74c9"></a>

#### ¿"Worse is Better"?

¿Qué es un buen software?

En un famoso artículo de finales de los 80, *The Rise of Worse is Better*, el autor menciona que un buen diseño de software debe considerar cuatro cualidades: **simplicidad, corrección, consistencia e integridad**.

El autor menciona dos filosofías de diseño de software, llamémoslas provisionalmente **the right thing** y **worse is better** (es necesario señalar que este nombre no es peyorativo); ambas filosofías giran en torno a las cuatro cualidades mencionadas, diferenciándose en la priorización de estas.

---

<a id="orgbebeeee"></a>

##### The right thing

-   **Simplicidad** - El diseño debe ser simple y fácil de entender. La simplicidad de la interfaz es más importante que la simplicidad de la implementación.
-   **Corrección** - El diseño debe ser correcto. En esto no se puede hacer concesiones.
-   **Consistencia** - La consistencia es tan importante como la corrección. Por lo tanto, se puede ceder un poco en simplicidad e integridad.
-   **Integridad** - El diseño debe poder considerar una variedad de situaciones posibles. No se puede sacrificar excesivamente la integridad para mantener la simplicidad.

<a id="org948c614"></a>

##### Worse is better

-   **Simplicidad** - El diseño debe ser simple y fácil de entender. La simplicidad de la implementación es más importante que la simplicidad de la interfaz. La simplicidad es la cualidad más importante.
-   **Corrección** - El diseño debe ser correcto, por supuesto, mantener la simplicidad es un poco más importante que la corrección.
-   **Consistencia** - El diseño no puede ser demasiado inconsistente. Se puede sacrificar la consistencia para mantener la simplicidad. Bajo la premisa de garantizar la simplicidad, se puede sacrificar la consistencia por la integridad.
-   **Integridad** - El diseño debe poder considerar una variedad de situaciones posibles. Se puede sacrificar la integridad en cualquier momento para garantizar la simplicidad del diseño.

---

Posteriormente, el autor da muchos ejemplos de ambos para argumentar por qué *worse-is-better* estaba arrasando en la industria del software en ese momento.

Estas dos filosofías no tienen superioridad o inferioridad. Hoy en día, también las encontramos a nuestro alrededor, y la realidad a menudo oscila entre ambas. Esperamos poder hacer diseños excelentes y con valor estético, pero también debemos considerar factores como el costo y las personas. En última instancia, debemos entregar software de calidad que funcione para resolver problemas del mundo real, y el costo de escribir y mantener el software absolutamente no puede ser mayor que el valor del problema en sí.

<a id="org514ce0b"></a>

#### Golang - el lenguaje

Golang es casi un ejemplo del principio *worse is better*:

-   Condensa años de experiencia práctica de Google en C++.
-   Es tan simple, sin características complejas, que básicamente solo hay una forma de construir para resolver un problema, lo que significa:
    -   Casi no se necesita esfuerzo en el lenguaje mismo para dominarlo fácilmente.
    -   El código es muy fácil de leer.
-   Compila rápidamente, incluso sacrificó los genéricos por la velocidad de compilación.
-   Se pueden ejecutar tareas en paralelo muy fácilmente mediante goroutines.
-   Casi abandona la característica del lenguaje de pila de excepciones, forzando la verificación y manejo de errores.
-   Una compilación, ejecución en todas partes.

<a id="org2432232"></a>

#### Kubernetes - la plataforma

Kubernetes es familiar para todos, no me atrevo a dar lecciones, lo resumo en una frase: proporciona un diseño de API conceptualmente muy simple, complementado con un mecanismo de reconciliación proveniente de la cibernética, que permite la implementación, escalado y operación automatizada de software containerizado.

K8s permite a los desarrolladores extender sus capacidades abriendo esta especificación de API y el mecanismo de reconciliación. Los desarrolladores pueden implementar el **Patrón Operator**: codificar el conocimiento de configuración, implementación (Día 1) y operación, respaldo, conmutación por error (Día 2) del software en software que opera el software, automatizando estas operaciones complejas y propensas a errores, mejorando así la confiabilidad y reduciendo costos.

---

Entonces, la razón para elegir Harbor Operator es que tiene un diseño excelente. En una plataforma excelente y utilizando características de lenguaje simples, sin trucos excesivos, logra un sistema de software práctico y con valor estético a través de varios diseños clave que cumplen con los principios de diseño SOLID, y puede considerarse un practicante de la filosofía *the right thing*.

El código del autor casi no tiene comentarios, pero es excepcionalmente fácil de leer, lo que también se debe a todo el sistema.

<a id="org6815286"></a>

## Objetivo

La abstracción y simplificación de problemas inevitablemente conlleva la pérdida de flexibilidad, mientras que Harbor Operator sacrifica completamente la flexibilidad para lograr la máxima reducción de carga mental, haciendo que el desarrollo del Operator sea más como declarar una configuración de software.

Escribir un operator manualmente con client-go, debido a la falta de genéricos en Golang, es casi un castigo. Todo el proyecto estaría plagado de una enorme cantidad de código boilerplate (código repetitivo). Creo que incluso si alguien realmente escribiera manualmente con client-go, nadie empezaría realmente desde cero.

Así surgió kubebuilder, que abstrae operaciones como la creación del cliente de Kubernetes, la escucha de solicitudes del API Server de Kubernetes y la puesta en cola de solicitudes en bibliotecas comunes controller runtime y herramientas comunes controller tools, y puede generar código de andamiaje para que los desarrolladores se centren en el desarrollo de la lógica empresarial que maneja los cambios en los objetos API.

Kubebuilder aún deja un espacio para la diversidad de la lógica empresarial, mientras que Harbor Operator, sobre esta base, busca aún más el extremo, sacrificando completamente la flexibilidad para perseguir la consistencia y simplicidad conceptual, y el negocio al que se enfrenta es realmente muy adecuado para este enfoque.

Por lo tanto, en esta lectura de código fuente, nuestro objetivo principal es aprender cómo Harbor Operator:

-   Realiza operaciones de Día 1.
-   Reduce aún más la redundancia del código del operator, utilizando el mismo código de Controller para implementar el Controller de once CRDs de diferentes niveles.
-   Utiliza DAG para resolver las dependencias entre recursos. El autor parece haber solicitado una patente para esto.

Además, no nos centraremos en estudiar:

-   Las operaciones de Día 2 en Harbor Operator; de hecho, en la versión actual esta funcionalidad aún no es estable.
-   El código fuente y las funciones del propio Harbor.

<a id="org345a335"></a>

## Lectura del Código Fuente

<a id="org1198d5f"></a>

### Estructura Estática

<a id="orgb32de77"></a>

#### Estructura de Directorios

Aquí solo se enumeran los directorios.

```
    root
    ├── apis
    │   ├── goharbor.io
    │   │   └── v1alpha3
    │   └── meta
    │       └── v1alpha1
    ├── controllers
    │   ├── controller_string.go
    │   ├── controllers.go
    │   └── goharbor
    │       ├── chartmuseum
    │       ├── controller_test.go
    │       ├── core
    │       ├── exporter
    │       ├── harbor
    │       ├── harborcluster
    │       ├── internal
    │       ├── jobservice
    │       ├── notaryserver
    │       ├── notarysigner
    │       ├── portal
    │       ├── registry
    │       ├── registryctl
    │       └── trivy
    ├── pkg
    │   ├── builder
    │   ├── cluster
    │   │   ├── controllers
    │   │   │   ├── cache
    │   │   │   ├── common
    │   │   │   ├── database
    │   │   │   │   └── api
    │   │   │   ├── harbor
    │   │   │   └── storage
    │   │   ├── gos
    │   │   ├── k8s
    │   │   └── lcm
    │   ├── config
    │   │   ├── harbor
    │   │   └── template
    │   ├── controller
    │   │   ├── errors
    │   │   ├── internal
    │   │   │   └── graph
    │   │   └── mutation
    │   ├── event-filter
    │   ├── exit
    │   ├── factories
    │   │   ├── application
    │   │   ├── logger
    │   │   └── owner
    │   ├── graph
    │   ├── harbor
    │   ├── image
    │   ├── manager
    │   ├── resources
    │   │   ├── checksum
    │   │   └── statuscheck
    │   ├── scheme
    │   ├── setup
    │   ├── status
    │   ├── template
    │   ├── tracing
    │   ├── utils
    │   │   └── strings
    │   └── version
    ...
```

<a id="orgfc0f08e"></a>

#### Interfaces Clave

![img](https://0xc1.space/images/2022/01/30/harbor-operator-class.svg)

<a id="org290c6c2"></a>

#### Arquitectura del Sistema

Hasta la versión v1.0.1, Harbor Operator se encarga principalmente de las operaciones de Día 1 del sistema Harbor.
![img](https://0xc1.space/images/2022/01/30/harbor-operator-arch.png)

<a id="org41c8944"></a>

### Enfocarse en lo Grande y Dejar lo Pequeño: HarborCluster

Primero, filtremos algunas partes no tan críticas: la definición del CRD HarborCluster y la implementación de su Controller.

¿Por qué es especial? Primero, observemos su posición en la arquitectura del sistema: está en el nivel más alto, gestiona el propio sistema Harbor y todos los servicios con estado de los que depende. Esto debe explicarse desde dos aspectos: la historia del proyecto y su posición especial en la arquitectura del sistema.

Desde la perspectiva de la arquitectura del sistema, este CRD HarborCluster es extremadamente similar en definición al CRD Harbor, con una gran cantidad de redundancia de código, lo que no se ve bien. Esto se debe a que, como el CRD más externo (superior) de todo el sistema, está orientado directamente al usuario; debe poder proporcionar al usuario todas las configuraciones necesarias para declarar la implementación de Harbor. Además, dado que Harbor es en sí mismo un conjunto de servicios sin estado, una implementación completa también requiere que el CRD HarborCluster gestione todos los servicios con estado de los que depende Harbor, incluidos Postgres, Minio y Redis.

Y la información necesaria del propio sistema Harbor ya está definida en el CRD Harbor, por lo que la parte redundante en el CRD HarborCluster es transmitir esta información completa y correctamente al CRD Harbor; además, el CRD HarborCluster también necesita gestionar los CRDs de esos servicios con estado que están fuera de los límites de su propia responsabilidad, por lo que no puede utilizar completamente la lógica del Controller en Harbor y todos sus subcomponentes.

Desde una perspectiva histórica, Harbor Operator fue originalmente un proyecto privado de OVH Cloud, que luego fue donado a la comunidad goharbor. Por lo tanto, observando el historial de git, la razón por la cual la definición del CRD HarborCluster y la implementación de su Controller tienen tanta inconsistencia con otros Controllers en el sistema es que fue un contribuyente posterior de la comunidad, y el diseño inicial de Harbor Operator no consideró las funciones que debía asumir.

Y la implementación del propio HarborCluster Controller no es muy diferente de la mayoría de los Controllers implementados con Controller-runtime que solemos ver, por lo que no se estudiará en detalle.

---

HarborCluster Controller

![img](https://0xc1.space/images/2022/01/30/harbor-cluster-controller.png)

---

Harbor Core Controller

![img](https://0xc1.space/images/2022/01/30/harbor-core-controller.png)

---

<a id="orgd9c3526"></a>

### Resolver las Dependencias entre Recursos: Dependency Graph

El grafo de dependencias es un módulo relativamente independiente en todo el proyecto, pero en realidad actúa como el motor de ejecución de todos los controllers en Harbor Operator. Esencialmente, observa que varios tipos de recursos en Kubernetes tienen dependencias mutuas; el despliegue y reconciliación de algunos recursos depende del despliegue y reconciliación de otros, por ejemplo, un Deployment puede depender de un Configmap; eventualmente, estas relaciones de dependencia forman un grafo de dependencias, que en realidad debería ser un DAG. Aquí necesitamos definir la interfaz de la siguiente manera:

```go
    package graph

    type Resource interface{}

    type RunFunc func(context.Context, Resource) error

    type Manager interface {
            Run(ctx context.Context) error
            AddResource(ctx context.Context, resource Resource, blockers []Resource, run RunFunc) error
    }

    type resourceManager struct {
       resources map[Resource][]Resource
       functions map[Resource]RunFunc

       lock sync.Mutex
    }
```

-   Donde `Resource` define un recurso abstracto. Dado que este módulo no se preocupa por lo que representa exactamente un recurso, y para mantener la máxima flexibilidad dentro de las limitaciones expresivas del lenguaje, se utiliza el tipo superior `interface{}`.
-   `RunFunc` es responsable de manejar específicamente cómo operar sobre un `Resource`. Aquí, `RunFunc` enfrenta un problema de seguridad de tipos: `interface{}` significa que el compilador no sabe nada sobre este tipo y no puede hacer nada, pero `RunFunc` debe tomar este tipo que puede ser cualquier cosa y hacer algo con él. Por lo tanto, creemos que debe realizar una conversión de tipo forzada. Si cada `RunFunc` de recurso tuviera que convertir manualmente a un tipo específico, sería muy aburrido y repulsivo; más adelante observaremos cómo Harbor Operator centraliza este trabajo sucio en un solo lugar.
-   `Manager` solo tiene dos métodos: agregar un `Resource` y ejecutar este grafo. Necesitamos estudiarlos por separado.
-   La definición de la estructura de datos `resourceManager` que implementa `Manager` también es simple:
    -   Un mapa `resource -> blockers`
    -   Un mapa `resource -> runFunc`
    -   Un `lock` para manejar la concurrencia de las operaciones en el mapa. Desde aquí podemos ver que al autor no le gustan las estructuras de datos como `Sync.Map` que garantizan seguridad concurrente pero pierden seguridad de tipos, lo que hace que sea aún más curioso cómo maneja el autor tantos (11 componentes) `RunFunc`.

Dado que es un `Graph`, debe haber una estructura de datos para el `Graph` y un método de fábrica para construir este `Graph`. La estructura de datos de `resourceManager` parece un poco rígida, no estoy seguro de si es el `Graph` real.

<a id="org75cbb07"></a>

#### AddResource

Según la firma, se puede observar que `AddResource` agrega el recurso en sí que necesita ser agregado, todas sus dependencias y la `runFunc` correspondiente. Vale la pena señalar que primero se deben agregar los recursos que no dependen de ningún recurso (es decir, con grado de salida 0).

```go
    func (rm *resourceManager) AddResource(ctx context.Context, resource Resource, blockers []Resource, run RunFunc) error {
       if resource == nil {
          return nil
       }

       if run