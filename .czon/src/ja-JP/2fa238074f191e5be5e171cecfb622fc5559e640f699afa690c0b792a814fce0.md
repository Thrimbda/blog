---
"title": "オブザーバーパターン実力分析"
"summary": "本稿ではまず、オブザーバーパターン（別名：公開-購読パターン）の基本概念、GoFによる定義、および実世界での応用例（RSS購読など）を紹介します。続いて、オブザーバーパターンの参加者（Subject、Observer、ConcreteSubject、ConcreteObserver）と適用場面（オブジェクト間に依存関係が存在する場合、あるオブジェクトの変更に伴って他のオブジェクトも同時に変更する必要がある場合）について詳しく説明します。その後、J2EEにおけるActionとActionListenerを例に、具体的なJava Swingコードの実例を通じて、オブザーバーパターンがMVCパラダイムにおいてモデルとビューの結合度を低下させるためにどのように適用されるかを示します。本稿では、通常の関数呼び出しやコールバック関数と比較して、オブザーバーパターンがオブジェクト間の一貫性を低コストで維持し、ブロードキャスト効果を実現し、コードの再利用性を大幅に向上させることを指摘します。"
"tags":
  - "デザインパターン"
  - "システム分析と設計"
  - "オブザーバーパターン"
  - "J2EE"
  - "ActionListener"
  - "MVC"
  - "Java"
  - "結合度"
"date": "2017-04-10"
---

---
title: オブザーバーパターン実力分析
date: 2017-04-10
taxonomies:
  tags:
    - デザインパターン
    - システム分析と設計
---

> 一般的に、オブジェクト指向分析と設計には、通常の関数呼び出しの他に、コールバック関数がよく用いられる3つのイベント処理メカニズムが存在します。また、J2EEではリスナーベースのイベント処理メカニズムも提供されています。資料を調査し、ActionおよびActionListenerのメカニズムを分析し、分析実例を完成させてください。

まず、オブザーバーパターンについて理解します。

<!--more-->

## オブザーバーパターン (Observer Pattern)

### 実世界におけるオブザーバー

オブザーバーパターンは、公開-購読パターンとも呼ばれます。例えば、RSS（WeChatプッシュの元祖）購読では、あるブログ（被観測者）の運営者が記事を更新すると、購読者のリーダー（観測者）は自動的に更新を受け取ることができます。この公開-購読の仕組みを、オブザーバーパターンと呼びます。

### オブザーバーパターン

(**G**ang **O**f **F**our) によるオブザーバーパターンの記述：

> - 意図
>
>   オブジェクト間の一対多の依存関係を定義し、あるオブジェクトの状態が変化したときに、それに依存するすべてのオブジェクトに通知が届き、自動的に更新されるようにします。
>
> - 別名
>
>   依存(Dependents)、公開-購読(Publish-Subscribe)
>
> - 動機
>
>   システムを一連の相互に協調するクラスに分割する際、一般的な副作用として、関連するオブジェクト間の一貫性を維持する必要が生じます。一貫性を維持するためにクラス間を密結合にすることは望ましくありません。なぜなら、それは再利用性を低下させるからです。
>
> ...
>
> - 参加者
>
>   - Subject（目標）
>
>     目標は自身の観測者を知っています。任意の数の観測者が同一の目標を観測できます。
>
>     観測者オブジェクトの登録と削除のインターフェースを提供します。
>
>   - Observer（観測者）
>
>     目標が変化したときに通知を受け取る必要があるオブジェクトに対して、更新インターフェースを定義します。
>
>   - ConcreteSubject（具体目標）
>
>     関連する状態を各ConcreteObserverオブジェクトに保存します。
>
>     自身の状態が変化したとき、その各観測者に通知します。
>
>   - ConcreteObserver（具体観測者）
>
>     ConcreteSubjectオブジェクトへの参照を保持します。
>
>     関連する状態を保存します。この状態は目標の状態と一致している必要があります。
>
>     Observerの更新インターフェースを実装し、自身の状態を目標の状態と一致させます。

オブザーバーパターンは、以下のような場面でよく適用されることがわかります：

- 2つのオブジェクトが依存関係にある場合。
- あるオブジェクトを変更する際に、他のオブジェクトも同時に変更する必要がある場合。

通常の関数呼び出しやコールバック関数と比較して、オブザーバーパターンの使用は、オブジェクト間の一貫性を低コストで維持し、**オブジェクト間の結合度を大幅に低下させ、同時にブロードキャスト効果を達成することができます。これは前者2つでは実現できません。オブザーバーパターンの使用は、コードの再利用性を大幅に向上させます。**

**そして、J2EEにおけるActionとActionListenerは、まさにオブザーバーパターンの生きた例です。**

## J2EEにおけるAction&ActionListener

Action&ActionListenerは、MVCパラダイムにおいてモデルとビューの結合度を低下させるために非常にうまく適用できます。

非常に良い[例](http://www.ulisespulido.com/2009/03/observer-design-pattern-and-java-swing.html)を見つけました。コードは以下の通りです：

```java
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JTextField;

public class Frame extends JFrame {

  ActionListener observer1 = new Observer("First Observer");
  ActionListener observer2 = new Observer("Second Observer");
  ActionListener observer3 = new Observer("Third Observer");

  public Frame(){
    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    init();
  }

  private void init(){
    addChangingTextField();
    pack();
    setVisible(true);
  }

  private void addChangingTextField(){
    //Observable class TextField. each time
    //An action or event occurs the observers will be updated
    //Almost all the Swing classes has this kind of behavior
    JTextField dataTextField = new JTextField();

    // Observer registering to the observable class.
    dataTextField.addActionListener(observer1);
    dataTextField.addActionListener(observer2);
    dataTextField.addActionListener(observer3);

    add(dataTextField);
  }

  public static void main(String [] args){
  	Frame frame = new Frame();
  }
}

class Observer implements ActionListener{

  private String name;
  private String message;

  public Observer (String s){
  	name = s;
  }

  public void actionPerformed(ActionEvent e) {
    JTextField textField = (JTextField) e.getSource();
    message = textField.getText();
    JOptionPane.showMessageDialog(null,
    name + " has been confirmed about the change, Thanks!! "
    + " The Message was: " + message);
  }
}
```

### 分析

2つのクラスはそれぞれAction/ActionListenerの役割を担っています。`frame.dataTextField`は`addChangingTextField`メソッド内で3つのリスナー（`observer1`, `observer2`, `observer3`）をバインドしています。フレーム内のテキストフィールドが編集されると（状態が変化）、Observer内の`actionPerformed`メソッドがトリガーされ、対応するテキストが表示されます。

この例では、`frame.dataTextField`が`ConcreteSubject`として、`observer1`, `observer2`, `observer3`が`ConcreteObserver`として機能しています。そして、それらが実装しているAction/ActionListenerメソッドを定義したインターフェースが、それぞれ`Subject`と`Observer`に対応します。

観測者をバインドした後、目標は観測者の具体的な動作を気にせず、自身の状態が変化したときに観測者に通知するだけです。観測者は自身でどのような動作を行うかを決定します。したがって、この方法は非常に優れており、関数を明示的に呼び出したり、コールバック関数を実行して動作をトリガーする方法よりもはるかに優れており、学ぶ価値があります。