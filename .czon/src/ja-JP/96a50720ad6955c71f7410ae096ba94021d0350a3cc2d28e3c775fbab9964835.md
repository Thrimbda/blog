---
"title": "Zolaブログ向けリアルタイム編集とGitHubバックエンド統合ソリューション設計"
"summary": "本ドキュメントでは、既存のCSSデザインを損なうことなくZolaブログにリアルタイムMarkdown編集可能なWYSIWYGエディタと「バックエンド手書き不要」の統合ソリューションを設計する詳細な計画を説明します。既存のビジュアル言語の維持、バックエンド手書きの極力回避、リアルタイムプレビューと自動保存のサポートなどを含む設計原則を明確化しています。現状監査を通じて、プロジェクトがZolaサイト（Node/Reactビルドチェーンなし）であり、コンテンツソースがMarkdownファイルであることを確認しました。候補ソリューションの中では、主案としてD案：純JS /admin + Vditor + GitHub Device Flow + PR公開を推奨します。これにより、自前バックエンド不要、GitHubを信頼できる情報源として、下書きはローカルキャッシュのみ、画像はリポジトリに保存する完全なフローを実現します。本ドキュメントは、セキュリティリスク、スコープ定義、フェーズ概要も網羅し、最終的な推奨実装手順はデフォルトの前提に基づき、ソリューションの実現可能性とユーザー嗜好への適合を保証します。"
"tags":
  - "Zola"
  - "Markdown"
  - "WYSIWYG"
  - "GitHub"
  - "リアルタイム編集"
  - "バックエンド不要"
  - "フロントエンド開発"
  - "ブログ最適化"
"date": "2026-01-06"
---

# Zola ブログ：WYSIWYG Markdown リアルタイム編集 + Supabase/GitHub バックエンドソリューション設計

## 目標

現在の Zola ブログにおいて、既存の CSS デザインスタイルを損なうことなく、リアルタイムで Markdown を編集可能な WYSIWYG エディタと「バックエンド手書き不要」(Supabase または GitHub Issue/Discussion) の統合ソリューションを設計・計画します。

## 設計原則（必須遵守事項）

- 既存の suCSS + CSS 変数によるビジュアル言語（ライト/ダークテーマ切替を含む）を維持する
- バックエンドの手書き導入は極力避け、フロントエンドから直接 Supabase または GitHub API に接続することを優先する
- React/shadcn が必要な場合は、ビルドチェーン導入の理由、コスト、ロールバック案を提示すること
- 編集体験はリアルタイムプレビュー/レンダリングと自動保存（少なくとも下書き）をサポートすること
- コンテンツを Zola に公開する同期パスを明確化する（既存の content 構造を破壊しない）

## 現状概要（監査より）

- 本プロジェクトは Zola サイト（Node/React ビルドチェーンなし）であり、全サイトの CSS/JS は `static/` を経由し、`templates/head.html` で CDN 依存関係を導入可能です。
- テーマ/色は完全に `static/css/suCSS.css` の CSS 変数によって制御されています。JS は `data-theme` を通じてライト/ダークを切替えます（`static/js/script.js`）。
- コンテンツソースは `content/**` の Markdown ファイルです。YAML フロントマター（`---`）と Zola ショートコード（例：`{{ slideshow(...) }}`）を含みます。

## レビューが必要な不確定点（回答/選択してください）

1.  **編集範囲**：特定の1つまたは少数のファイル（例：`content/gcores-talks.md`）のみを編集できればよいですか、それとも「任意の `content/**` ページを編集可能」にしたいですか？
2.  **リアルタイム編集**：あなたの言う「リアルタイム」とは：
    - A) エディタ内でのリアルタイムプレビュー/レンダリングのみでよい（単一ユーザー）
    - B) バックグラウンドでの下書き自動保存が必要（単一ユーザー）
    - C) 複数人での共同編集/同時編集が必要（マルチユーザー）
3.  **公開連携**：編集結果は最終的にサイトにどのように反映させたいですか？
    - A) 下書きライブラリとして保存のみ（自動的に `content/` に入らない）
    - B) ワンクリック公開：自動的にリポジトリの `content/` に同期し、Zola ビルドをトリガーする
    - C) 半自動：ファイルをエクスポート/パッチを生成し、手動でコミットする
4.  **認証**：admin はあなた自身のみが使用します。「Supabase email magic link + 許可リストによる単一ユーザー」を受け入れますか？
5.  **画像**：エディタ内で直接画像をアップロードする必要がありますか？ 必要であれば、画像を Supabase Storage に保存し、Markdown から外部リンクとして参照することは受け入れますか？

> [REVIEW]
> 1.  任意のファイルを編集し、何らかの方法で github リポジトリにコミットしたい。バックエンドが必要な場合は、その必要性を論証すること。
> 2.  A と B
> 3.  B
> 4.  このバージョンは自分だけが使うので、admin であれば十分。セキュリティが保証されていればよい。楕円曲線鍵ペアを持ち、ssh のようにその鍵ペアで認証することも受け入れられる。
> 5.  画像アップロードが必要で、画像はリポジトリに保存したい。
>
> [RESPONSE] 承知しました。あなたの回答に基づき、デフォルトの前提/ソリューション指向を以下のように調整します：
>
> 1)  編集範囲：「任意の `content/**` ファイルを編集可能」に変更します（将来的には `templates/**` などにも拡張可能ですが、MVPではリスク低減のため `content/**` に限定します）。公開パスは「GitHub リポジトリへの書き戻し」を中核目標とします。Supabase を信頼できる情報源としては使用しません。
>
> 2)  リアルタイム編集：A + B を選択 —— エディタ内でのリアルタイムレンダリング/プレビュー + 自動保存（下書き）。
>
> 3)  公開連携：B を選択 —— 編集結果をワンクリックで GitHub にコミットします（レビュー/ロールバックのため、直接 master に push するのではなく PR 経由にすることを推奨します。直推を希望される場合はオプションとしても実装可能です）。
>
> 4)  認証：MVP はあなた自身のみが使用します。「ssh のような楕円曲線鍵ペア」という方向性は、ローカル認証情報の保護（例：あなたの秘密鍵で IndexedDB に保存された GitHub トークンを復号化する、またはアンロックステップとして使用する）として活用できます。しかし、GitHub への実際の書き込みには GitHub 認可トークンが必要です。「バックエンド手書きを極力避ける」という要件を満たすため、純フロントエンドで認可を完了できる GitHub OAuth *device flow*（`client_secret` に依存しない）を使用し、取得したトークンはローカルのみに保存し、あなたの秘密鍵で二次暗号化可能とする方向を提案します。
>
> 5)  画像：あなたの希望通り、画像もリポジトリに保存します（例：`static/images/uploads/...` に書き込み、Markdown から `/images/uploads/...` を参照）。アップロード実装としては「同じ GitHub トークンを使用して API 経由で blob/commit を作成する」ことで、追加のバックエンドは不要です。
>
> 次のステップとして、plan 内の「デフォルト推奨 A(Supabase を信頼できる情報源とする)」を「GitHub を信頼できる情報源 + Discussions/Issues による下書き保存 + PR 公開」に変更し、設計にトークン保存/暗号化と画像リポジトリ書き込みの詳細と制限（単一ファイルサイズ、頻繁な自動保存時のコミット戦略など）を追加します。
> [STATUS:resolved]

> [REVIEW] 可能であれば device flow は受け入れられます。そうすれば鍵ペアは不要で、自分のデバイスを信頼できます。
>
> [RESPONSE] OK、device flow を受け入れる前提で、「楕円曲線鍵ペア」を MVP から削除できます：
> - GitHub OAuth device flow を使用してリポジトリ書き込み用のアクセストークンを取得します
> - トークンはローカル（IndexedDB/localStorage）にのみ保存し、あなたが自分のデバイスを信頼すれば十分です
> - 将来的に「二次アンロック/ローカルの傍受者対策」が必要になった場合、鍵ペア/OS Keychain を v2 のオプション拡張として追加できます
> [STATUS:resolved]

## 候補ソリューション（高レベルアーキテクチャ）

### 案 D（現在の実装 / 主案）：純 JS `/admin` + Vditor + GitHub Device Flow + PR 公開

-   **フロントエンド**：`static/admin/*` 静的ページ。既存の `reset.css`/`suCSS.css`/`style.css` と `static/js/script.js` のテーマ切替を再利用（デザイン言語の一貫性を維持）。
-   **エディタ**：Vditor（デフォルト IR）。本文編集とフロントマター編集を分離（WYSIWYG による破壊を回避）。
-   **認証**：GitHub OAuth **device flow**（`client_secret` 不要、自前のトークン交換バックエンド不要）。トークンはローカルの IndexedDB にのみ保存。
-   **下書き**：ローカル自動保存（IndexedDB）のみ。デバイス間同期なし、Git commit ノイズを発生させません。
-   **公開**：公開時にブランチ作成 + PR、一度の書き込みで以下をコミット：
    -   `content/**.md`（フロントマター + 本文を結合）
    -   `static/images/uploads/**`（画像挿入時に pending assets として登録し、公開時にまとめてコミット）

長所：自前バックエンドが完全に不要。「信頼できる情報源」は GitHub リポジトリそのものです。あなたの嗜好と一致します。
リスク：エディタがショートコード/フロントマター（特に `{{ ... }}` を含むページ）を「忠実に」扱えるか検証が必要。GitHub API の権限範囲（scope）を制御する必要があります。

### 案 A（オプション）：純 JS `/admin` + Vditor + Supabase（下書き/デバイス間同期のみ）

将来「デバイス間での下書き同期/共同編集」が必要になった場合のみ導入。信頼できる情報源としては使用しません。

### 案 B（オプション）：純 JS `/admin` + TOAST UI Editor

TOAST UI の編集体験をより好む場合、エディタを置き換え可能（追加のテーマ上書きコストが必要）。

### 案 C（オプション）：React `/admin`（Vite）+ shadcn UI + Milkdown/TipTap

より複雑な UI/インタラクション（アセット管理、拡張ブロックなど）が必要な場合に適しています。代償：Node ビルドチェーンの導入が必要。既存の suCSS 変数への厳密なマッピングが必要で、スタイルの乖離を避ける必要があります。

> [REVIEW] D案が良いソリューションだと思います。バックエンドが不要で、状態はすべて github 上にあります。oauth provider の導入は受け入れられます。現在のコメントシステムも同様の方法で実装しています。確認してみてください。もしどうしても supabase を導入する必要があるなら、それは下書き保存のみに使用し、信頼できる情報源としては使用しないべきです。
>
> [RESPONSE] あなたの方向性に同意します：GitHub（Issues/Discussions + リポジトリ）を「状態はすべて GitHub 上にある」主ストレージとする方が、あなたの嗜好に合致します。Supabase を導入する場合でも、「オプションの下書き/キャッシュ」に格下げし、システムの信頼できる情報源としては使用しません。
>
> 誤った方向に進まないよう、2点確認が必要です：
>
> 1)  **OAuth 形態**：あなたが「oauth provider の導入は受け入れられる（コメントシステムも同様）」と述べています。コメントシステム giscus の書き込みは、GitHub App/サーバーサイドによるトークン交換と署名によって行われています。もし我々も従来の web OAuth flow を採用する場合、`client_secret` の秘匿が関わり、通常は信頼できるバックエンド/関数によるトークン交換が必要です。「バックエンド手書き不要」を満たすため、GitHub OAuth *device flow* をより推奨します：純フロントエンドで認可を完了できます（バックエンドによる `client_secret` の保管が不要です）。あなたは device flow を「oauth provider」の代替として受け入れますか？
>
> 2)  **下書きの保存先**：
>     - D1) GitHub Discussions：各ページに対応する discussion を作成し、下書きは discussion の本文とします。公開時に PR を生成して `content/**` に書き込みます。
>     - D2) GitHub Issues：同様ですが、issues はよりタスク指向です。
>     - D3) リポジトリの `drafts` ブランチ：自動保存で直接ファイルを更新します（多くのコミットが発生するため、マージ/圧縮戦略が必要です）。
>     あなたは D1/D2/D3 のどれを好みますか？
>
> あなたの確認後、「GitHub を信頼できる情報源とする + 下書き戦略 + PR 公開戦略 + 画像コミット戦略 + セキュリティモデル（トークンのローカル保存/オプションの秘密鍵暗号化）」を実現可能な実装手順として完成させます。
> [STATUS:need-info]
>
> [RESPONSE] 同意し、あなたの最新の確認に基づき収束を完了しました：
> - 案 D（GitHub を主ストレージとする）を主案としますが、「oauth provider + バックエンドによるトークン交換」は不要となり、**device flow** を使用します。
> - Supabase は主パスから削除します（将来的にデバイス間下書き/共同編集が必要になった場合、オプションコンポーネントとして追加可能）。
>
> 実装の意味合い（確認用）：
> - `下書き/自動保存`：ローカルキャッシュへの書き込みのみ。Git commit を発生させません。「一文字打つごとに commit/PR ノイズが発生する」ことを避けます。
> - `公開`：指定された `content/**` ファイル + 画像変更を一度にまとめて GitHub にコミットします（デフォルトでは PR 作成を推奨。master への直推も設定可能とします）。
>
> この収束方向に同意される場合、次のステップ（コード変更の許可後）でこれに基づいて実装します。
> [STATUS:resolved]

> [REVIEW] 1. device flow は受け入れられます。 2. フロントエンドのキャッシュでよいと思います。デバイス間同期の必要性は特にないので、複雑にしないでください。
>
> [RESPONSE] 確認を受け取りました：
> 1) OAuth：GitHub device flow を採用します（`client_secret` への依存なし、自前のトークン交換バックエンド不要）。
> 2) 下書き：フロントエンドのローカルキャッシュのみとします（IndexedDB を主とし、localStorage をフォールバック/小データ用）。デバイス間同期は行いません。
>
> これに基づき、全体設計を以下のように収束させます：
> -   **信頼できる情報源（公開済み）**：GitHub リポジトリ `content/**`（PR/push 経由で書き戻し）
> -   **下書き（下書き/自動保存）**：ローカルキャッシュ（Supabase/GitHub Discussions/Issues 不要）
> -   **画像**：公開時にリポジトリにまとめて書き込み（例：`static/images/uploads/...`）、Markdown ではサイト内パス