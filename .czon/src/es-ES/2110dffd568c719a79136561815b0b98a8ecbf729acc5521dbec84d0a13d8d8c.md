---
"title": "Diario de Prácticas (II): Resumen del Desarrollo del Servidor API Backend"
"summary": "Este artículo es un diario de resumen del autor como líder de proyecto desarrollando un servidor API backend durante su período de prácticas. El artículo detalla el proceso de diseño del proyecto 'Seed' (un sistema de gestión de objetivos centrado en una mini-app de WeChat), incluyendo la definición clara del posicionamiento del producto, las características del sistema (como sistema de usuarios, gestión de objetivos, compatibilidad con WeChat) y la arquitectura API RESTful. En cuanto a la implementación, el autor eligió el ecosistema Spring como stack tecnológico y comparte prácticas de desarrollo guiado por pruebas durante el proceso. El artículo también reflexiona sobre las deficiencias como gestor de proyecto en el control del progreso, asignación de personal y formación técnica, y discute el equilibrio necesario entre la capacidad de arquitectura de sistemas y la capacidad de implementación de algoritmos que debe tener un ingeniero de software. Finalmente, el autor considera que las prácticas son un complemento efectivo a las carencias de la educación en el aula, ayudando a evitar la contradicción entre calificaciones y competencias."
"tags":
  - "Prácticas"
  - "Desarrollo Backend"
  - "Gestión de Proyectos"
  - "Framework Spring"
  - "Mini-app de WeChat"
  - "API RESTful"
  - "Diseño de Software"
  - "Resumen de Aprendizaje"
"date": "2017-03-12"
---

---
title: Diario de Prácticas (II)
date: 2017-03-12 16:09:19
taxonomies:
  tags:
    - Cotidiano
    - Prácticas
    - Reflexiones
---

Las prácticas están llegando a su fin, y hasta ahora el trabajo de codificación de la versión básica del servidor API backend está prácticamente terminado. Aquí hago un resumen.

Como líder del grupo del proyecto, mi único conocimiento sobre gestión de proyectos de software proviene de haber leído *The Mythical Man-Month* una vez durante las vacaciones de invierno. Tras esta práctica, me doy cuenta de que aún soy muy inexperto. Sin embargo, creo que he aprendido algunas cosas.

<!--more-->

## Diseño

Comparado con hace dos años, cuando empezaba a escribir tareas en C sin pensarlo y abría directamente VS, hoy en día he cambiado bastante.

~~En primer lugar, hace mucho que no abro VS.~~

En resumen, estos dos años he pasado por la etapa de aprendizaje puro e inocente de Python, la experiencia de escribir el software de control para el robot en el equipo de robótica, la experiencia de escribir crawlers para el sitio web de la oficina académica (tanto para profesores como para estudiantes), y el proceso de escribir la herramienta de gestión de archivos durante el proyecto Orange Juice, que fueron períodos intensivos de escritura de código. Al principio, por supuesto, me lancé sin pensar, pero supongo que después de sufrir las consecuencias de las contradicciones, uno aprende a diseñar con antelación. Una vez dentro del mundo del diseño, el siguiente paso es una cuestión de grado; por lo tanto, esta experiencia de gestionar todo el proyecto ha sido un ejercicio muy beneficioso.

**Primero, aclarar qué se quiere hacer**. Esta pregunta es crucial para un equipo que realmente quiere crear un producto: **definir su propio producto** es algo estratégico. Sin embargo, lamentablemente, esta vez no hubo ideas interesantes, y con la responsabilidad sobre mis hombros, mi expectativa para estas prácticas era hacer un proyecto serio, confiable y sencillo.

En resumen, se trata de una **aplicación web tradicional con una mini-app de WeChat como característica principal**; concretamente, un sistema de gestión de objetivos.

Hay mucha gente que hace esto, por lo que el modelado de las tareas a enfrentar puede basarse en muchas soluciones maduras: como Worktile, orientado a proyectos; WonderList, orientado a la gestión personal de la vida; My Study Life, orientado a estudiantes; incluso incluyendo los `Recordatorios` de Apple y otras herramientas que he oído pero no he usado. Sintetizando las características de estas herramientas, se resume en un clásico sistema de gestión de objetivos con características de WeChat, que se convirtió en nuestro `Seed`.

### Características que debería tener

Entonces, ¿qué debería poder hacer `Seed`?

+ Tener un sistema de usuarios simple, para facilitar la sincronización y aumentar la fidelidad del usuario.
+ Los usuarios pueden crear y gestionar libremente objetivos, similares a los `proyectos` de Worktile.
+ Los usuarios pueden ser invitados a los objetivos de otros.
+ Los objetivos se dividen en tipo check-in diario (recurrente) y tipo proyecto (único, pueden incluir hitos).
+ El frontend principal es la mini-app de WeChat.
+ También es compatible con otros clientes potenciales.

De esto se deduce que `Seed` debería ser un servicio práctico, pequeño y refinado, lo que coincide con el propósito original de las mini-apps de WeChat.

Aquí es necesario enfatizar la característica de **"pequeño y refinado"**. ¿Por qué pequeño y simple? Primero, porque no hay suficiente personal y el tiempo es limitado. Segundo, para evitar el error que menciona *The Mythical Man-Month* que suelen cometer los `segundos proyectos`: arrogancia ciega, añadiendo locamente infinitas redundancias a un proyecto. Esto es algo estúpido que no merece la pena, especialmente porque no involucramos ingresos por publicidad. Un ejemplo simple: la versión de Mac OS de Xunlei y la versión de Win de Xunlei, obviamente a todos les gusta más la versión Mac, refinada y práctica.

También debe tener una buena compatibilidad con las mini-apps de WeChat. Para proporcionar una buena fluidez en la experiencia del usuario, debería admitir tanto el email como nombre de usuario para iniciar sesión, como el openId de WeChat como credencial de acceso.

### Estructura del sistema

Como se mencionó anteriormente, queremos hacer una aplicación web con la mini-app de WeChat como característica principal, lo que significa que `Seed` tiene la capacidad ~~y la ambición~~ de ser compatible con otros frontends. Por lo tanto, una API de estilo RESTful se convierte en la mejor opción: frontend y backend completamente desacoplados, estructura clara, fácil de consumir.

Por lo tanto, `Seed` debería ser un sistema donde la mini-app de WeChat y otras formas potenciales actúen como frontend, consumiendo los `recursos` proporcionados por el backend a través del protocolo HTTP.

El backend proporciona servicios seguros y confiables a través de la API.

Para ello también he aprendido algo, conociendo la idea de HATEOAS (Hypermedia As The Engine Of Application State) (hipermedia como motor del estado de la aplicación), aunque inmadura, es un posible futuro.

## Implementación

Dado que solo participé en el trabajo de codificación del servidor API, aquí solo hablaré de la implementación del backend.

Me gusta clasificar el diseño en el nivel estratégico (el "dao"), y el resto del trabajo en el nivel táctico (el "shu"). Por lo tanto, la elección de la tecnología y cómo implementar concretamente un sistema pueden incluirse aquí.

### Tecnología

Debido a los requisitos de las prácticas, y también por el deseo de usar el lenguaje Java de manera razonable, elegí `Spring Framework` como framework backend, utilizando además todo el ecosistema Spring:

+ Spring Boot como contenedor de aplicaciones
+ Spring Framework para implementar la lógica de negocio
+ Spring Data como DAO
+ Spring Session para gestionar sesiones
+ Spring test para pruebas

Además, utilicé herramientas como Git, TravisCi, Heroku, etc., para mejorar la experiencia de desarrollo.

### Proceso de desarrollo

Como mencioné antes, la experiencia de escribir Controllers en Spring es muy similar a la del framework web Flask de Python. ¿Quizás Flask tomó alguna inspiración de Spring? Creo que las clases controladoras orientadas a recursos son mucho más compactas que la forma tradicional de Java Web, donde hay que escribir un Servlet para cada recurso.

Spring promueve el desarrollo guiado por pruebas (TDD), y hacerlo realmente no es fácil, ya que las pruebas no suelen ser un trabajo popular. Si realmente asignas a una persona específica para escribir código de prueba, primero, el costo de aprendizaje es alto, y segundo, hay algunos problemas de relaciones personales. Por lo tanto, en el desarrollo decidí que cada persona fuera responsable de probar su propio código. Finalmente, yo revisaría el código.

## Resumen

Ya he hablado de las partes interesantes de `Seed` en sí. Ahora hablemos de otras cosas.

### Resumen sobre mí mismo

Aprendí mucho durante las prácticas, pero aún hay problemas.

Como gestor de proyecto, soy bastante novato. El control del progreso, la asignación de personal y otros detalles tienen muchas deficiencias.

Por ejemplo:

- La falta de conocimiento sobre tecnologías frontend hace que probablemente solo el servidor API funcione al final en este proyecto.
- Solo la mitad de las personas en el grupo del proyecto realmente participaron.
- La formación para los participantes fue vaga y careció de paciencia.

Obviamente, todavía necesito seguir practicando. Pero al mismo tiempo, ser tanto gestor de proyecto como desarrollador me llevó a reflexionar sobre otro problema.

### Discusión sobre las dos capacidades de un ingeniero de software

**La capacidad de arquitectura y control de todo el sistema** y **la capacidad de selección, adaptación e implementación de algoritmos para una función única**.

La educación en el aula de nuestra facultad de software parece centrarse solo en lo segundo, lo cual no es extraño, ya que el dominio de los algoritmos es fácil de medir; se puede decir que las diferencias en capacidad son evidentes, como resolver problemas matemáticos: bajo condiciones y restricciones estrictas, la creatividad de las personas es muy fácil de evaluar. Pero la capacidad de establecer razonablemente estas llamadas "condiciones y restricciones estrictas", aunque importante, es difícil de medir.

En cuanto a por qué digo que es contradictorio, pongo un ejemplo simple y comprensible, aunque quizás no muy apropiado: todos saben que es infantil e irreal que los padres prohíban a sus hijos tener relaciones tempranas con la excusa de que afecta los estudios, pero esperen que formen una familia inmediatamente después de graduarse. Esperar implícitamente que los estudiantes, **solo** con buenas calificaciones, se conviertan en personas completas después de graduarse también es una idea ligeramente distorsionada. La diferencia entre estos dos casos es que la contradicción en el segundo no es tan aguda como en el primero.

Creo que estas prácticas son efectivamente una compensación por las deficiencias de la educación en el aula, y tienen la oportunidad de evitar la contradicción entre los símbolos que representan **las calificaciones** como medio de formación y **las capacidades** como objetivo de formación.