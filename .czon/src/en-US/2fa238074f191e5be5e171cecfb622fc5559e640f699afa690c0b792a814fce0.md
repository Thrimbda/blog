---
"title": "In-Depth Analysis of the Observer Pattern"
"summary": "This article first introduces the basic concepts of the Observer pattern, including its definition, aliases, motivation, and participants, and points out that this pattern is commonly used to handle dependencies and state synchronization between objects. Through an example of Action and ActionListener in J2EE, the article demonstrates the practical application of the Observer pattern in reducing coupling between Model and View. In the example, JTextField serves as the concrete subject, while multiple ActionListeners act as concrete observers. When the text field's state changes, it automatically notifies the observers to perform corresponding actions. The article emphasizes that, compared to ordinary function calls and callback functions, the Observer pattern more effectively maintains consistency between objects and improves code reusability."
"tags":
  - "Design Patterns"
  - "Observer Pattern"
  - "J2EE"
  - "Action"
  - "ActionListener"
  - "System Analysis and Design"
  - "MVC"
  - "Coupling"
"date": "2017-04-10"
---

---
title: In-Depth Analysis of the Observer Pattern
date: 2017-04-10
taxonomies:
  tags:
    - Design Patterns
    - System Analysis and Design
---

> Generally, there are three mechanisms for event handling in object-oriented analysis and design: besides ordinary function calls, callback functions are often used. Additionally, J2EE provides an event handling mechanism based on listeners. Please research and analyze the mechanisms of Action and ActionListener, and complete an analysis example.

First, let's understand the Observer pattern.

<!--more-->

## Observer Pattern

### Observers in the Real World

The Observer pattern is also known as the Publish-Subscribe pattern. For example, in RSS (the predecessor of WeChat push notifications) subscriptions, when a blogger (the subject) updates their blog post, the subscribers' readers (observers) automatically receive the update. This publish-subscribe approach is what we call the Observer pattern.

### The Observer Pattern

The Gang of Four (GoF) describes the Observer pattern as follows:

> - **Intent**
>
>   Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.
>
> - **Also Known As**
>
>   Dependents, Publish-Subscribe
>
> - **Motivation**
>
>   A common side effect of partitioning a system into a collection of cooperating classes is the need to maintain consistency between related objects. You don't want to achieve consistency by making the classes tightly coupled, because that reduces their reusability.
>
> ...
>
> - **Participants**
>
>   - **Subject**
>
>     The subject knows its observers. Any number of observers may observe a subject.
>
>     Provides an interface for attaching and detaching observer objects.
>
>   - **Observer**
>
>     Defines an updating interface for objects that should be notified of changes in a subject.
>
>   - **ConcreteSubject**
>
>     Stores state of interest to ConcreteObserver objects.
>
>     Sends a notification to its observers when its state changes.
>
>   - **ConcreteObserver**
>
>     Maintains a reference to a ConcreteSubject object.
>
>     Stores state that should stay consistent with the subject's state.
>
>     Implements the Observer updating interface to keep its state consistent with the subject's state.

It can be observed that the Observer pattern is often applied in scenarios where:

- Two objects have a dependency relationship.
- When one object changes, other objects need to be updated simultaneously.

Compared to ordinary function calls and callback functions, the Observer pattern can maintain consistency between objects at a low cost, significantly **reducing the degree of coupling between objects while achieving a broadcast effect, which the former two cannot accomplish. The use of the Observer pattern greatly **improves code reusability**.

**Action and ActionListener in J2EE are a vivid example of the Observer pattern.**

## Action & ActionListener in J2EE

Action & ActionListener can be effectively applied in the MVC paradigm to reduce coupling between the model and view.

A great [example](http://www.ulisespulido.com/2009/03/observer-design-pattern-and-java-swing.html) is found, with the code shown below:

```java
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JTextField;

public class Frame extends JFrame {

  ActionListener observer1 = new Observer("First Observer");
  ActionListener observer2 = new Observer("Second Observer");
  ActionListener observer3 = new Observer("Third Observer");

  public Frame(){
    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    init();
  }

  private void init(){
    addChangingTextField();
    pack();
    setVisible(true);
  }

  private void addChangingTextField(){
    //Observable class TextField. each time
    //An action or event occurs the observers will be updated
    //Almost all the Swing classes has this kind of behavior
    JTextField dataTextField = new JTextField();

    // Observer registering to the observable class.
    dataTextField.addActionListener(observer1);
    dataTextField.addActionListener(observer2);
    dataTextField.addActionListener(observer3);

    add(dataTextField);
  }

  public static void main(String [] args){
  	Frame frame = new Frame();
  }
}

class Observer implements ActionListener{

  private String name;
  private String message;

  public Observer (String s){
  	name = s;
  }

  public void actionPerformed(ActionEvent e) {
    JTextField textField = (JTextField) e.getSource();
    message = textField.getText();
    JOptionPane.showMessageDialog(null,
    name + " has been confirmed about the change, Thanks!! "
    + " The Message was: " + message);
  }
}
```

### Analysis

The two classes respectively play the roles of Action/ActionListener. `frame.dataTextField` binds three listeners (`observer1`, `observer2`, `observer3`) in the `addChangingTextField` method. When the text field in the frame is edited (state changes), it triggers the `actionPerformed` method in Observer, displaying the corresponding text.

In this example, `frame.dataTextField` serves as the `ConcreteSubject`, while `observer1`, `observer2`, and `observer3` act as `ConcreteObservers`. The interfaces they implement, which define the Action/ActionListener methods, correspond to `Subject` and `Observer`, respectively.

After binding observers, the subject does not concern itself with the specific behavior of the observers. It simply notifies the observers when its own state changes, leaving it up to the observers to decide what actions to take. Therefore, this method is quite elegantâ€”far superior to explicitly calling functions or executing callback functions to trigger actions. It's definitely worth learning from.