---
"title": "Diseño de un Sistema de Edición en Tiempo Real para un Blog Zola con Backend en GitHub"
"summary": "Este documento detalla el diseño de un editor WYSIWYG para editar Markdown en tiempo real en un blog Zola, sin alterar el estilo CSS existente, integrado con un backend 'sin código manual'. Se definen principios de diseño como mantener el lenguaje visual actual, evitar en lo posible backends escritos a mano, y soportar vista previa en tiempo real y guardado automático. Tras una auditoría, se confirma que el proyecto es un sitio Zola sin cadena de construcción Node/React, con contenido en archivos Markdown. Entre las opciones, se propone como principal la Opción D: JS puro en `/admin` + Vditor + GitHub Device Flow + Publicación vía PR, logrando un flujo completo sin backend propio, usando GitHub como fuente de verdad, guardando borradores solo en caché local y almacenando imágenes en el repositorio. El documento también cubre riesgos de seguridad, alcance y fases, recomendando pasos de implementación basados en supuestos predeterminados para garantizar viabilidad y alineación con las preferencias del usuario."
"tags":
  - "Zola"
  - "Markdown"
  - "WYSIWYG"
  - "GitHub"
  - "Edición en tiempo real"
  - "Sin backend"
  - "Desarrollo frontend"
  - "Optimización de blogs"
"date": "2026-01-06"
---

# Blog Zola: Diseño del Sistema de Edición WYSIWYG Markdown en Tiempo Real + Backend Supabase/GitHub

## Objetivo

Diseñar y planificar un sistema que integre un editor WYSIWYG para editar Markdown en tiempo real con un backend "sin código manual" (Supabase o GitHub Issue/Discussion) para el blog Zola actual, sin romper el estilo CSS existente.

## Principios de diseño (deben cumplirse)

- Mantener el lenguaje visual actual de suCSS + variables CSS (incluyendo el cambio de tema claro/oscuro)
- Evitar en lo posible introducir un backend escrito a mano; priorizar la conexión directa del frontend a las APIs de Supabase o GitHub
- Si se requiere React/shadcn, justificar la necesidad, el coste y el plan de reversión de la cadena de construcción
- La experiencia de edición debe soportar vista previa/renderizado en tiempo real y guardado automático (al menos para borradores)
- Definir claramente la ruta de sincronización del contenido publicado con Zola (sin romper la estructura actual de `content`)

## Resumen del estado actual (de la auditoría)

- Este proyecto es un sitio Zola (sin cadena de construcción Node/React), todo el CSS/JS está en `static/`, y se permite incluir dependencias CDN en `templates/head.html`.
- El tema/colores están completamente impulsados por las variables CSS en `static/css/suCSS.css`; JS cambia entre claro/oscuro mediante `data-theme` (`static/js/script.js`).
- La fuente de contenido son los archivos Markdown en `content/**`; contienen front matter YAML (`---`) y shortcodes de Zola (como `{{ slideshow(...) }}`).

## Puntos de incertidumbre a revisar (por favor responde/selecciona)

1.  **Alcance de la edición**: ¿Solo necesitas editar uno o unos pocos archivos específicos (ej. `content/gcores-talks.md`) o deseas "poder editar cualquier página en `content/**`"?
2.  **Edición en tiempo real**: ¿A qué te refieres con "en tiempo real"?:
    - A) Vista previa/renderizado en tiempo real dentro del editor es suficiente (un solo usuario)
    - B) Necesita guardado automático de borradores en segundo plano (un solo usuario)
    - C) Necesita colaboración múltiple/edición simultánea (varios usuarios)
3.  **Flujo de publicación**: ¿Cómo debería afectar el resultado de la edición al sitio final?
    - A) Solo guardar en una biblioteca de borradores (no entra automáticamente en `content/`)
    - B) Publicación con un clic: sincronización automática al `content/` del repositorio y activación de la construcción de Zola
    - C) Semiautomático: exportar archivo/generar parche, para que lo confirmes manualmente
4.  **Autenticación**: Si el admin es solo para tu uso, ¿aceptas "enlace mágico por email de Supabase + lista de permitidos de un solo usuario"?
5.  **Imágenes**: ¿Necesitas subir imágenes directamente desde el editor? Si es así, ¿aceptas que las imágenes se almacenen en Supabase Storage y se referencien como enlaces externos en el Markdown?

> [REVISIÓN]
> 1. Quiero editar archivos arbitrarios y luego enviarlos al repositorio de GitHub de alguna manera. Si se necesita un backend, justificar su necesidad.
> 2. A y B
> 3. B
> 4. Esta versión es solo para mí, solo necesito admin, mientras sea seguro. Incluso aceptaría tener un par de claves de curva elíptica y usarlas para autenticarme, como con SSH.
> 5. Necesito subir imágenes y prefiero que se guarden en el repositorio.
>
> [RESPUESTA] Recibido. Ajusto los supuestos predeterminados/orientación del plan según tus respuestas:
>
> 1) Alcance de edición: Cambiado a "puede editar cualquier archivo en `content/**`" (y permitir extensión a `templates/**` etc., pero el MVP se limita primero a `content/**` para reducir riesgo). La ruta de publicación tiene como objetivo central "escribir de vuelta al repositorio de GitHub"; ya no usar Supabase como fuente de verdad.
>
> 2) Edición en tiempo real: Selecciono A + B — Renderizado/vista previa en tiempo real en el editor + guardado automático (borrador).
>
> 3) Flujo de publicación: Selecciono B — Enviar con un clic el resultado de la edición a GitHub (se recomienda usar PR en lugar de push directo a master, para facilitar tu revisión/reversión; si insistes en push directo, se puede hacer opcional).
>
> 4) Autenticación: MVP solo para ti. Mencionaste "par de claves de curva elíptica como SSH", esa dirección podría usarse para proteger credenciales locales (ej: usar tu clave privada para descifrar un token de GitHub almacenado en IndexedDB, o como paso de desbloqueo). Pero para escribir realmente en GitHub aún se necesita un token de autorización de GitHub; para cumplir con "evitar en lo posible un backend", prefiero usar GitHub OAuth *device flow* (no depende de `client_secret`) realizado completamente en el frontend, y luego almacenar el token solo localmente, pudiendo cifrarlo secundariamente con tu clave privada.
>
> 5) Imágenes: Según tu preferencia, las imágenes también se guardan en el repositorio (ej: escribir en `static/images/uploads/...`, referenciar `/images/uploads/...` en Markdown); la implementación de subida es "usar el mismo token de GitHub para crear blob/commit vía API", no necesita backend adicional.
>
> Mi próximo paso será cambiar en el plan la "recomendación predeterminada A (fuente de verdad en Supabase)" por "fuente de verdad en GitHub + Discussions/Issues para borradores + publicación vía PR", y complementar el diseño con detalles y limitaciones del almacenamiento/cifrado del token y la escritura de imágenes en el repositorio (tamaño máximo por archivo, estrategia de commits para autoguardado frecuente, etc.).
> [ESTADO:resuelto]

> [REVISIÓN] Si es posible, creo que puedo aceptar device flow, entonces no necesitaríamos el par de claves, puedo confiar en mi propio dispositivo.
>
> [RESPUESTA] OK, aceptando device flow, podemos eliminar el "par de claves de curva elíptica" del MVP:
> - Obtener un token de acceso de escritura al repositorio mediante GitHub OAuth device flow
> - El token se guarda solo en la máquina local (IndexedDB/localStorage), confías en tu propio dispositivo
> - Posteriormente, si deseas un "desbloqueo secundario/protección contra observadores locales", el par de claves/OS Keychain puede ser una mejora opcional para v2
> [ESTADO:resuelto]

## Opciones candidatas (arquitectura de alto nivel)

### Opción D (Implementación actual / Principal): JS puro `/admin` + Vditor + GitHub Device Flow + Publicación vía PR

- **Frontend**: Página estática `static/admin/*`, reutiliza los estilos existentes `reset.css`/`suCSS.css`/`style.css` y el cambio de tema de `static/js/script.js` (manteniendo coherencia del lenguaje de diseño).
- **Editor**: Vditor (modo IR por defecto), edición del cuerpo + edición separada del front matter (para evitar que el modo WYSIWYG lo dañe).
- **Autenticación**: GitHub OAuth **device flow** (sin necesidad de `client_secret`, no requiere backend propio para intercambio de tokens); el token se guarda solo en IndexedDB local.
- **Borradores**: Solo autoguardado local (IndexedDB), sin sincronización entre dispositivos, sin generar ruido de commits Git.
- **Publicación**: Al publicar, crear rama + PR, escribiendo de una vez:
    - `content/**.md` (combinando front matter + cuerpo)
    - `static/images/uploads/**` (las imágenes insertadas se registran como activos pendientes y se envían juntas al publicar)

Ventajas: Completamente sin backend propio; la "fuente de verdad" es el repositorio de GitHub; alineado con tus preferencias.
Riesgos: Necesita validar la "fidelidad" del editor con los shortcodes/front matter (especialmente páginas con `{{ ... }}`); necesita controlar el alcance de los permisos de la API de GitHub (scope).

### Opción A (Opcional): JS puro `/admin` + Vditor + Supabase (solo borradores/sincronización entre dispositivos)

Solo introducir si en el futuro necesitas "sincronización de borradores entre dispositivos/colaboración"; no como fuente de verdad.

### Opción B (Opcional): JS puro `/admin` + TOAST UI Editor

Si prefieres la experiencia de edición de TOAST UI, se puede cambiar el editor (con costo adicional de sobrescribir temas).

### Opción C (Opcional): React `/admin` (Vite) + shadcn UI + Milkdown/TipTap

Adecuado si necesitas UI/interacciones más complejas (gestión de recursos, bloques extensibles, etc.). Coste: Introducir cadena de construcción Node; necesita mapeo estricto a las variables suCSS existentes para evitar desviación de estilo.

> [REVISIÓN] Creo que D debería ser la mejor opción, no necesita un backend, el estado está en GitHub, creo que puedo aceptar introducir un proveedor de oauth, mi sistema de comentarios actual ya hace algo así, puedes ver cómo hacerlo. Si es estrictamente necesario introducir Supabase, solo debería guardar borradores, no como almacenamiento de la fuente de verdad.
>
> [RESPUESTA] De acuerdo con tu dirección: usar GitHub (Issues/Discussions + repositorio) como almacenamiento principal donde "el estado está en GitHub" se alinea mejor con tus preferencias; si se introduce Supabase, también debería degradarse a "borrador/caché opcional", no a la fuente de verdad del sistema.
>
> Necesito que confirmes 2 puntos más para evitar errores:
>
> 1) **Forma de OAuth**: Dices "puedo aceptar introducir un proveedor de oauth (el sistema de comentarios también es así)". El sistema de comentarios giscus escribe mediante una GitHub App/servidor que realiza el intercambio de tokens y firma; si también usamos el flujo OAuth web tradicional, involucraría la confidencialidad de `client_secret`, lo que normalmente aún requiere un backend/función confiable para intercambiar el token. Para cumplir con "no escribir backend a mano", sugiero más bien usar GitHub OAuth *device flow*: la autorización se puede completar completamente en el frontend (no necesita que un backend guarde `client_secret`). ¿Aceptas device flow como sustituto del "proveedor de oauth"?
>
> 2) **Dónde guardar borradores**:
>    - D1) GitHub Discussions: Cada página corresponde a un discussion, el borrador es el cuerpo del discussion; al publicar, generar PR para escribir en `content/**`.
>    - D2) GitHub Issues: Igual, pero issues está más orientado a flujos de tareas.
>    - D3) Rama `drafts` en el repositorio: El autoguardado actualiza directamente el archivo (generaría muchos commits, requiere estrategia de fusión/compresión).
>    ¿Cuál prefieres, D1/D2/D3?
>
>    Después de tu confirmación, completaré los "pasos de implementación realizables" con: "Fuente de verdad en GitHub + estrategia de borradores + estrategia de publicación PR + estrategia de envío de imágenes + modelo de seguridad (almacenamiento local de token / cifrado opcional con clave privada)".
>    [ESTADO:necesita-información]
>
> [RESPUESTA] Aceptado y ya convergido según tu última confirmación:
> - La Opción D (GitHub como almacenamiento principal) es la principal, pero ya no necesita "proveedor de oauth + intercambio de tokens en backend", usando **device flow** en su lugar.
> - Se elimina Supabase de la ruta principal (si en el futuro se necesitan borradores entre dispositivos/colaboración, se puede añadir como componente opcional).
>
> Implicaciones de implementación (para tu confirmación):
> - `borrador/autoguardado`: Solo escribe en caché local, no genera commits Git; evita "ruido de commit/PR por cada tecla pulsada".
> - `publicar`: Envía de una vez el archivo `content/**` especificado + cambios de imágenes, a GitHub (por defecto se sugiere abrir PR; también se puede configurar para push directo a master).
>
> Si estás de acuerdo con esta dirección convergente, mi próximo paso (cuando digas que se puede modificar el código) será implementar según esto.
> [ESTADO:resuelto]

> [REVISIÓN] 1. Acepto device flow. 2. Creo que mejor caché frontend, no parece que tenga necesidades de sincronización entre dispositivos, no lo compliquemos.
>
> [RESPUESTA] Confirmación recibida:
> 1) OAuth: Se adopta GitHub device flow (sin dependencia de `client_secret`, sin necesidad de backend propio para intercambio de tokens).
> 2) Borradores: Solo caché local en el frontend (IndexedDB como principal, localStorage como respaldo/para datos pequeños), sin sincronización entre dispositivos.
>
> En base a esto, convergeré el diseño general en:
> - **Fuente de verdad (publicado)**: Repositorio de GitHub `content/**` (escrito de vuelta mediante PR/push)
> - **Borradores (borrador/autoguardado)**: Caché local (no necesita Supabase/GitHub Discussions/Issues)
> - **Imágenes**: Se escriben en el repositorio al publicar (ej: `static/images/uploads/...`), referenciadas en Markdown con rutas internas del sitio
> [ESTADO:resuelto]

## Implementación recomendada (basada en supuestos predeterminados)

La implementación actual sigue directamente la Opción D (sin backend):

1.  Página estática `/admin/`: Conecta con GitHub (device flow), obtiene la lista de `content/**.md`.
2.  Cargar archivo: Analiza y separa front matter y cuerpo; el cuerpo se edita con Vditor.
3.  Borrador: Guardado con debounce en IndexedDB local al escribir (no se escribe en GitHub).
4.  Imágenes: Mediante "Insertar imagen" se registran como activos pendientes y se inserta la ruta interna del sitio (`/images/uploads/...`); al publicar, se envían junto con el commit al `static/images/uploads/...` del repositorio.
5.  Publicar: Crear rama + PR (un commit que incluye Markdown + imágenes), que al fusionarse activa el workflow de despliegue de Zola existente.

## Lista de seguridad y riesgos (necesita verificación/pruebas)

- Fidelidad del editor con `{{ ... }}` (shortcodes de Zola) y front matter (especialmente en modo WYSIWYG).
- XSS: Si se permite HTML crudo en Markdown, publicarlo en el sitio conlleva riesgo de inyección (se necesita restringir/filtrar con reglas "antes de publicar").
- Alcance (scope) del token de GitHub: Minimizar lo máximo posible (usar