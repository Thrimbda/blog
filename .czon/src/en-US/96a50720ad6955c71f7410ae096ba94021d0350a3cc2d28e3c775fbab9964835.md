---
"title": "Zola Blog WYSIWYG Editing and GitHub Backend Integration Solution Design"
"summary": "This document details the plan for adding WYSIWYG real-time Markdown editing functionality to an existing Zola blog. The core goal is to maintain the current design style and avoid introducing a custom backend. By analyzing the current state and design principles, the document recommends an architecture based on pure frontend implementation, using GitHub OAuth device flow for authentication, saving drafts locally, and publishing content back to the GitHub repository via creating a PR. This solution ensures a real-time preview and autosave editing experience while clarifying the content synchronization path without disrupting the existing structure. The document also discusses alternative candidate solutions, security risks, and implementation phases."
"tags":
  - "Zola"
  - "WYSIWYG"
  - "Markdown"
  - "GitHub"
  - "Frontend"
  - "Real-time Editing"
  - "No Backend"
  - "Blog"
"date": "2026-01-06"
---

# Zola Blog: WYSIWYG Markdown Real-time Editing + Supabase/GitHub Backend Solution Design

## Goal

To design and plan a WYSIWYG editor with real-time Markdown editing capabilities for the current Zola blog, integrated with a "no custom backend" solution (Supabase or GitHub Issue/Discussion), without disrupting the existing CSS design style.

## Design Principles (Must Follow)

- Maintain the existing suCSS + CSS variables visual language (including light/dark theme switching).
- Avoid introducing a custom backend as much as possible; prioritize frontend direct connection to Supabase or GitHub API.
- If React/shadcn is needed, provide justification for introducing the build chain, its cost, and a rollback plan.
- The editing experience must support real-time preview/rendering and autosave (at least for drafts).
- Clearly define the synchronization path for publishing content to Zola (without breaking the existing content structure).

## Current State Summary (From Audit)

- This project is a Zola site (no Node/React build chain). All site CSS/JS is served from `static/`, and CDN dependencies can be introduced in `templates/head.html`.
- Theme/colors are entirely driven by CSS variables in `static/css/suCSS.css`; JS toggles light/dark via `data-theme` (`static/js/script.js`).
- Content source is `content/**` Markdown files; includes YAML front matter (`---`) and Zola shortcodes (e.g., `{{ slideshow(...) }}`).

## Points Needing Your Review/Decision (Please Answer/Choose)

1.  **Editing Scope**: Do you only need to edit one/a few specific files (e.g., `content/gcores-talks.md`) or want to be able to "edit any page under `content/**`"?
2.  **Real-time Editing**: Your definition of "real-time" is:
    - A) Real-time preview/rendering within the editor is sufficient (single user)
    - B) Requires background autosave of drafts (single user)
    - C) Requires multi-user collaboration/simultaneous editing (multiple users)
3.  **Publishing Pipeline**: How should the editing results ultimately affect the site?
    - A) Only save to a draft library (does not automatically enter `content/`)
    - B) One-click publish: Automatically sync to the repo's `content/` and trigger a Zola build
    - C) Semi-automatic: Export file/generate patch, you manually commit
4.  **Authentication**: The admin is only for your own use. Do you accept "Supabase email magic link + allowlist single user"?
5.  **Images**: Do you need to upload images directly within the editor? If yes, do you accept storing images in Supabase Storage and referencing them via external links in Markdown?

> [REVIEW]
> 1. I want to edit any file, then submit it to the github repo via some method. If a backend is needed, justify its necessity.
> 2. A and B
> 3. B
> 4. This version is just for me, admin only is fine, as long as it's secure. I can even accept having an elliptic curve key pair and using it for authentication, like SSH.
> 5. Need to upload images, and want images stored in the repo.
>
> [RESPONSE] Received. I'll adjust the default assumptions/solution orientation based on your answers:
>
> 1) Editing Scope: Changed to "can edit any `content/**` file" (and allow extension to `templates/**` etc., but MVP will lock to `content/**` to reduce risk). Publishing path has "writing back to GitHub repo" as the core goal; Supabase is no longer the source of truth.
>
> 2) Real-time Editing: Choose A + B — real-time rendering/preview within the editor + autosave (draft).
>
> 3) Publishing Pipeline: Choose B — one-click submission of editing results to GitHub (recommend using PR instead of direct push to master for easier review/rollback; can be made an option if you insist on direct push).
>
> 4) Authentication: MVP is for your use only. You mentioned the "elliptic curve key pair like SSH" direction could be used for local credential protection (e.g., using your private key to decrypt a GitHub token stored in IndexedDB, or as an unlock step). However, actual write operations to GitHub still require a GitHub authorized token. To satisfy "try to avoid needing a backend", I lean towards using GitHub OAuth *device flow* (no dependency on `client_secret`) completed purely on the frontend, then storing the token only locally with optional secondary encryption using your private key.
>
> 5) Images: According to your preference, images are also stored in the repo (e.g., written to `static/images/uploads/...`, referenced in Markdown as `/images/uploads/...`). Implementation-wise, uploading is "using the same GitHub token to create blob/commit via API", no extra backend needed.
>
> My next step is to change the "default recommendation A (Supabase as source of truth)" in the plan to "GitHub as source of truth + Discussions/Issues for draft storage + PR publishing", and supplement the design with details and limitations regarding token storage/encryption and image writing to repo (single file size, commit strategy for frequent autosave, etc.).
> [STATUS:resolved]

> [REVIEW] If possible, I think device flow is acceptable, then we don't need the key pair. I can trust my own device.
>
> [RESPONSE] OK, given the acceptance of device flow, we can remove the "elliptic curve key pair" from the MVP:
> - Use GitHub OAuth device flow to obtain an access token for writing to the repo.
> - Token is only saved locally (IndexedDB/localStorage), you just need to trust your own device.
> - Later, if you want "secondary unlock/protection against local onlookers", add the key pair/OS Keychain as an optional v2 enhancement.
> [STATUS:resolved]

## Candidate Solutions (High-Level Architecture)

### Solution D (Current Implementation / Primary Solution): Pure JS `/admin` + Vditor + GitHub Device Flow + PR Publishing

- **Frontend**: `static/admin/*` static pages, reusing existing `reset.css`/`suCSS.css`/`style.css` and the theme toggle from `static/js/script.js` (maintaining consistent design language).
- **Editor**: Vditor (default IR mode), separate editing for body and front matter (to avoid WYSIWYG corruption).
- **Authentication**: GitHub OAuth **device flow** (no `client_secret` needed, no custom token exchange backend required); token stored only locally in IndexedDB.
- **Drafts**: Local autosave only (IndexedDB), no cross-device sync, no Git commit noise.
- **Publishing**: Create branch + PR upon publish, writing in one go:
  - `content/**.md` (merge front matter + body)
  - `static/images/uploads/**` (images registered as pending assets upon insertion, submitted together upon publishing)

Advantages: Completely no custom backend; "Source of truth" is the GitHub repo; aligns with your preferences.
Risks: Need to verify editor's "fidelity" to shortcodes/front matter (especially pages containing `{{ ... }}`); need to control GitHub API permission scope.

### Solution A (Optional): Pure JS `/admin` + Vditor + Supabase (Drafts/Cross-Device Only)

Only introduce if you need "cross-device draft sync/collaboration" in the future; not as the source of truth.

### Solution B (Optional): Pure JS `/admin` + TOAST UI Editor

If you prefer the TOAST UI editing experience, the editor can be replaced (requires additional theme customization cost).

### Solution C (Optional): React `/admin` (Vite) + shadcn UI + Milkdown/TipTap

Suitable for: You need more complex UI/interactions (resource management, extension blocks, etc.). Cost: Introduces Node build chain; requires strict mapping to existing suCSS variables to avoid style drift.

> [REVIEW] I think D is a good solution. It doesn't need a backend, the state is all on GitHub. I think I can accept introducing an OAuth provider. My current comment system does this too. You can see how to do it. If Supabase must be introduced, it should only store drafts, not as the source of truth storage.
>
> [RESPONSE] Agree with your direction: Using GitHub (Issues/Discussions + repo) as the primary storage where "state is all on GitHub" better aligns with your preference; if Supabase is introduced, it should be demoted to an "optional draft/cache", not the system's source of truth.
>
> I need you to confirm 2 more points to avoid going down the wrong path:
>
> 1) **OAuth Form**: You said "can accept introducing an OAuth provider (the comment system does this too)". The comment system giscus's writes rely on a GitHub App/server-side for token exchange and signing; if we also use the traditional web OAuth flow, it involves keeping the `client_secret` confidential, which typically still requires a trusted backend/function to exchange tokens. To satisfy "no custom backend", I recommend using GitHub OAuth *device flow*: authorization can be completed purely on the frontend (no backend needed to keep `client_secret`). Do you accept device flow as a replacement for the "OAuth provider"?
>
> 2) **Where to Store Drafts**:
> - D1) GitHub Discussions: Each page corresponds to a discussion, draft is the discussion body; publish by generating a PR to write to `content/**`.
> - D2) GitHub Issues: Same principle, but issues are more task-oriented.
> - D3) Repo `drafts` branch: Autosave directly updates files (will generate many commits, requires merge/squash strategy).
> Which do you prefer, D1/D2/D3?
>
> After your confirmation, I will complete the "GitHub as source of truth + draft strategy + publish PR strategy + image submission strategy + security model (token local storage/optional private key encryption)" into actionable implementation steps.
> [STATUS:need-info]
>
> [RESPONSE] Agreed and have converged based on your latest confirmation:
> - Solution D (GitHub as primary storage) as the main solution, but no longer needs "OAuth provider + backend token exchange", using **device flow** instead.
> - Supabase removed from the main path (if cross-device drafts/collaboration is needed in the future, add as an optional component).
>
> Implementation implications (for your confirmation):
> - `draft/autosave`: Only write to local cache, no Git commits; avoid "generating a commit/PR noise with every keystroke".
> - `publish`: Submit the specified `content/**` file + image changes to GitHub in one go (default recommendation is to open a PR; can also be configured to push directly to master).
>
> If you agree with this convergence direction, my next step (when you say to proceed with code changes) is to implement accordingly.
> [STATUS:resolved]

> [REVIEW] 1. device flow is acceptable. 2. I think maybe just frontend cache. I don't seem to have a need for cross-device sync, so let's not complicate things.
>
> [RESPONSE] Confirmation received:
> 1) OAuth: Adopt GitHub device flow (no `client_secret` dependency, no custom token exchange backend needed).
> 2) Drafts: Only implement frontend local cache (IndexedDB primary, localStorage as fallback/for small data), no cross-device sync.
>
> Accordingly, I will converge the overall design to:
> - **Source of Truth (published)**: GitHub repo `content/**` (written back via PR/push)
> - **Drafts (draft/autosave)**: Local cache (no need for Supabase/GitHub Discussions/Issues)
> - **Images**: Written to the repo upon publishing (e.g., `static/images/uploads/...`), Markdown references site-internal paths.
> [STATUS:resolved]

## Recommended Implementation (Based on Default Assumptions)

Current implementation directly implements Solution D (no backend):

1.  `/admin/` static page: Connect to GitHub (device flow), fetch list of `content/**.md` files.
2.  Load file: Parse and separate front matter and body; edit body with Vditor.
3.  Drafts: Debounced save to local IndexedDB upon input (no write to GitHub).
4.  Images: Register as pending asset via "Insert image" and insert site-internal path (`/images/uploads/...`); submit to repo's `static/images/uploads/...` upon publishing.
5.  Publish: Create branch + PR (single commit containing Markdown + images), triggering the existing Zola deploy workflow upon merge.

## Security and Risk Checklist (Needs Verification/Testing)

- Editor fidelity to `{{ ... }}` (Zola shortcodes) and front matter (especially in WYSIWYG mode).
- XSS: If raw HTML is allowed in Markdown, publishing to the site introduces injection risks (need rule constraints/filtering "before publishing").
- GitHub token scope: Minimize as much as possible (use `public_repo` for public repo).
- Admin page indexing: Need `noindex` (or place in an unguessable path/add extra gate) to avoid search engine indexing.

## Scope

- static/css/*
- templates/*
- static/js/*
- scripts/*
- .github/*
- .legion/**

## Phase Overview

1.  **Current State Audit & Constraints** - 2 tasks
2.  **Editor Selection Research** - 2 tasks
3.  **Backend & Data Model Design** - 2 tasks
4.  **Integration Solution Detailed Design & Implementation Plan** - 2 tasks

---

*Created: January 6, 2026 | Last Updated: January 6, 2026*