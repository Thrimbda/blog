---
"title": "A Second Look at Concurrency (Actor)"
"summary": "The article first discusses issues in concurrent programming when multiple workers need to work asynchronously with distinct responsibilities. Sharing a single message queue leads to problems such as inability to send messages to specific workers, misdelivered messages, and timing issues. Through step-by-step analysis, the author points out the inefficiency and potential bugs of a shared message queue in such scenarios. The article then introduces the Actor model as a fundamental solution, which assigns an independent message queue (mailbox) to each worker, achieving complete message isolation and asynchronous communication. The concept of the Actor model is explained in detail, including its parallel execution, message passing, and addressing mechanisms. A Python thread-based implementation example is provided, demonstrating how to build a basic Actor (BaseWorker). Finally, the author summarizes the advantages of the Actor model in concurrent programming, emphasizing its value in abstract thinking and the practice of 'high cohesion, low coupling.'"
"tags":
  - "python"
  - "concurrency"
  - "Actor model"
  - "message queue"
  - "asynchronous programming"
  - "multithreading"
  - "programming model"
"date": "2017-05-19"
---

---
title: A Second Look at Concurrency (Actor)
date: 2017-05-19
taxonomies:
  tags:
    - python
    - concurrency
---

[Last time](http://0xc1.space/2017/05/06/初探并发/), we discussed using message queues to pass messages between threads (or processes) to achieve inter-thread communication.

<!--more-->

## Shared Message Queue

This approach is based on the assumption that **concurrency is only about improving system throughput**. Under this assumption, every worker performs the same tasks, so they can share a single message queue—it doesn't matter who picks up the next instruction.

### What If We Aren't Siblings?

What if we need to implement a system where each worker has distinct responsibilities and works asynchronously (e.g., our IP phone)? If we still use the above method, with all workers sharing a single message queue, problems arise: messages cannot be sent to specific workers.

How can we solve this? A simple and crude solution is to add an identifier to each message to specify its intended recipient:

```python
queue = Queue([('Send_to_worker_A', 'do_something1'),
               ('Send_to_worker_B', 'do_something2'),
               ('Send_to_worker_B', 'do_something3'),
               ('Send_to_worker_C', 'do_something4'),
               ('Send_to_worker_A', 'do_something5')])
```

It seems the problem is solved, right? But we've introduced a new issue.

### What If I Accidentally Open Someone Else's Mail?

If a message intended for worker A is received by worker B, it's useless to worker B, while worker A, who should have received it, misses out. This wastes worker B's time, consumes worker A's resources, and could even lead to strange bugs due to skipped steps.

How do we solve this? Intuitively, adding the following strategy to each worker seems to fix the problem: if a worker receives a message meant for someone else, put it back into the message queue.

```python
class Worker_B:
    
    def run(self):
        while True:
            if not self.queue.empty():
                data = self.queue.get()
                if data['to_whom'] == 'worker_B':
                    do_something_with_data
                else:
                    self.queue.put(data)
```

It seems patched up and solved... but in reality, we've introduced yet another problem.

### This Looks Like a Dead End

First, a message queue is a queue, meaning FIFO (First-In-First-Out). Even if we introduce a priority queue, this fundamental characteristic doesn't change. As a result, a message that should have been delivered first to worker A, after being handled by worker B, becomes the last message in the queue for worker A. This could lead to strange bugs in the system.

Second, even if we manage to reinsert misdelivered messages at the front of the queue, without introducing a locking mechanism to make worker B's `receive-check-return` operation atomic, other workers might continue receiving messages while worker B is performing the return operation. This could still cause significant timing issues. Introducing a locking mechanism can solve logical errors, but it would allow only one worker to actually work during each polling cycle. Other workers that receive wrong messages and perform the `receive-check-return` operation would waste their time slices, **leading to inefficiency.**

Therefore, for systems that introduce concurrency for asynchronous work, sharing a single message queue among all workers doesn't seem like a good approach.

The fundamental solution to this problem is to create a dedicated message queue (mailbox) for each group of workers performing the same task, or even assign each worker its own message queue, completely abandoning shared memory between threads. The latter approach is the protagonist of today's discussion: **the Actor model (Participant Pattern).**

## Actor Model

First, let's look at Wikipedia's definition and concepts of the Actor model:

### Concepts

In computer science, the Actor model is a model for concurrent computation. An "actor" is an abstract concept in programming, regarded as the fundamental unit of concurrent computation: when an actor receives a message, it can make decisions, create more actors, send more messages, and determine how to respond to subsequent messages. The Actor model was proposed in a 1973 paper by Carl Hewitt, Peter Bishop, and Richard Steiger.

The philosophy promoted by the Actor model is "everything is an actor," similar to the object-oriented programming principle "everything is an object." However, object-oriented programming is typically sequential, while the Actor model is parallel. An actor is a computational entity that responds to received messages and, in parallel:

- Sends a finite number of messages to other actors;
- Creates a finite number of new actors;
- Specifies the behavior for the next received message.

These operations do not assume sequential execution and can thus be performed in parallel. The decoupling of the sender from the sent message is the fundamental advantage of the Actor model. This enables asynchronous communication while satisfying the control structure of message passing. Message recipients are distinguished by addresses, sometimes called "mail addresses." Therefore, an actor can only communicate with actors whose addresses it possesses. It can obtain addresses from received messages or from the actors it creates. The characteristics of the Actor model include parallel computation within or between actors, dynamic creation of actors, addresses included in messages, interaction only through direct asynchronous message communication, and no restrictions on the order of message arrival.

### Implementation

Actors are simple, designed for concurrency, and provide sufficient encapsulation to isolate changes (e.g., whether multithreading or multiprocessing is used).

Let's look at a typical Python thread-based implementation of an Actor:

```python
from queue import Queue
from threading import Thread, Event


class WorkerExit(Exception):
    # Exception used to terminate tasks
    pass


class BaseWorker(object):
    # Actor
    def __init__(self):
        self._mailbox = Queue()
        super(BaseWorker, self).__init__()

    def send(self, msg):
        self._mailbox.put(msg)

    def recv(self):
        msg = self._mailbox.get()
        if msg is WorkerExit:
            raise WorkerExit()
        return msg

    def close(self):
        self.send(WorkerExit)

    def start(self):
        self._terminated = Event()
        t = Thread(target=self._bootstrap)

        t.daemon = True
        t.start()

    def _bootstrap(self):
        try:
            self.run()
        except WorkerExit:
            pass
        finally:
            self._terminated.set()

    def join(self):
        self._terminated.wait()

    def run(self):
        raise NotImplementedError
```

To briefly explain, this Actor (which I've named `BaseWorker` and used as a parent class in real projects) maintains two data structures: a `Queue` as the mailbox and an `Event` as a mechanism to block the main thread.

The core operation exposed as an external interface here is the `send()` method. Note that **we do not restrict the types of messages that can be passed**, which provides immense flexibility.

Inside the Actor, we use a thread to run the `run()` method, combined with the `recv()` method, to perform the specified tasks. It's worth mentioning that we set a sentinel signal, `WorkerExit`, to stop tasks. Note that `WorkerExit` works by being recognized and raised as an exception. In the exception handling, we could do even more, but here we simply stop the thread when this exception is caught. This exception handling is implemented via the `_bootstrap()` method, which wraps `run()`.

Under the philosophy of the Actor model, we can extend this simple example to go even further.

## Summary

Concurrent programming requires a more abstract way of thinking than usual and serves as good practice for the principle of "high cohesion, low coupling."

In my exploration of this entirely new field, the Actor model has been a guiding light, truly helping me get started. Hence, I share it here. :)