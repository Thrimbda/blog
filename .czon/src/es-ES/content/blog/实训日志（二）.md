---
"title": "Diario de Prácticas (II): Resumen del Desarrollo de API Backend y Gestión de Proyectos"
"summary": "Este artículo es un diario escrito por el autor al finalizar su proyecto de prácticas, en el que repasa su experiencia como líder del grupo responsable del desarrollo del servidor de API backend. Primero, expone la filosofía de diseño del proyecto 'Seed' (un sistema de gestión de objetivos), enfatizando el principio de 'pequeño y minimalista', y adoptando una arquitectura de API RESTful para soportar múltiples frontends como mini programas de WeChat. En cuanto a la implementación técnica, se optó por utilizar el ecosistema Spring para el desarrollo, y se menciona la práctica de desarrollo guiado por pruebas. El autor reflexiona sobre sus propias deficiencias en la gestión del proyecto, como el conocimiento insuficiente de tecnologías frontend y la participación desigual del equipo. También discute el equilibrio necesario entre la capacidad de arquitectura de sistemas y la capacidad de implementación concreta que requiere un ingeniero de software, considerando que estas prácticas son un complemento importante a la educación en el aula."
"tags":
  - "Prácticas"
  - "Gestión de Proyectos"
  - "Desarrollo Backend"
  - "Framework Spring"
  - "API RESTful"
  - "Mini Programas de WeChat"
  - "Educación en Ingeniería de Software"
"date": "2017-03-12"
---

---
title: Diario de Prácticas (II)
date: 2017-03-12 16:09:19
taxonomies:
  tags:
    - Cotidiano
    - Prácticas
    - Reflexiones
---

Las prácticas están a punto de llegar a su fin. En este momento, el trabajo de codificación de la versión básica del servidor de API backend está prácticamente terminado. Es un buen momento para hacer un resumen.

Como líder del grupo del proyecto, mi único conocimiento sobre gestión de proyectos de software proviene de haber leído *The Mythical Man-Month* durante las vacaciones de invierno. Después de esta práctica, me doy cuenta de que aún soy muy inexperto. Sin embargo, creo que he aprendido algunas cosas.

<!--more-->

## Diseño

Comparado con hace dos años, cuando empezaba a escribir código en C para las tareas sin pensarlo dos veces y abriendo Visual Studio, hoy en día he cambiado bastante.

~~En primer lugar, hace mucho que no abro Visual Studio.~~

En resumen, durante estos dos años he pasado por varias etapas de codificación intensiva: la etapa de aprendizaje puro e inocente de Python, la experiencia desarrollando la interfaz de usuario para el robot en el equipo de robótica, la experiencia escribiendo crawlers para el sitio web de la oficina académica (tanto para profesores como para estudiantes), y la participación en el proyecto "Zumo de Naranja" escribiendo una herramienta de gestión de archivos. Al principio, por supuesto, me lancé sin pensar, pero supongo que después de sufrir las consecuencias de las contradicciones e inconsistencias, uno aprende a diseñar con anticipación. Una vez que entras en el mundo del diseño, la siguiente cuestión es el grado de profundidad; por lo tanto, esta experiencia de tener el control de todo el proyecto ha sido un ejercicio muy beneficioso.

**Primero, aclarar qué se quiere hacer**. Esta pregunta es crucial para un equipo que realmente quiere crear un producto: **definir su propio producto** es una cuestión a nivel estratégico. Lamentablemente, esta vez no tuvimos una idea particularmente interesante, pero con la responsabilidad sobre los hombros, mi expectativa para estas prácticas era hacer un proyecto sólido y simple.

En pocas palabras, se trata de una **aplicación web tradicional con los mini programas de WeChat como característica principal**; concretamente, un sistema de gestión de objetivos.

Hay mucha gente que hace esto, por lo que para modelar los elementos a los que nos enfrentamos podemos encontrar muchos esquemas maduros: como Worktile, orientado a proyectos; WonderList, orientado a la gestión personal de la vida; My Study Life, orientado a estudiantes; e incluso la app `Recordatorios` de Apple y otras herramientas que he oído mencionar pero no he usado. Sintetizando las características de estas herramientas, resumimos un sistema de gestión de objetivos clásico, con características propias de WeChat, y así nació lo que queríamos hacer: `Seed`.

### Características que debería tener

Entonces, ¿qué debería poder hacer `Seed`?

+ Tener un sistema de usuarios simple, para facilitar la sincronización y aumentar la fidelidad del usuario.
+ Los usuarios pueden crear y gestionar libremente objetivos, similares a los `proyectos` de Worktile.
+ Los usuarios pueden ser invitados a los objetivos de otros.
+ Los objetivos se dividen en tipo "check-in diario" (cíclico) y tipo "proyecto desafiante" (único, se pueden introducir hitos).
+ El frontend principal son los mini programas de WeChat.
+ También es compatible con otros clientes potenciales.

De esto se deduce que `Seed` debería ser un servicio práctico, pequeño y minimalista, lo cual coincide con la intención original de los mini programas de WeChat.

Aquí es necesario enfatizar la característica de **"pequeño y minimalista"**. ¿Por qué pequeño y simple? Primero, porque no hay suficiente personal y el tiempo es limitado. Segundo, para evitar el error común del `segundo proyecto` mencionado en *The Mythical Man-Month*: la arrogancia ciega, añadiendo locamente características redundantes e interminables a un proyecto. Esto es un esfuerzo inútil y tonto, especialmente porque no involucramos ingresos por publicidad. Un ejemplo simple: la versión de Mac OS de Xunlei y la versión de Windows de Xunlei, obviamente a todos les gusta más la versión de Mac, que es más ligera y usable.

También debe tener una buena compatibilidad con los mini programas de WeChat. Para proporcionar una transición fluida en la experiencia del usuario, debería admitir tanto el email como nombre de usuario para iniciar sesión, como el openId de WeChat como credencial de acceso.

### Estructura del sistema

Como se mencionó anteriormente, queremos hacer una aplicación web con los mini programas de WeChat como característica principal. Esto significa que `Seed` tiene la capacidad ~~y la ambición~~ de ser compatible con otros frontends. Por lo tanto, una API de estilo RESTful se convierte en la mejor opción: desacoplamiento completo entre frontend y backend, estructura clara y fácil de consumir.

Por lo tanto, `Seed` debería consistir en los mini programas de WeChat y otras formas potenciales como frontend, consumiendo a través del protocolo HTTP los `recursos` proporcionados por el backend.

El backend proporciona servicios seguros y confiables a través de la API.

Para ello también aprendí un poco, llegando a conocer la idea de HATEOAS (Hypermedia As The Engine Of Application State). Aunque aún no está madura, es un posible futuro.

## Implementación

Dado que solo participé en el trabajo de codificación del servidor de API, aquí solo hablaré de la implementación del backend.

Me gusta clasificar el diseño en el nivel estratégico (el "Tao"), y el trabajo restante en el nivel táctico (la "técnica"). Por lo tanto, la elección de qué tecnología usar y cómo implementar concretamente un sistema puede incluirse aquí.

### Tecnología

Debido a los requisitos de las prácticas, y también por el deseo de usar el lenguaje Java de manera razonable, elegimos `Spring Framework` como framework backend, utilizando de paso todo el ecosistema Spring:

+ Spring Boot como contenedor de aplicaciones
+ Spring Framework para implementar la lógica de negocio
+ Spring Data como DAO
+ Spring Session para gestionar las sesiones
+ Spring Test para pruebas

Además, utilizamos herramientas como Git, TravisCI y Heroku para mejorar la experiencia de desarrollo.

### Proceso de desarrollo

Como mencioné antes, la experiencia de escribir controladores en Spring es muy similar a la del framework web Flask de Python. ¿Quizás Flask tomó alguna inspiración de Spring? Creo que las clases controladoras orientadas a recursos son mucho más compactas que la forma tradicional de Java Web, donde hay que escribir un Servlet para cada recurso.

Spring promueve el desarrollo guiado por pruebas (TDD). Hacerlo realmente no es fácil, ya que las pruebas no suelen ser un trabajo popular. Asignar a una persona específica para escribir código de pruebas tiene un alto costo de aprendizaje y, además, plantea algunos problemas de relaciones personales. Por lo tanto, durante el desarrollo decidí que cada persona fuera responsable de probar su propio código. Finalmente, yo revisaría el código.

## Resumen

La parte interesante sobre `Seed` en sí ya ha sido contada. Ahora hablemos de otras cosas.

### Resumen personal

Aprendí mucho durante las prácticas, pero aún hay problemas.

Como gestor de proyecto, soy bastante malo. El control del progreso, la asignación de personal y otros detalles tienen muchas deficiencias.

Por ejemplo:

- La falta de conocimiento sobre tecnologías frontend hace que probablemente solo el servidor de API sea funcional al final de este proyecto.
- Solo la mitad de las personas en el grupo del proyecto participaron realmente.
- La formación para las personas que participaron en el trabajo fue vaga y careció de paciencia.

Obviamente, todavía necesito seguir practicando. Pero al mismo tiempo, ser tanto gestor de proyecto como desarrollador me llevó a reflexionar sobre otro tema.

### Discusión sobre las dos capacidades de un ingeniero de software

**La capacidad de arquitectura y control de todo el sistema** y **la capacidad de elección, adaptación y uso de algoritmos para implementar una función concreta**.

La educación en el aula de nuestra facultad de ingeniería de software parece centrarse solo en lo segundo. Esto no es extraño, ya que el dominio de los algoritmos es fácil de medir; se puede decir que las diferencias en habilidad son evidentes, como resolver problemas matemáticos: bajo condiciones y restricciones estrictas, la creatividad de las personas es muy fácil de evaluar. Sin embargo, la capacidad de establecer razonablemente estas llamadas "condiciones y restricciones estrictas", aunque importante, es difícil de medir.

En cuanto a por qué digo que es contradictorio, pongamos un ejemplo simple y comprensible, aunque quizás no del todo apropiado: todo el mundo sabe que es infantil e irreal que los padres prohíban a sus hijos tener relaciones sentimentales tempranas con el pretexto de que afecta a los estudios, pero esperen que formen una familia inmediatamente después de graduarse. Y esperar implícitamente que los estudiantes, **solo** con buenas calificaciones académicas, se conviertan en personas completas al graduarse es también una idea un tanto distorsionada. La diferencia entre estos dos casos es que la contradicción en el segundo no es tan aguda como en el primero.

Creo que este tipo de prácticas son efectivamente una compensación por las deficiencias de la educación en el aula, y una oportunidad para evitar la contradicción entre el **rendimiento académico** como medio de formación y la **capacidad** como objetivo de formación, que estos dos símbolos representan.