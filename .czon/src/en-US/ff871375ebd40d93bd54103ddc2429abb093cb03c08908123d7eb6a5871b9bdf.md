---
"title": "An RBAC Demo: For Aiur"
"summary": "This article introduces an RBAC practice demo named 'For Aiur,' which uses Python's Flask framework to build a RESTful service that simulates resource management and role-based permission control in the StarCraft game. The article provides a detailed analysis of the design of subjects, roles, resources, and permissions in the demo, and demonstrates how to implement the SA (Subject-Role) and PA (Role-Permission) relationships in the RBAC model through code examples. Additionally, the article explains how to integrate RBAC with a RESTful architecture, as well as the business logic and implementation details of the demo. Finally, the author summarizes the insights and gains from this practice regarding RBAC, the Flask framework, and RESTful principles."
"tags":
  - "RBAC"
  - "RESTful"
  - "Flask"
  - "System Design"
  - "Python"
  - "Permission Management"
  - "StarCraft"
  - "Demo"
"date": "2017-05-11"
---

---
title: An RBAC Demo: For Aiur
date: 2017-05-11
taxonomies:
  tags:
    - System Design and Analysis
    - RESTful
    - RBAC
---

Based on the understanding of RBAC from the previous article and due to assignment requirements, I will create a simple demo as a practice for RBAC.

I have no intention of making the demo overly complex. My goal is to illustrate the concepts, so it remains "small but complete."

So, what is the goal of this demo, and what can it do?

<!--more-->

## Analysis and Design

To make it interesting and fully reflect the problem, I will simulate a greatly simplified scenario in my demo, where every unit miraculously possesses subjective initiative, set in a StarCraft battle from the perspective of a Protoss player.

A good demo needs a good name, so this demo is called: **For Aiur!** (Aiur is the homeworld of the Protoss, and every Zealot says this impassioned phrase when warped onto the battlefield: "For Aiur!")

In **For Aiur**, you lead your team to produce enough Zealot warriors to destroy the Destroyer Amon and save the universe. If you don't have enough Zealots, you will fail, the stars will whisper, and all things will vanish.

All of this is reflected in a RESTful service built with Python's Flask framework.

> In a real scenario, every entity except the player can be created, so they can all be considered resources. To reflect RBAC, I have added the following constraints:
>
> - The few subjects provided in this demo are unique and always exist, as if they were one-of-a-kind, thus eliminating the possibility of any subject being recursively created (e.g., a Probe can produce a Nexus, and a Nexus can produce Probes).
> - In reality, Gateways require energy from Pylons to operate, but this is not reflected here. I explain it as our Gateways receiving energy support from the Spear of Adun, a legendary Protoss mothership in synchronous orbit, thus treating Pylons only as resources providing population capacity.

This battle scenario includes the following objects:

### Subject

- Player (you) – thrimbda
- Probe (basic worker unit, can gather resources and construct buildings) – probe
- Gateway (produces Zealots, a combat unit) – gateway

#### Role

- Archon (supreme commander, allocates all resources) – archon
- Crystal Collector (only Probes can take on this role) – crystal_collector
- Portal for Zealot Warp-in (beacon supporting the teleportation of Protoss warriors) – portal
- Pylon Builder (with Pylons, we can have enough population capacity to warp in Zealots) – pylon_transporter

### Resource

- Uncollected Crystal (used to build Pylons and warp in Zealots, initial value unknown)
- Collected Crystal (used to build Pylons and warp in Zealots, initial value 0)
- Population Capacity (provides energy for warping, i.e., the population we refer to, initial value 0)
- Zealot (combat unit, the warriors you use to save the universe, initial value 0)

### Permission

> Since each operation on a resource is a permission, we do not list operations separately here but directly provide permissions and their descriptions.

- Collect Crystal (up to 1000 units per collection)
- Observe Uncollected Crystal (observe total amount)
- Status Report (report current resource quantities)
- Scout Amon's Strength (calculate required number of Zealots)
- Build Pylon (each Pylon provides 10 population capacity and costs 100 Crystal)
- Produce Zealot (each Zealot consumes 2 population capacity and 100 Crystal)
- Attack Amon (Victory or death!)

### SA

> The many-to-many relationships between Subject-Role and Role-Permission are represented using Python's tuple data structure, and the same applies in the implementation. Therefore, this application does not use a database.

```python
subject_role = (('thrimbda', 'archon'),
                ('probe', 'crystal_collector'),
                ('probe', 'pylon_transporter'),
                ('gateway', 'portal'))
```

### PA

```python
role_permission = (('archon', 'get_status'),
                   ('archon', 'for_aiur'),
                   ('archon', 'scout'),
                   ('crystal_collector', 'get_crystal'),
                   ('crystal_collector', 'crystal_status'),
                   ('pylon_transporter', 'get_status'),
                   ('pylon_transporter', 'transport_pylon'),
                   ('portal', 'transport_zealot'),
                   ('portal', 'get_status'))
```

## Implementation

[Repository URL](https://github.com/Thrimbda/my-life-for-Aiur)

[Online Deployment](https://my-life-for-aiur.herokuapp.com/) (slow)

### Overview

Overall, I used Python's Flask framework to build a RESTful-style service. The entire application does not involve a frontend, so there are no security issues like bypassing the frontend.

One characteristic of this demo is that it does not use a database. RBAC does not mandate the use of a database, and using a database in RBAC is intuitive and natural. However, in **For Aiur**, we do not use a database; instead, we use files to represent the RBAC `Subject-Role-Permission` relationships. Databases themselves evolved from file systems. Files are used here because the system is simple enough, and to further reduce complexity for illustrative purposes. The specific file format is described in the SA and PA relationship sections above.

### About RESTful

Here is a brief mention of RESTful (**Re**presentational **S**tate **T**ransfer).

As the name suggests, it is the (resource) representational state transfer.

In a web service, the services provided are the system's resources, represented as URIs, and the form of the service is the operation on the resources (state transfer), represented as HTTP verbs. These concepts align well with the resources and operations in RBAC. Therefore, what I need to do is apply RBAC's permission management to the operations on resources in REST.

### Objects in RBAC

As seen in the two configuration files, besides SA and PA, we can implicitly derive S, R, P:

```python
# Derive S and R lists from the above tuple subject_role
subjects = list(set([item[0] for item in subject_role]))
roles = list(set([item[1] for item in subject_role]))
```

SE can be well-corresponded to the session in a web application, serving as a temporary object for a subject during a login:

```python
# The subject uses this to log into the Spear of Adun tactical management system API. Here, session is a global object in Flask, and its implementation details are not elaborated.
class SpearOfAdun(Resource):
    
    def post(self):
        args = self.putparser.parse_args()
        if args['subject'] is not None:
            abortInvalideSubject(args['subject'])
        if args['role'] is not None:
            abortInvalideRole(args['role'])
        checkRole(args['subject'], args['role'], subject_role)
        session['subject'] = args['subject']
        session['role'] = args['role']
        return {'message': 'login as %s using %s' % (session['subject'], session['role'])}, 201
```

The modeling of Subject-Role ultimately aims to isolate and assign permissions, ensuring proper use and protection of system resources.

In **For Aiur**, I treat permissions as internal properties of the web API, for example:

```python
# API for warping in Zealots
class Zealot(Resource):

    def put(self):
        permission = 'transport_zealot' # Permission
        abortIfSubjectUnauthenticated(session) # Login verification
        checkPermission(session['role'], permission, role_permission) # Check if the subject in this role can request this permission
        args = self.putparser.parse_args()
        amount = nexus.transport(args['amount'])
        return {'message': 'transport %d zealot warriors, En Taro Tassadar!' % amount}, 200
```

In the two APIs used as examples above, each class exists as a resource in the system, and the provided HTTP methods are operations on the resources.

**At this point, all the objects in RBAC are in place.**

### Business Logic

Since **For Aiur** is a real, playable online real-time strategy game API, it's necessary to explain its business logic:

The player's goal is: **Gather resources, build a base, and then create an army that strikes fear into your enemies to defeat the Dark One, Amon.**

The only condition to defeat Amon is to have a sufficient number of Zealots, which is a randomly generated integer between 20 and 100 by the system. Simultaneously, the system generates just enough uncollected Crystal for you to defeat Amon based on this number.

**Why just enough?**

Since warping in Zealots requires a sufficient amount of Crystal energy and Crystal, and Pylons providing energy also consume Crystal to produce. Therefore, if you build too many Pylons, although you'll have enough energy, you will **lose this battle that determines the fate of the entire universe because you don't have enough Crystal to warp in Zealots**.

The entire logic is provided by an object whose lifecycle spans the entire battle. To prevent issues, I added thread locks to ensure each operation is atomic.

```python
# Since it is the core of the entire game, I call it the Nexus.
import random
from threading import Lock


class Nexus(object):
    _lock = Lock()
    crestalInControl = None
    crestalRemain = None
    populationCap = None
    zealot = None
    status = {}
    _amond = None

    def __init__(self):
        # Initialize the object
        self._amond = random.randint(20, 100)
        self.crestalRemain = self._amond * 100 + (self._amond // 5 + 1) * 100
        self.crestalInControl = 0
        self.populationCap = 0
        self.zealot = 0

    def collect(self, amount=1000):
        # Collect Crystal
        with self._lock:
            amount = min(amount, self.crestalRemain)
            self.crestalRemain -= amount
            self.crestalInControl += amount
            return amount

    def transport(self, amount=5):
        # Warp in Zealots
        with self._lock:
            capacity = self.populationCap / 2
            available = self.crestalInControl / 100
            amount = min(amount, capacity, available)
            self.zealot += amount
            self.crestalInControl -= amount * 100
            self.populationCap -= amount * 2
            return amount

    def build(self, amount=1):
        # Build Pylons
        with self._lock:
            available = self.crestalInControl / 100
            amount = min(amount, available)
            self.populationCap += amount * 10
            self.crestalInControl -= amount * 100
            return amount

    def forAiur(self):
        # For Aiur!
        with self._lock:
            if self.zealot >= self._amond:
                return True
            else:
                return False

    def getStatus(self, role):
        # Get status
        if role == 'archon':
            return {
                'crestalInControl': self.crestalInControl,
                'crestalRemain': self.crestalRemain,
                'populationCap': self.populationCap,
                'zealot': self.zealot
            }
        elif role == 'pylon_transporter':
            return {
                'crestalInControl': self.crestalInControl,
                'populationCap': self.populationCap
            }
        elif role == 'portal':
            return {
                'crestalInControl': self.crestalInControl,
                'populationCap': self.populationCap,
                'zealot': self.zealot
            }
        else:
            return {}


nexus = Nexus() # Instantiate the object
```

## Conclusion

In fact, each battle in StarCraft II is a typical DAC model: the player dominates everything, and all operations in the game can be seen as transforming the two basic resources, Crystal and Vespene Gas (simplified here), into the resources the player needs (production units, combat units) and consuming the enemy's resources to win the battle. This shows that the RESTful service concept is very universal.

In the small game **For Aiur**, I solidified several roles to construct an RBAC model.

Through this practice, I gained an understanding of RBAC's application in a system, further learned the excellent Flask framework, and deepened my understanding of RESTful principles, reaping many benefits.