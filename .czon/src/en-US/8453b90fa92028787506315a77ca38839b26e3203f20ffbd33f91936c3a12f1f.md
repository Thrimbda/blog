---
"title": "Tinkering with a New Blog: I've Moved My Gcores Feed into the Blog"
"summary": "This article details the author's process of rebuilding a new blog after the old one failed. The author chose Zola as the static site generator and focuses on how to obtain personal Gcores feed data by analyzing the Gcores API, using RxJS to handle data streams, and ultimately generating Markdown documents. Furthermore, the article delves into implementing frontend interactive effects for a sliding image gallery by writing HTML, CSS, and JavaScript, and shares the joy brought by the feedback loop during coding. The article not only showcases specific technical implementations but also reflects on the relationship between work and happiness, emphasizing the importance of efficient feedback loops for creativity."
"tags":
  - "Blog"
  - "Technology"
  - "Frontend Development"
  - "Zola"
  - "RxJS"
  - "API"
  - "Personal Project"
  - "Programming Joy"
"date": "2024-06-18"
---

**This article was born from my undying childlike curiosity.**

In April, during a trip, I had a strong urge to write a travelogue, which I first posted on Gcores. As per my usual practice, I would then organize a Markdown version to post on my own blog.

However, after finishing the editing, I found that my blog was broken.

## The Old Blog

The trend of setting up personal blogs became popular in our department during my junior year. Seven years ago, [this](<[搭好博客后的一点话](./da-hao-bo-ke-hou-de-yi-dian-hua/)>) cringe-inducing article of mine described the initial thoughts and feelings I had when I first built this blog.

As for the reasons, firstly, I wanted to push myself to write something; secondly, I wanted to do some engineering practice, combining some fancy, trendy technologies not taught in school; and having a domain name was really cool, at least I thought so.

Let's reenact the scene back then:

---

After learning a tiny bit of something new, with an excited heart, I would hurriedly record my thoughts into a Markdown document.

After writing, I would nonchalantly execute a few commands to push the new blog post:

```shell
$ git add .
$ git commit -m "new blog! hahahaha"
$ git push origin master
```

Then, eagerly opening the CI interface—CI was still somewhat trendy back then, the DevOps concept having only been proposed a few years prior. On the CI log page, I would wait for the entire blog, including this article, to be built into a static HTML website, wait for Travis to push the build artifacts to the git repository using my key, and wait for Github to publish the build artifacts.

Finally, I would enter my domain [https://blog.thrimbda.com](https://blog.thrimbda.com) and contentedly watch the new article appear at the very top of the page.

---

Over the years, this process became boring, boring yet consistently effective, until the day it finally failed.

## The New Blog

On that day at the end of April, I retried the CI pipeline three times in a row, and all failed. A quick glance at the logs revealed that a certain dependency used for building seemed to have disappeared from the internet due to being too old. I realized what a huge time span seven years is in this industry—long enough for sandstorms to destroy castles and seawater to swallow mountains.

So, during idle moments at work, with some not-so-exciting requirements, I made a technology selection: **simple enough, convenient enough.**

This new blog was born. As per tradition, let me introduce it:

- Chose [Zola](https://www.getzola.org/) as the generator;

- Found a very simple but quite nice-looking [theme](https://github.com/Speyll/anemone);

As a replacement for the old blog, this new blog was complete.

## The Childlike Tinkering Process

Perhaps because it was new enough, or because the technology selection was simple enough, or maybe because the feedback loop in frontend work is short enough, coupled with inevitably picking up some frontend knowledge from working with Azheng, filling in the knowledge gaps I didn't study seriously in my freshman year, the process of tinkering with the blog became fun again.

Some small-scale CSS style modifications, adding a new gitcus, hosting the comment section on Github; I reached an agreement with my seven-years-ago self: coding and tinkering with engineering is indeed a joyful thing, the joy of labor, the joy of play.

I want to ride the tailwind of this joy to focus on (and indulge in) explaining the technical process of moving my Gcores feed into the blog.

<!--more-->

---

### Data

During a previous exploration, I discovered that Gcores is incredibly friendly to crawlers. Its data interfaces are very uniform and expressive. For example, exploring my feed:

![gcores-api-at-glance](https://0xc1.space/images/2024/06/18/gcores-api-at-glance.jpg)

Found that this is the API for requesting feed data:

```
https://www.gcores.com/gapi/v1/users/464460/recommend?talk-include=topic%2Cuser%2Chelpful%2Cpoll-options%2Crelated-content.radio%2Crelated-content.video%2Crelated-content.article%2Crelated-content.game%2Crelated-content.film%2Crelated-content.album%2Crelated-content.album-bundle%2Crelated-content.product%2Crelated-content.discussion&original-include=user%2Cdjs%2Ccategory&order-by=time&before=1718720726.986&fields[articles]=title%2Cdesc%2Cexcerpt%2Cis-published%2Cthumb%2Capp-cover%2Ccover%2Ccomments-count%2Clikes-count%2Cbookmarks-count%2Cis-verified%2Cpublished-at%2Coption-is-official%2Coption-is-focus-showcase%2Cduration%2Cdraft%2Caudit-draft%2Cuser%2Ccomments%2Ccategory%2Ctags%2Centries%2Centities%2Csimilarities%2Clatest-collection%2Ccollections%2Coperational-events%2Cportfolios%2Ccatalog-tags&fields[videos]=title%2Cdesc%2Cexcerpt%2Cis-published%2Cthumb%2Capp-cover%2Ccover%2Ccomments-count%2Clikes-count%2Cbookmarks-count%2Cis-verified%2Cpublished-at%2Coption-is-official%2Coption-is-focus-showcase%2Cduration%2Cdraft%2Caudit-draft%2Cuser%2Ccomments%2Ccategory%2Ctags%2Centries%2Centities%2Csimilarities%2Clatest-collection%2Ccollections%2Coperational-events%2Cportfolios%2Ccatalog-tags%2Cmedia%2Cdjs%2Calbums%2Cpublished-albums&fields[radios]=title%2Cdesc%2Cexcerpt%2Cis-published%2Cthumb%2Capp-cover%2Ccover%2Ccomments-count%2Clikes-count%2Cbookmarks-count%2Cis-verified%2Cpublished-at%2Coption-is-official%2Coption-is-focus-showcase%2Cduration%2Cdraft%2Caudit-draft%2Cuser%2Ccomments%2Ccategory%2Ctags%2Centries%2Centities%2Csimilarities%2Clatest-collection%2Ccollections%2Coperational-events%2Cportfolios%2Ccatalog-tags%2Cmedia%2Cdjs%2Clatest-album%2Calbums%2Cis-free%2Cis-require-privilege
```

#### Raw Data

Let's extract the key information:

```ts
const user = 464460;

const url = new URL(
  `https://www.gcores.com/gapi/v1/users/${user}/recommend?talk-include=topic%2Cuser%2Chelpful%2Cpoll-options%2Crelated-content.radio%2Crelated-content.video%2Crelated-content.article%2Crelated-content.game%2Crelated-content.film%2Crelated-content.album%2Crelated-content.album-bundle%2Crelated-content.product%2Crelated-content.discussion&original-include=user%2Cdjs%2Ccategory&order-by=time&fields[articles]=title%2Cdesc%2Cexcerpt%2Cis-published%2Cthumb%2Capp-cover%2Ccover%2Ccomments-count%2Clikes-count%2Cbookmarks-count%2Cis-verified%2Cpublished-at%2Coption-is-official%2Coption-is-focus-showcase%2Cduration%2Cdraft%2Caudit-draft%2Cuser%2Ccomments%2Ccategory%2Ctags%2Centries%2Centities%2Csimilarities%2Clatest-collection%2Ccollections%2Coperational-events%2Cportfolios%2Ccatalog-tags&fields[videos]=title%2Cdesc%2Cexcerpt%2Cis-published%2Cthumb%2Capp-cover%2Ccover%2Ccomments-count%2Clikes-count%2Cbookmarks-count%2Cis-verified%2Cpublished-at%2Coption-is-official%2Coption-is-focus-showcase%2Cduration%2Cdraft%2Caudit-draft%2Cuser%2Ccomments%2Ccategory%2Ctags%2Centries%2Centities%2Csimilarities%2Clatest-collection%2Ccollections%2Coperational-events%2Cportfolios%2Ccatalog-tags%2Cmedia%2Cdjs%2Calbums%2Cpublished-albums&fields[radios]=title%2Cdesc%2Cexcerpt%2Cis-published%2Cthumb%2Capp-cover%2Ccover%2Ccomments-count%2Clikes-count%2Cbookmarks-count%2Cis-verified%2Cpublished-at%2Coption-is-official%2Coption-is-focus-showcase%2Cduration%2Cdraft%2Caudit-draft%2Cuser%2Ccomments%2Ccategory%2Ctags%2Centries%2Centities%2Csimilarities%2Clatest-collection%2Ccollections%2Coperational-events%2Cportfolios%2Ccatalog-tags%2Cmedia%2Cdjs%2Clatest-album%2Calbums%2Cis-free%2Cis-require-privilege`
);
```

Further observation reveals that pagination seems to be determined by a parameter called `before`. By continuously iterating forward with this timestamp parameter until no data is returned, we can write code like this:

```ts
import {
  EMPTY,
  Observable,
  expand,
  map,
  mergeAll,
  mergeMap,
  of,
  shareReplay,
  skip,
  takeWhile,
  tap,
  toArray,
} from "https://esm.sh/rxjs@7.8.1";

const user = 464460;

const url = new URL(
  `https://www.gcores.com/gapi/v1/users/${user}/recommend?talk-include=topic%2Cuser%2Chelpful%2Cpoll-options%2Crelated-content.radio%2Crelated-content.video%2Crelated-content.article%2Crelated-content.game%2Crelated-content.film%2Crelated-content.album%2Crelated-content.album-bundle%2Crelated-content.product%2Crelated-content.discussion&original-include=user%2Cdjs%2Ccategory&order-by=time&fields[articles]=title%2Cdesc%2Cexcerpt%2Cis-published%2Cthumb%2Capp-cover%2Ccover%2Ccomments-count%2Clikes-count%2Cbookmarks-count%2Cis-verified%2Cpublished-at%2Coption-is-official%2Coption-is-focus-showcase%2Cduration%2Cdraft%2Caudit-draft%2Cuser%2Ccomments%2Ccategory%2Ctags%2Centries%2Centities%2Csimilarities%2Clatest-collection%2Ccollections%2Coperational-events%2Cportfolios%2Ccatalog-tags&fields[videos]=title%2Cdesc%2Cexcerpt%2Cis-published%2Cthumb%2Capp-cover%2Ccover%2Ccomments-count%2Clikes-count%2Cbookmarks-count%2Cis-verified%2Cpublished-at%2Coption-is-official%2Coption-is-focus-showcase%2Cduration%2Cdraft%2Caudit-draft%2Cuser%2Ccomments%2Ccategory%2Ctags%2Centries%2Centities%2Csimilarities%2Clatest-collection%2Ccollections%2Coperational-events%2Cportfolios%2Ccatalog-tags%2Cmedia%2Cdjs%2Calbums%2Cpublished-albums&fields[radios]=title%2Cdesc%2Cexcerpt%2Cis-published%2Cthumb%2Capp-cover%2Ccover%2Ccomments-count%2Clikes-count%2Cbookmarks-count%2Cis-verified%2Cpublished-at%2Coption-is-official%2Coption-is-focus-showcase%2Cduration%2Cdraft%2Caudit-draft%2Cuser%2Ccomments%2Ccategory%2Ctags%2Centries%2Centities%2Csimilarities%2Clatest-collection%2Ccollections%2Coperational-events%2Cportfolios%2Ccatalog-tags%2Cmedia%2Cdjs%2Clatest-album%2Calbums%2Cis-free%2Cis-require-privilege`
);

const imageUrl = (image: string) =>
  `https://image.gcores.com/${image}?x-oss-process=image/quality,q_90/format,webp`;

// pagination
url.searchParams.set("before", `${Date.now() / 1000}`);

interface IGcoresTalk {
  text: string;
  images: string[];
  published_at: number;
  tags: string[];
}

const rawGcoresTalkData$: Observable<any[]> = of({
  before: Date.now() / 1000,
}).pipe(
  // raw data
  expand(async ({ before }) => {
    url.searchParams.set("before", `${before}`);
    const res = await fetch(url);
    const data = await res.json();
    if (!data.data || data.data.length === 0) {
      return EMPTY;
    }
    return {
      before:
        new Date(
          data.data[data.data.length - 1].attributes["published-at"]
        ).getTime() / 1000,
      ...data,
    };
  }),
  skip(1),
  // debug
  // take(1),
  takeWhile((v) => !!v.data),
  // filter((v) => v.data.length > 0),
  tap((v) => {
    console.info(v);
  }),
  toArray(),
  shareReplay(1)
);
```

Now we have an Rx stream carrying all the raw feed data for a user.

#### Processing Data

With the raw data, the next step is to process it into Markdown. Let's start processing directly. The key points are:

- Decide what content to display.

- Understand the Gcores interface fields.

The feed is similar to a social media feed like Weibo or Twitter—text with images, plus some tags. Let's display them in a flat layout.

The feed data can be defined as follows:

```json
{
  "blocks": [
    {
      "data": { "spoiler": false },
      "depth": 0,
      "entityRanges": [{ "key": 0, "length": 1, "offset": 0 }],
      "inlineStyleRanges": [],
      "key": "7u4tf",
      "text": "-",
      "type": "atomic"
    },
    {
      "data": { "spoiler": false },
      "depth": 0,
      "entityRanges": [],
      "inlineStyleRanges": [],
      "key": "wisz4",
      "text": "核聚变好玩，和雨川西蒙合了影，见到了做志愿者的 merz，然而社恐差点没敢上前搭话，腿快走断了，给没能来的小朋友们买了点纪念品，Celeste 随机异变速通震撼我妈，全程硬是没把因为震惊而张开的大嘴合上。可惜周天广州下雨航班被取消所以急匆匆买了深圳回上海的高铁票就没去成周天的。",
      "type": "unstyled"
    },
    {
      "data": { "spoiler": false },
      "depth": 0,
      "entityRanges": [],
      "inlineStyleRanges": [],
      "key": "nzffe",
      "text": "",
      "type": "unstyled"
    },
    {
      "data": { "spoiler": false },
      "depth": 0,
      "entityRanges": [],
      "inlineStyleRanges": [],
      "key": "7f8m6",
      "text": "下次还来！",
      "type": "unstyled"
    }
  ],
  "entityMap": {
    "0": {
      "data": {
        "caption": "",
        "images": [
          {
            "path": "0ad6514d154c80a9ef6b4b0d6173d132-3024-4032.HEIC",
            "width": 3024,
            "height": 4032
          },
          {
            "path": "69cea053377d3155d5f7e22e8584f289-4032-3024.HEIC",
            "width": 4032,
            "height": 3024
          },
          {
            "path": "aedf102fa319ce3df2438386f894def4-4032-3024.HEIC",
            "width": 4032,
            "height": 3024
          }
        ]
      },
      "mutability": "IMMUTABLE",
      "type": "GALLERY"
    }
  }
}
```

Combined with the content we want to output, define the following structure:

```ts
interface IGcoresTalk {
  text: string;
  images: string[];
  published_at: number;
  tags: string[];
}
```

What we want to output is simply a `string` type Markdown text.

```ts
const cookedData$ = rawGcoresTalkData$.pipe(
  mergeAll(),
  mergeMap(({ data, included }): IGcoresTalk[] => {
    // we only need the title as the tags of the talk
    const mapTypeIdToTitle = Object.fromEntries(
      included.map((v: any) => [`${v.type}-${v.id}`, v.attributes.title])
    );
    console.info(mapTypeIdToTitle);
    const talks = data
      .filter((v: any) => v.type === "talks")
      .map((v: any) => {
        const content = JSON.parse(v.attributes.content);
        const text = content.blocks
          .filter((v: any) => v.type === "unstyled")
          .map((v: any) => v.text.replace(/\#/, "\\#"))
          .join("\n");

        const images = (content.entityMap?.[0]?.data?.images ?? []).map(
          (v: any) => v.path
        );
        const published_at = new Date(v.attributes["published-at"]).getTime();
        const tags = Object.values(v.relationships as any[])
          .filter((v) => !!v.data)
          .filter((v) => ["topics", "games"].includes(v.data.type))
          .map(({ data }) => mapTypeIdToTitle[`${data.type}-${data.id}`]);
        return {
          text,
          images,
          published_at,
          tags,
        };
      });

    return talks;
  })
);
```

Now we have a bunch of data structures we want. Next, we just need to process them into `string`.

```ts
cookedData$
  .pipe(
    //
    tap((v) => {
      console.info(v);
    }),
    map((v: IGcoresTalk): string => {
      const published_time = new Date(v.published_at);
      const title = `## ${published_time.getFullYear()}-${
        published_time.getMonth() + 1
      }-${published_time.getDate()}`;
      const content = v.text;
      const images = v.images.map((v) => `![${v}](${imageUrl(v)})`).join("\n");
      const tags = v.tags.map((v) => `- ${v}`).join("\n");

      return `${title}\n\n${images}\n\n${content}\n\n${tags}\n`;
    }),
    toArray(),
    map(
      (all) =>
        `---\ntitle: '0xc1 的机组日志'\ndate: ${new Date().toISOString()}\n---\n原始链接：[Thrimbda 的机组](https://www.gcores.com/users/464460/talks)\n${all.join(
          "\n\n---\n---\n\n"
        )}`
    ),
    tap((v) => {
      console.info(v);
    }),
    tap((v) => Deno.writeTextFile(`./content/gcores-talks.md`, v))
  )
  .subscribe();
```

I chose the most straightforward processing method—directly outputting to a nearby directory.

The complete version of this code is [here](https://github.com/Thrimbda/blog/blob/184bad3cbc217b52248dfe169a09fb44aa551328/scripts/get-gcores-talk.ts). Run it via `deno`:

```shell
deno cache get-gcores-talk.ts
deno run -A get-gcores-talk.ts
```

### Image Display and Rendering

At this point, we have output a valid Markdown document, sufficient to render into a decent-looking webpage.

![gcores-pictures-render](https://0xc1.space/images/2024/06/18/gcores-pictures-render.jpg)

But the images look strange: directly rendering them as flat Markdown stacks makes the proportion of images to text very uncoordinated, giving a top-heavy feeling. It would be great if we could make a sliding image gallery like Gcores does.

#### Solution Selection

Markdown supports extending its expressiveness through HTML, so we can always render images directly as HTML with our own code to achieve the desired effect. However, Zola provides another way to achieve our goal more easily: [Shortcodes | Zola](https://www.getzola.org/documentation/content/shortcodes/)

What we need to do is write an HTML template supplemented with appropriate CSS for styling and JS code for interaction; then directly call this HTML in the main Markdown content.

Wait? Writing HTML + CSS + JS, right? It's like going back to freshman year.

#### Writing the Frontend

##### HTML

The HTML part is very simple and boring. For each image gallery, provide the following elements:

- A container for the sliding image gallery itself.

- The images.

- Dots below to indicate the index.

- Arrow buttons to switch images left and right.

```html
<div class="slider-container">
  <div class="slider-wrapper">
    <div class="slider">
      {% for slide in slides %}
      <div class="slider-item">
        <img src="{{slide}}" />
        {% if slide.caption %}
        <div class="caption">{{slide.caption}}</div>
        {% endif %}
      </div>
      {% endfor %}
    </div>
    <button class="slider-prev" type="button">&#10094;</button>
    <button class="slider-next" type="button">&#10095;</button>
  </div>
  <!-- The dots/circles -->
  <div class="slider-dot-container">
    {% for slide in slides %}
    <span class="slider-dot"></span>
    {% endfor %}
  </div>
</div>
```

##### CSS

Thanks to more modern frontend technologies, using flex layout to achieve this is very simple now. The core idea is to arrange the images in a row, but only reveal the space for one image, with all other images hidden behind it:

```css
.slider-wrapper {
  overflow: hidden;
  position: relative;
  box-sizing: border-box;
  width: 100%;
}

.slider {
  position: relative;
  display: flex;
  box-sizing: border-box;
}

.slider-item {
  position: relative;
  flex: 1 0 100%;
  min-height: 150px;
  max-height: min(550px, 55svh);

  display: flex;
  align-items: center;
  justify-items: center;
  box-sizing: border-box;

  overflow: visible;
}

.slider-item img {
  position: relative;
  width: auto;
  max-height: 100%;
  margin: auto; /* Center horizontally */
}

/* Next & previous buttons */
.slider-prev,
.slider-next {
  /* cursor: pointer; */
  position: absolute;
  /* top: 50%; */
  width: auto;
  height: 100%;
  transform: translateY(-100%);
  font-weight: bold;
  font-size: 1.2rem;

  z-index: 1;
  color: white;
  transition: 0.6s ease;
  border-radius: 5px;
  border: none;
  background-color: transparent;
}

/* Position the "next button" to the right */
.slider-next {
  right: 0;
  border-radius: 5px;
  /* border-radius: 3px 0 0 3px; */
}
.slider-prev:hover:enabled,
.slider-next:hover:enabled {
  border: none;
  color: var(--accent);
  background-color: rgba(71, 71, 71, 0.3);
}

.slider-dot-container {
  text-align: center;
}

.slider-dot {
  cursor: pointer;
  height: 15px;
  width: 15px;
  margin: 0 2px;
  background-color: #bbb;
  border-radius: 50%;
  display: inline-block;
  transition: background-color 0.6s ease;
}
.slider-dot:hover,
.slider-dot-active {
  background-color: #717171;
}
```

##### JavaScript

The JS part is responsible for allowing users to switch which specific image is displayed in the visible area through interaction. These interactions include:

- Mouse clicking the left/right buttons.

- Mouse clicking the small dots.

- Left/right swiping on touch devices.

After the web API incorporated JQuery, and with the help of rxjs, this becomes very simple:

```js
const ELS = (selector, parent) =>
  (parent || document).querySelectorAll(selector);
const EL = (selector, parent) => (parent || document).querySelector(selector);
const mod = (n, m) => ((n % m) + m) % m;

ELS(".slider-container").forEach((EL_parent) => {
  const EL_slider = EL(".slider", EL_parent);
  const ELS_items = ELS(".slider-item", EL_parent);
  const ELS_dots = ELS(".slider-dot", EL_parent);
  const total = ELS_items.length;
  let c = 0;

  const setDotActive = () => {
    ELS_dots.forEach((EL_dot, i) => {
      EL_dot.classList.toggle("slider-dot-active", i === c);
    });
  };

  setDotActive();

  const anim = () => {
    EL_slider.style.transform = `translateX(-${c * EL_slider.offsetWidth}px)`;
  };
  const prev = () => {
    distance = 0;
    startX = 0;
    c = mod(c - 1, total);
    setDotActive();
    anim();
  };
  const next = () => {
    distance = 0;
    startX = 0;
    c = mod(c + 1, total);
    setDotActive();
    anim();
  };

  EL(".slider-prev", EL_parent).addEventListener("click", prev);
  EL(".slider-next", EL_parent).addEventListener("click", next);

  ELS(".slider-dot", EL_parent).forEach((dot, i) => {
    dot.addEventListener("click", () => {
      c = i;
      setDotActive();
      anim();
    });
  });

  const touchstart$ = fromEvent(EL_parent, "touchstart");
  const touchend$ = fromEvent(EL_slider, "touchend");
  const touchmove$ = fromEvent(EL_slider, "touchmove");

  touchstart$
    .pipe(
      tap(() => {
        EL_slider.style.transition = "none";
      }),
      switchMap((start) =>
        animationFrames().pipe(
          withLatestFrom(touchmove$),
          map(([, touchEvent]) => {
            const distance =
              touchEvent.touches[0].clientX - start.touches[0].clientX;

            EL_slider.style.transform = `translateX(-${
              c * EL_slider.offsetWidth - distance
            }px)`;
            return distance;
          }),
          takeUntil(touchend$),
          defaultIfEmpty(0),
          last()
        )
      ),
      tap({
        next: (distance) => {
          EL_slider.style.transition = "transform 0.3s ease-in-out";
          if (distance / EL_slider.offsetWidth > 0.2) {
            c = mod(c - 1, total);
          } else if (distance / EL_slider.offsetWidth < -0.2) {
            c = mod(c + 1, total);
          }
          setDotActive();
          anim();
        },
      }),
      repeat()
    )
    .subscribe();
});
```

The general idea of the entire code is to record a current displayed image index `[0, 1, ..., imageNumbers - 1]` for each sliding image gallery. User interaction changes the index, thereby calculating how many pixels the current sliding image gallery should offset to display the image indicated by the index.

I'm quite proud of the last piece of Rx code for touch interaction.

Touch interaction is more complex than button interaction because during the user's swipe, the image must follow the user's finger, and this feel must be tuned well to avoid frustrating the user.

This complexity means the interaction requires more information and more complex WEB APIs.

From an interaction logic perspective, we need to record the pixel position of the finger when the touch starts, and the offset of the finger's pixel position relative to the initial position at each animation frame. Then, during each frame's rendering, add this offset to the sliding image gallery, making the image follow the finger. After moving a certain distance and the finger leaves the screen, we need to decide whether to switch images. For example, if the finger just taps the screen, causing a 2-pixel offset to the right, the image should not switch; but when the finger swipes halfway across the screen to the right, the image should switch. Let's set a threshold of 20% of the offset relative to the entire container width. If the finger swipe distance exceeds 20% of the gallery width, we consider it should switch images.

From an API perspective, there are three relevant events:

- touchstart - Indicates the user starts touching the screen. This event carries the initial finger pixel coordinates.

- touchmove - Triggered whenever the user's finger moves, carrying the current finger coordinates.

- touchend - Indicates the finger leaves the screen.

Rx is very suitable for implementing this type of requirement. We wrap the user's finger touch events into a data stream. After processing, it becomes a stream of horizontal finger offsets, used to update the image position in each animation frame. Finally, after the touch ends, decide whether to switch images based on the ratio of the offset to the container width.

---

### Where Does the Joy Come From?

Work can bring joy because our brains love feedback and loops.

{% mermaid() %}

stateDiagram-v2
    [*] --> Labor
    Labor --> ViewEffect
    ViewEffect --> NotSatisfied
    NotSatisfied --> ThinkAboutProblem
    ThinkAboutProblem --> Labor
    ViewEffect --> SatisfiedLeave
    SatisfiedLeave --> [*]

{% end %}

Pain comes from incomplete or overly long loops. Writing frontend code is so joyful because its loop is efficient enough. Each time you modify the code, with saving and refreshing, you can directly see the effect of the modification. So much so that you can complete several such feedback loops within minutes, thus bringing joy.

I hope this kind of joy can accompany everyone.

## Conclusion

Today, the content discussed in this article could still be considered progressive for a university student's blog, but its depth is somewhat shallow relative to my years of work experience, to the point where I often felt embarrassed while writing it.

But regardless, compared to the haphazard copying when I last built a blog, this time I have complete control over every part of my blog. The tinkering process brought me a very pure and simple joy, and it is precisely this joy that gave me the audacity to finish writing it.