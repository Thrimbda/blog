---
"title": "Internship Log (Part 2): Backend API Development and Project Management Summary"
"summary": "This article is the author's summary log after the basic completion of the backend API server for the internship project. It details the design philosophy of the project 'Seed' (a goal management system primarily targeting WeChat Mini Programs), including clarifying the product positioning, defining core features (such as user system, goal management, multi-client compatibility), and adopting a RESTful API architecture. In terms of implementation, the author explains the choice of technology stack using the Spring ecosystem and shares testing strategies from the development process. Furthermore, the author reflects on shortcomings as a project manager regarding schedule control, personnel allocation, and technical training, and discusses the balance between the system architecture capabilities and specific algorithm implementation skills required of a software engineer, concluding that the internship serves as a crucial supplement to classroom education."
"tags":
  - "Internship"
  - "Project Management"
  - "Backend Development"
  - "Spring Framework"
  - "WeChat Mini Program"
  - "RESTful API"
  - "Software Design"
  - "Personal Summary"
"date": "2017-03-12"
---

---
title: Internship Log (Part 2)
date: 2017-03-12 16:09:19
taxonomies:
  tags:
    - Daily
    - Internship
    - Reflections
---

The internship is nearing its end. The coding work for the basic version of the backend API server is now essentially complete, so I'm summarizing my thoughts here.

As the project team leader, my only knowledge about software project management came from reading *The Mythical Man-Month* once during winter break. Through this practical experience, I've realized I'm still quite green. Nevertheless, I believe I've learned a few things.

<!--more-->

## Design

Compared to two years ago when I would fire up VS without a second thought to write C language assignments, I've clearly changed a bit today.

~~First of all, I haven't opened VS in a long time.~~

In any case, over these two years, I've gone through various concentrated coding experiences: the pure, naive period of learning Python, the trials of writing the upper computer software for the robotics team, the experience of writing crawlers for the academic affairs office website (both teacher and student sides), and developing the file management tool for the Orange Juice project. At the very beginning, I would just charge ahead recklessly, but I guess after suffering enough from inconsistencies, I learned the importance of upfront design. Once you step through the door of design, it becomes a matter of degree—so this experience of overseeing the entire project has been a very beneficial exercise.

**First, clearly define what to do.** This question is crucial for a team genuinely wanting to build a product: **defining your own product** is a strategic-level task. Unfortunately, we didn't have any particularly interesting ideas this time, and with responsibility on my shoulders, my expectation for this internship was to seriously create a reliable, simple project.

In short, it's a **traditional web application with WeChat Mini Programs as its flagship feature**—specifically, a goal management system.

So many people have built this kind of thing, so modeling the tasks we'd face could draw from many mature solutions: tools like Worktile for project orientation; WonderList for personal life management; My Study Life for students; even Apple's `Reminders` and other tools I've heard of but haven't used. Synthesizing the characteristics of these tools, we aimed to create a classic, WeChat-flavored goal management system—this became our project, `Seed`.

### Features It Should Have

So what should `Seed` be able to do?

+ Have a simple user system for easy synchronization and increased user stickiness.
+ Allow users to freely create and manage goals, similar to `projects` in Worktile.
+ Allow users to be invited into others' goals.
+ Goals are categorized into daily check-in types (recurring) and project攻坚 types (one-time, can incorporate milestones).
+ The primary frontend is the WeChat Mini Program.
+ Also compatible with other potential clients.

From this perspective, `Seed` should be a small, streamlined, and practical service, which aligns perfectly with the original intent of WeChat Mini Programs.

It's necessary to emphasize the characteristic of being **"small and streamlined."** Why small and simple? First, limited manpower and time. Second, to avoid the mistake often made in `second-system` projects mentioned in *The Mythical Man-Month*: blind arrogance, frantically adding endless redundant features to a project. This is a thankless and foolish endeavor, especially since—we're not dealing with advertising revenue. A simple example: Mac OS版迅雷 and Win版迅雷, obviously everyone prefers the streamlined and usable Mac version.

It must also have good compatibility with WeChat Mini Programs. To provide a smooth user experience, it should support both email as a user login identifier and WeChat openId as a login credential.

### System Architecture

As mentioned above, we aim to build a web application with WeChat Mini Programs as its flagship feature. This means `Seed` has the capability ~~and ambition~~ to be compatible with other frontends. Therefore, a RESTful-style API becomes the best choice: complete decoupling of frontend and backend, clear structure, and easy consumption.

Thus, `Seed` should consist of a WeChat Mini Program and other potential forms as the frontend, consuming `resources` provided by the backend via the HTTP protocol.

The backend provides secure and reliable services through APIs.

I also learned a bit about this, encountering the concept of HATEOAS (Hypermedia As The Engine Of Application State). Although not yet mature, it represents a possible future.

## Implementation

Since I only participated in the coding work for the API server, I'll only discuss the backend implementation here.

I like to categorize design as the strategic level (the "Tao"), and the remaining work as the tactical level (the "Shu"). Therefore, choosing which technologies to use and how to specifically implement a system falls into the latter category.

### Technology Stack

Due to internship requirements and a desire to use the Java language appropriately, we chose the `Spring Framework` as the backend framework, along with the Spring ecosystem:

+ Spring Boot as the application container
+ Spring Framework for implementing business logic
+ Spring Data as the DAO
+ Spring Session for session management
+ Spring test for testing

Additionally, we used tools like Git, Travis CI, and Heroku to improve the development experience.

### Development Process

As mentioned before, the experience of writing Spring Controllers is quite similar to that of Python's Flask web framework. Perhaps Flask drew some inspiration from Spring? I think resource-oriented controller classes are much more compact compared to the traditional Java Web approach of writing a Servlet for each resource.

Spring advocates Test-Driven Development (TDD). Actually doing this consistently isn't easy, as testing isn't always a popular task. Assigning a dedicated person to write test code would involve a high learning cost and some interpersonal complications. So during development, I decided to have each person responsible for testing their own code. I would then review all the code.

## Summary

The noteworthy parts about `Seed` itself have been covered. Now, let's talk about other things.

### Self-Reflection

I learned a lot during the internship, but problems remain.

As a project manager, I was pretty terrible. There were significant shortcomings in controlling the schedule, allocating personnel, and handling other details.

For example:
- Lack of knowledge about frontend technologies likely means only the API server will be functional by the end of this project.
- Only half of the project team members were truly engaged.
- Training for those who did participate felt hollow and lacked patience.

Clearly, I need further development. However, serving as both project manager and developer led me to ponder another issue.

### Discussion on Two Types of Abilities for Software Engineers

**The ability to architect and oversee an entire system** versus **the ability to choose, tailor, and implement algorithms for a single function.**

The classroom education in our university's software school seems to focus only on the latter. This isn't particularly strange, as mastery of algorithms is easily measurable. One could say the difference in ability is stark, much like solving math problems—people's creativity is very easy to evaluate under strict preconditions and constraints. But the ability to reasonably set these so-called "strict preconditions and constraints," while important, is difficult to measure.

As for why this is contradictory, here's a simple, understandable, though perhaps not perfectly apt, example: Everyone knows it's naive and unrealistic for parents to forbid their children from early romance for fear of hindering studies, yet expect them to start a family immediately after graduation. Similarly, implicitly expecting students to become all-round talents after graduation **solely** based on good academic performance is a slightly distorted notion. The difference is that the contradiction in the latter case is not as sharp as in the former.

I believe such internships are indeed a compensation for the shortcomings of classroom education and offer an opportunity to avoid the contradiction between **grades** as a cultivation method and **capability** as the cultivation goal.