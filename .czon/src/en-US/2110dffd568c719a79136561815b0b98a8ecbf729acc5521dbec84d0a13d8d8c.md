---
"title": "Internship Log (II): Backend API Development and Project Management Summary"
"summary": "This article is the author's summary log after the basic completion of the backend API server for the internship project. The article elaborates on the design philosophy of the project 'Seed' (a goal management system primarily targeting WeChat Mini Programs), including clarifying product positioning, defining core features (such as user system, goal management, multi-client compatibility, etc.), and adopting a RESTful API architecture. In terms of implementation, the author introduces the selection of the technology stack, including the Spring ecosystem, and shares testing strategies during the development process. Additionally, the author reflects on shortcomings as a project manager in areas such as progress control, personnel allocation, and technical training. The article also discusses the balance between the system architecture capabilities and specific algorithm implementation skills required of a software engineer, viewing the internship as an important supplement to classroom education."
"tags":
  - "Internship"
  - "Project Management"
  - "Backend Development"
  - "Spring Framework"
  - "WeChat Mini Program"
  - "RESTful API"
  - "Software Design"
  - "Personal Summary"
"date": "2017-03-12"
---

---
title: Internship Log (II)
date: 2017-03-12 16:09:19
taxonomies:
  tags:
    - Daily
    - Internship
    - Reflections
---

The internship is nearing its end, and the coding work for the basic version of the backend API server is essentially complete. Here’s a summary.

As the project team leader, my only knowledge about software project management comes from reading *The Mythical Man-Month* once during the winter break. Through this practical experience, I realized I’m still too inexperienced. However, I believe I’ve learned a few things.

<!--more-->

## Design

Compared to two years ago when I would immediately open Visual Studio to work on C language assignments without a second thought, I’ve clearly changed a bit today.

~~First of all, I haven’t opened Visual Studio in a long time.~~

In any case, over the past two years, I’ve gone through various intensive coding experiences: from the naive and pure days of learning Python, to the training of writing the upper computer software for the robotics team, or the experience of writing crawlers for the academic affairs website’s teacher and student portals, and participating in the Orange Juice project to develop a file management tool. At the beginning, I would just dive in recklessly, but I guess after suffering enough from contradictions, I learned the importance of planning ahead. Once I stepped into the world of design, the next step was about the extent of it—so this experience of overseeing the entire project was a very beneficial exercise.

**First, clarify what to do.** This question is crucial for a team genuinely wanting to create a product: **defining your product** is a strategic-level task. Unfortunately, this time, there weren’t any particularly interesting ideas, but with responsibility on my shoulders, my expectation for this internship was to seriously create a reliable, simple project.

In short, it’s a **traditional web application with WeChat Mini Programs as its main feature**—specifically, a goal management system.

This has been done by so many people that modeling the tasks we’d face could draw from many mature solutions: tools like Worktile for project management, WonderList for personal life management, My Study Life for students, and even Apple’s Reminders and other tools I’ve heard of but never used. By synthesizing the features of these tools, we summarized a classic, WeChat-style goal management system—this became our project, `Seed`.

### Features It Should Have

So, what should `Seed` be able to do?

+ Have a simple user system to facilitate synchronization and increase user engagement.
+ Users can freely create and manage goals, similar to Worktile’s “projects.”
+ Users can be invited to join others’ goals.
+ Goals are divided into daily check-in types (recurring) and project-focused types (one-time, with milestones possible).
+ The primary frontend is WeChat Mini Programs.
+ Also compatible with other potential clients.

From this perspective, `Seed` should be a small, streamlined, and practical service, which aligns perfectly with the original intent of WeChat Mini Programs.

Here, it’s essential to emphasize the characteristic of being **“small and streamlined.”** Why small and simple? First, there aren’t enough people and time is limited. Second, to avoid the mistakes mentioned in *The Mythical Man-Month* that “second projects” are prone to: blind arrogance and endlessly adding redundant features to a project. This is a thankless and foolish endeavor, especially since—we’re not dealing with advertising revenue. A simple example: Mac OS version of Thunder vs. Windows version of Thunder; obviously, everyone prefers the streamlined and usable Mac version.

At the same time, it must have good compatibility with WeChat Mini Programs. To provide a smooth user experience, it should support both email as a login credential and WeChat openId as a login credential.

### System Structure

As mentioned earlier, we’re building a web application with WeChat Mini Programs as its main feature, meaning `Seed` has the ability ~~and ambition~~ to be compatible with other frontends. Therefore, a RESTful-style API becomes the best choice: complete decoupling of frontend and backend, clear structure, and easy consumption.

Thus, `Seed` should be a system where WeChat Mini Programs and other potential forms act as the frontend, consuming “resources” provided by the backend via the HTTP protocol.

The backend provides secure and reliable services through APIs.

For this, I also learned a bit and came across the concept of HATEOAS (Hypermedia As The Engine Of Application State). Although not yet mature, it represents a possible future.

## Implementation

Since I only participated in the coding work for the API server, I’ll only discuss the backend implementation here.

I like to categorize design as the strategic level (the “way”), and the remaining work as the tactical level (the “technique”). Therefore, choosing what technology to use and how to specifically implement a system falls into this category.

### Technology

Due to the internship requirements and a desire to use the Java language appropriately, I chose the `Spring Framework` as the backend framework, along with the entire Spring ecosystem:

+ Spring Boot as the application container
+ Spring Framework for implementing business logic
+ Spring Data as the DAO
+ Spring Session for session management
+ Spring Test for testing

Additionally, tools like Git, TravisCI, and Heroku were used to improve the development experience.

### Development Process

As mentioned earlier, the experience of writing Spring Controllers is very similar to that of Python’s Flask web framework. Perhaps Flask drew some inspiration from Spring? Resource-oriented controller classes feel much more compact compared to the traditional Java Web approach of writing a Servlet for each resource.

Spring advocates test-driven development, but actually doing this isn’t easy, as testing isn’t always a popular task. Assigning a dedicated person to write test code would involve high learning costs and some interpersonal issues. So, during development, I decided to have each person test the code they wrote, with me ultimately reviewing the code.

## Summary

The noteworthy parts about `Seed` itself have been covered. Now, let’s talk about other things.

### Self-Reflection

I learned a lot during the internship, but there are still issues.

As a project manager, I’m quite inexperienced. There are significant shortcomings in controlling progress, allocating personnel, and handling other details.

For example:

- Lack of knowledge about frontend technologies means this project might only have a working API server in the end.
- Only half of the project team members truly participated.
- Training for those who did participate felt hollow and lacked patience.

Clearly, I still need further development. However, being both a project manager and a developer led me to think about another issue.

### Discussion on Two Types of Abilities for Software Engineers

**The ability to architect and oversee the entire system** and **the ability to choose, tailor, and implement algorithms for individual functions.**

The classroom education at our university’s software school seems to focus only on the latter. This isn’t strange, as mastery of algorithms is easy to measure, and differences in ability are obvious—like solving math problems, where people’s creativity is easy to evaluate under strict preconditions and constraints. However, the ability to reasonably set these so-called “strict preconditions and constraints,” while important, is difficult to measure.

As for why this is contradictory, here’s a simple and understandable, though perhaps not entirely appropriate, example: everyone knows it’s naive and unrealistic for parents to forbid their children from dating early under the pretext of fearing it will interfere with studies, yet expect them to start a family immediately after graduation. Similarly, implicitly expecting students to become all-round talents after graduation **solely** based on good academic performance is a slightly distorted idea. The difference is that the latter contradiction isn’t as sharp as the former.

I believe such internships are indeed a compensation for the shortcomings of classroom education and offer an opportunity to avoid the contradiction between **grades** as a means of cultivation and **ability** as the goal of cultivation.